# RTCInboundRtpStreamStats: qpSum property

{{APIRef("WebRTC")}}

The **`qpSum`** property of the {{domxref("RTCInboundRtpStreamStats")}} dictionary indicates the sum of the **Quantization Parameter** (**QP**) values for every frame sent or received on the video track corresponding to this `RTCInboundRtpStreamStats` object.

In general, a larger numbers indicates that the video data is more heavily compressed.

> [!NOTE]
> This value is only available for video media.

## Value

A positive integer.

## Description

[Quantization](https://en.wikipedia.org/wiki/Quantization) is the process of applying lossy compression to a range of values, resulting in a single **quantum value**.
This value takes the place of the range of values, thereby reducing the number of different values that appear in the overall data set, making the data more compressible.
The quantization process and the amount of compression can be controlled using one or more parameters.

It's important to keep in mind that the value of QP can change periodically—even every frame—so it's difficult to know for certain how substantial the compression is.
The best you can do is make an estimate.
You can, for example, use the value of {{domxref("RTCReceivedRtpStreamStats.framesDecoded")}} if receiving the media (or {{domxref("RTCSentRtpStreamStats.framesEncoded")}} if sending it) to get the number of frames handled so far, and compute an average from there.
See [Calculating average quantization](#calculating_average_quantization) below for a function that does this.

Also, the exact meaning of the QP value depends on the {{Glossary("codec")}} being used.
For example, for the VP8 codec, the QP value can be anywhere from 1 to 127 and is found in the frame header element `"y_ac_qi"`, whose value is defined in {{RFC(6386, "", "19.2")}}.
H.264 uses a QP which ranges from 0 to 51; in this case, it's an index used to derive a scaling matrix used during the quantization process.
Additionally, QP is not likely to be the only parameter the codec uses to adjust the compression. See the individual codec specifications for details.

## Examples

### Calculating average quantization

The `calculateAverageQP()` function shown below computes the average QP for the given {{domxref("RTCStatsReport")}} object that contains RTP stream statistics, returning 0 if the object doesn't describe an RTP stream.

```js
function calculateAverageQP(stats) {
  let frameCount = 0;

  switch (stats.type) {
    case "inbound-rtp":
    case "remote-inbound-rtp":
      frameCount = stats.framesDecoded;
      break;
    case "outbound-rtp":
    case "remote-outbound-rtp":
      frameCount = stats.framesEncoded;
      break;
    default:
      return 0;
  }

  return status.qpSum / frameCount;
}
```

Note that QP values can vary from codec to codec.
This value is therefore only potentially useful when compared against the same codec.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCInboundRtpStreamStats: remoteId property

{{APIRef("WebRTC")}}

The **`remoteId`** property of the {{domxref("RTCInboundRtpStreamStats")}} dictionary specifies the {{domxref("RTCInboundRtpStreamStats.id", "id")}} of the {{domxref("RTCRemoteOutboundRtpStreamStats")}} object representing the remote peer's {{domxref("RTCRtpSender")}} which is sending the media to the local peer.

## Value

A string.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCInboundRtpStreamStats: removedSamplesForAcceleration property

{{APIRef("WebRTC")}}

The **`removedSamplesForAcceleration`** property of the {{domxref("RTCInboundRtpStreamStats")}} dictionary accumulates the difference between the number of samples played out of the {{glossary("jitter","jitter buffer")}} and the number of samples received while audio playout is sped up.

The WebRTC jitter buffer sets a target playout delay level such that the inflow and outflow of the jitter buffer should be approximately the same.
If the jitter buffer empties too slowly the audio sample that is next in line to be output may be "behind schedule", and the engine may speed up playout to catch up.
If the engine speeds up playout by removing some audio samples, this property indicates the accumulated number of such removed samples.

Speeding up or slowing down the audio (as tracked with {{domxref("RTCInboundRtpStreamStats.insertedSamplesForDeceleration","insertedSamplesForDeceleration")}}) may result in audible warbling or other distortion.
The totals at the end of the call also give you some indication of how many samples or seconds were impacted, and `removedSamplesForAcceleration` can be correlated with {{domxref("RTCInboundRtpStreamStats/totalSamplesReceived","totalSamplesReceived")}} to get a relative measure of acceleration.
Logging `insertedSamplesForDeceleration` and `removedSamplesForAcceleration` in timeslices can be helpful for isolating the times at which the problem occurred and you can then correlate other metrics in the same timeslice to determine likely causes.

> [!NOTE]
> The value is undefined for video streams.

## Value

A positive integer.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCInboundRtpStreamStats.insertedSamplesForDeceleration","insertedSamplesForDeceleration")}}
- [The better way](https://webrtchacks.com/how-webrtcs-neteq-jitter-buffer-provides-smooth-audio/#post-4560-_mv3ivinthkf5) in "How WebRTC's NetEQ Jitter Buffer Provides Smooth Audio" (webrtchacks.com, June 2025)
# RTCInboundRtpStreamStats: silentConcealedSamples property

{{APIRef("WebRTC")}}

The **`silentConcealedSamples`** property of the {{domxref("RTCInboundRtpStreamStats")}} dictionary indicates the total number of silent concealed samples for the received audio track over the lifetime of this stats object.

A concealed sample is a sample that was lost or arrived too late to be played out, and therefore had to be replaced with a locally generated synthesized sample.
A silent concealed sample is one where the inserted sample is either silent or [comfort noise](https://en.wikipedia.org/wiki/Comfort_noise).

> [!NOTE]
> The value is undefined for video streams.

## Value

A positive integer.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCInboundRtpStreamStats.concealedSamples")}}
- {{domxref("RTCInboundRtpStreamStats.concealmentEvents")}}
- [Packet loss concealment](https://en.wikipedia.org/wiki/Packet_loss_concealment) on Wikipedia
# RTCInboundRtpStreamStats: ssrc property

{{APIRef("WebRTC")}}

The **`ssrc`** property of the {{domxref("RTCInboundRtpStreamStats")}} dictionary identifies the synchronization source (SSRC) of this stream of {{Glossary("RTP")}} packets.

## Value

A positive integer.

## Description

The **`ssrc`** property uniquely identifies the SSRC of the RTP packets whose statistics are covered by this {{domxref("RTCInboundRtpStreamStats")}} object.

A synchronization source might be something like a microphone, or a mixer application that combines multiple sources.
All packets from the same source share the same time source and sequence space, and so can be ordered relative to each other.
Note that two streams with the same `ssrc` value refer to the same source.

The manner in which SSRC values are generated is not mandated by the specification, although it does make recommendations.
You should not make any assumptions based on the value of `ssrc` other than that any two objects with the same `ssrc` value refer to the same source.
See {{RFC("3550", "", "8")}} for additional information about `ssrc`.

> [!NOTE]
> The specification includes an example that generates values for `ssrc` using MD5.
> While not part of the standard, exactly, it is a good mechanism that may be used by some browsers; others may use other methods, such as random number generators.
> _Do not_ rely upon these values meaning anything other than "these objects are associated with the same source."

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCRtpReceiver.getSynchronizationSources()")}}
- {{domxref("RTCEncodedAudioFrame.getMetadata()")}}
# RTCInboundRtpStreamStats: timestamp property

{{APIRef("WebRTC")}}

The **`timestamp`** property of the {{domxref("RTCInboundRtpStreamStats")}} dictionary is a {{domxref("DOMHighResTimeStamp")}} object specifying the time at which the data in the object was sampled.

## Value

A {{domxref("DOMHighResTimeStamp")}} value indicating the time at which the activity described by the statistics in this object was recorded, in milliseconds elapsed since the beginning of January 1, 1970, UTC.

The value should be accurate to within a few milliseconds but may not be entirely precise, either because of hardware or operating system limitations or because of [fingerprinting](/en-US/docs/Glossary/Fingerprinting) protection in the form of reduced clock precision or accuracy.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCInboundRtpStreamStats: totalAssemblyTime property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`totalAssemblyTime`** property of the {{domxref("RTCInboundRtpStreamStats")}} dictionary indicates the total time spent assembling successfully decoded video frames that were transported in multiple RTP packets.

> [!NOTE]
> The value is undefined for audio streams.

## Value

A number, in seconds.

## Description

The property is updated whenever a video frame that was transported in multiple RTP packets is successfully decoded.
The time increment is calculated by subtracting the timestamp of the last and first RTP packets that contained the video frame data.
The time is not updated for video frames that are not decoded, or that are transported entirely within one RTP packet.

The average assembly time can be determined by dividing `totalAssemblyTime` by {{domxref("RTCInboundRtpStreamStats/framesAssembledFromMultiplePackets","framesAssembledFromMultiplePackets")}}.
A higher average assembly time might indicate network issues or inefficiencies in the receiving pipeline.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCInboundRtpStreamStats: totalAudioEnergy property

{{APIRef("WebRTC")}}

The **`totalAudioEnergy`** property of the {{domxref("RTCInboundRtpStreamStats")}} dictionary represents the total audio energy of a received audio track over the lifetime of this stats object.

The total energy across a particular duration can be determined by subtracting the value of this property returned by two different `getStats()` calls.

> [!NOTE]
> The value is undefined for video streams.

## Value

A number produced by summing the energy of every sample over the lifetime of this stats object.

The energy of each sample is calculated by dividing the sample's value by the highest-intensity encodable value, squaring the result, and then multiplying by the duration of the sample in seconds.
This is shown as an equation below:

<!-- prettier-ignore-start -->
<math display="block">
  <semantics><mrow><mi>duration</mi><mo>×</mo><msup><mrow><mo>(</mo><mfrac><mi>sample_level</mi><mi>max_level</mi></mfrac><mo>)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="TeX">duration \times⁢ \left(\left(\right. \frac{sample{\_}level}{max{\_}level} \left.\right)\right)^{2}</annotation></semantics>
</math>
<!-- prettier-ignore-end -->

Note that if multiple audio channels are used, the audio energy of a sample refers to the highest energy of any channel.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCAudioSourceStats.totalAudioEnergy")}} for audio energy of local tracks (that are being sent)
# RTCInboundRtpStreamStats: totalDecodeTime property

{{APIRef("WebRTC")}}

The **`totalDecodeTime`** property of the {{domxref("RTCInboundRtpStreamStats")}} dictionary indicates the total time spend decoding frames for this media source/stream, in seconds.

The time it takes to decode one frame is the time passed between feeding the decoder a frame and the decoder returning decoded data for that frame.

The number of decoded frames is given in {{domxref("RTCInboundRtpStreamStats.framesDecoded", "framesDecoded")}}, and the average decode time is `totalDecodeTime / framesDecoded`.

> [!NOTE]
> The property is undefined for audio streams.

## Value

An positive number, in seconds.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCInboundRtpStreamStats.framesDecoded", "framesDecoded")}}
# RTCInboundRtpStreamStats: totalFreezesDuration property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`totalFreezesDuration`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary indicates the total time that the video in this stream has spent frozen, in seconds.

A freeze is counted if the interval between two rendered frames is equal or greater than the larger of "three times the average duration", or "the average + 150ms", and the time taken between frames is added to the `totalFreezesDuration`.

The average freeze duration can be calculated using `totalFreezesDuration / freezeCount`.

> [!NOTE]
> The property is undefined for audio streams.

## Value

An positive number, in seconds.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCInboundRtpStreamStats.freezeCount", "freezeCount")}}
# RTCInboundRtpStreamStats: totalInterFrameDelay property

{{APIRef("WebRTC")}}

The **`totalInterFrameDelay`** property of the {{domxref("RTCInboundRtpStreamStats")}} dictionary indicates the total accumulated time between consecutively rendered frames, in seconds.
It is recorded after each frame is rendered.

The inter-frame delay variance can be calculated from `totalInterFrameDelay`, {{domxref("RTCInboundRtpStreamStats.totalSquaredInterFrameDelay","totalSquaredInterFrameDelay")}} , and {{domxref("RTCInboundRtpStreamStats.framesRendered","framesRendered")}} according to the formula: `(totalSquaredInterFrameDelay - totalInterFrameDelay^2/ framesRendered)/framesRendered`.

> [!NOTE]
> The property is undefined for audio streams.

## Value

A positive number, in seconds.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCInboundRtpStreamStats: totalPausesDuration property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`totalPausesDuration`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary indicates the total time that the video in this stream has spent paused, in seconds

A pause is counted when a new frame is rendered more than 5 seconds after the last frame was rendered, and the time taken between frames is added to the `totalPausesDuration`.

The average pause duration can be calculated using `totalPausesDuration / pauseCount`.

> [!NOTE]
> The property is undefined for audio streams.

## Value

An positive number, in seconds.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCInboundRtpStreamStats.pauseCount", "pauseCount")}}
# RTCInboundRtpStreamStats: totalProcessingDelay property

{{APIRef("WebRTC")}}

The **`totalProcessingDelay`** property of the {{domxref("RTCInboundRtpStreamStats")}} dictionary indicates the total accumulated time spent processing audio or video samples, in seconds.

The processing time for each audio or video sample is calculated from the time the first RTP packet is received (reception timestamp) to the time that the corresponding sample or frame is decoded (decoded timestamp).
At this point the audio sample or video frame is fully decoded by the decoder and is ready for playout by the {{domxref("MediaStreamTrack")}}.

For audio streams, an RTP packet may contain multiple audio samples: these will share the same reception timestamp.
For video streams, a complete frame may arrive in several RTP packets, and the reception timestamp is that of the first RTP packet that was received that contains data for the frame.
In both cases the decoded timestamp is the time at which the sample or frame is ready to play.

For video, the property only accumulates for decoded frames (not those that were dropped).
The average processing delay can be calculated by dividing the `totalProcessingDelay` with the {{domxref("RTCInboundRtpStreamStats.framesDecoded","framesDecoded")}}. <!-- audio samples can't get average - totalSamplesDecoded not in spec yet or implemented -->

## Value

A positive number, in seconds.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCInboundRtpStreamStats: totalSamplesDuration property

{{APIRef("WebRTC")}}

The **`totalSamplesDuration`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary indicates the total duration of all audio samples that have been received.
In other words, the current duration of the track.

This can be used with {{domxref("RTCInboundRtpStreamStats/totalAudioEnergy","totalAudioEnergy")}} to compute an average audio level over different intervals.

> [!NOTE]
> The value is undefined for video streams.

## Value

An positive number, in seconds.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCAudioSourceStats.totalSamplesDuration")}} for the audio duration of sent samples.
- {{domxref("RTCInboundRtpStreamStats/totalSamplesReceived","totalSamplesReceived")}}
# RTCInboundRtpStreamStats: totalSamplesReceived property

{{APIRef("WebRTC")}}

The **`totalSamplesReceived`** property of the {{domxref("RTCInboundRtpStreamStats")}} dictionary indicates the total number of samples received on this stream, including {{domxref("RTCInboundRtpStreamStats/concealedSamples","concealedSamples")}}.

> [!NOTE]
> The value is undefined for video streams.

## Value

An positive integer.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCInboundRtpStreamStats: totalSquaredInterFrameDelay property

{{APIRef("WebRTC")}}

The **`totalSquaredInterFrameDelay`** property of the {{domxref("RTCInboundRtpStreamStats")}} dictionary indicates the sum of the square of each inter-frame delay between consecutively rendered frames.
It is recorded after each frame is rendered.

The inter-frame delay variance be calculated from {{domxref("RTCInboundRtpStreamStats.totalInterFrameDelay","totalInterFrameDelay")}}, `totalSquaredInterFrameDelay`, and {{domxref("RTCInboundRtpStreamStats.framesRendered","framesRendered")}}, according to the formula: `(totalSquaredInterFrameDelay - totalInterFrameDelay^2/ framesRendered)/framesRendered`.

> [!NOTE]
> The property is undefined for audio streams.

## Value

A positive number.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCInboundRtpStreamStats: trackIdentifier property

{{APIRef("WebRTC")}}

The **`trackIdentifier`** property of the {{domxref("RTCInboundRtpStreamStats")}} dictionary is a string that identifies the `MediaStreamTrack` associated with the inbound stream.

This value will match the {{domxref("MediaStreamTrack.id")}} value of the associated track.

## Value

A string that identifies the associated media track.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCInboundRtpStreamStats: transportId property

{{APIRef("WebRTC")}}

The **`transportId`** property of the {{domxref("RTCInboundRtpStreamStats")}} dictionary is a string that uniquely identifies the associated {{domxref("RTCTransportStats")}} statistics object for this RTP stream's underlying transport.

`RTCInboundRtpStreamStats` and `RTCTransportStats` objects are correlated by iterating the {{domxref("RTCStatsReport")}} to find the statistics objects where `RTCInboundRtpStreamStats.transportId` is equal to {{domxref("RTCTransportStats.id")}}.

## Value

A string that contains the {{domxref("RTCTransportStats.id","id")}} of the object that was inspected to produce the {{domxref("RTCTransportStats")}} object associated with this RTP stream.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCInboundRtpStreamStats: type property

{{APIRef("WebRTC")}}

The **`type`** property of the {{domxref("RTCInboundRtpStreamStats")}} dictionary is a string with the value `"inbound-rtp"`.

Different statistics are obtained by iterating the {{domxref("RTCStatsReport")}} object returned by a call to {{domxref("RTCPeerConnection.getStats()")}}.
The type indicates the set of statistics available through the object in a particular iteration step.
A value of `"inbound-rtp"` indicates that the statistics available in the current step are those defined in {{domxref("RTCInboundRtpStreamStats")}}.

## Value

A string with the value `"inbound-rtp"`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: active property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`active`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary is a boolean that indicates whether this RTP stream is configured to be sent, or is disabled.

For example, this would be `false` if the track corresponding to the stream had its {{domxref("MediaStreamTrack.enabled")}} property set to `false`.
Note that an active stream may still not be sending if, for example, the stream is limited by network conditions.

## Value

`true` if the stream is enabled for sending, `false` otherwise.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: bytesSent property

{{APIRef("WebRTC")}}

The **`bytesSent`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary indicates the total number of payload bytes sent on this stream ({{domxref("RTCDataChannel")}}).

The value includes bytes in retransmitted payload bytes.
It does not include headers or padding.

## Value

A positive integer.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: codecId property

{{APIRef("WebRTC")}}

The **`codecId`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary is a string that uniquely identifies the object that was inspected to produce the data in the {{domxref("RTCCodecStats")}} for the {{Glossary("RTP")}} stream.

`RTCOutboundRtpStreamStats` and `RTCCodecStats` objects are correlated by iterating the {{domxref("RTCStatsReport")}} to find the statistics objects where `RTCOutboundRtpStreamStats.codecId` is equal to {{domxref("RTCCodecStats.id")}}.

## Value

A string that contains the {{domxref("RTCCodecStats.id","id")}} of the object that was inspected to produce the {{domxref("RTCCodecStats")}} object associated with this RTP stream.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: frameHeight property

{{APIRef("WebRTC")}}

The **`frameHeight`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary is a positive integer that indicates the height of the last encoded frame, in pixels.

Note that the resolution of the encoded frame may be lower than that of the media source, which is provided in {{domxref("RTCVideoSourceStats.height")}}.

> [!NOTE]
> The property is undefined for audio streams, and before the first frame is encoded.

## Value

A positive integer.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: framesEncoded property

{{APIRef("WebRTC")}}

The **`framesEncoded`** property of
the {{domxref("RTCOutboundRtpStreamStats")}} dictionary indicates the total number of
frames that have been encoded by this {{domxref("RTCRtpSender")}} for this media
source.

## Value

An integer value indicating the total number of video frames that this sender has
encoded so far for this stream.

> [!NOTE]
> This property is only valid for video streams.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: framesPerSecond property

{{APIRef("WebRTC")}}

The **`framesPerSecond`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary indicates the number of encoded frames sent in the last second.

Note that this may be lower than the media source frame rate, which is provided in {{domxref("RTCVideoSourceStats.framesPerSecond")}}.

> [!NOTE]
> The value does not exist for audio, or before the first second of encoding.

## Value

A positive number.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: framesSent property

{{APIRef("WebRTC")}}

The **`framesSent`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary indicates the total number of encoded frames sent on this RTP stream over its lifetime.

Note that this may be lower than the total number of media source frames, which is provided in {{domxref("RTCVideoSourceStats.frames")}}.

> [!NOTE]
> The value does not exist for audio.

## Value

A positive number.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: frameWidth property

{{APIRef("WebRTC")}}

The **`frameWidth`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary is a positive integer that indicates the width of the last encoded frame, in pixels.

Note that the resolution of the encoded frame may be lower than that of the media source, which is provided in {{domxref("RTCVideoSourceStats.width")}}.

> [!NOTE]
> The value does not exist for audio, or before the first frame is encoded.

## Value

A positive integer.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: headerBytesSent property

{{APIRef("WebRTC")}}

The **`headerBytesSent`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary indicates the total number of RTP header and padding bytes sent for this [synchronization source (SSRC)](/en-US/docs/Web/API/RTCOutboundRtpStreamStats/ssrc).

Note that the total number of bytes sent as payload over the transport is equal to: `headerBytesSent` + {{domxref("RTCOutboundRtpStreamStats.bytesSent","bytesSent")}}.

## Value

A positive integer.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: id property

{{APIRef("WebRTC")}}

The **`id`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary is a string that uniquely identifies the object for which this object provides statistics.

Using the `id`, you can correlate this statistics object with others, in order to monitor statistics over time for a given WebRTC object, such as an {{domxref("RTCPeerConnection")}}, or an {{domxref("RTCDataChannel")}}.

## Value

A string that uniquely identifies the object for which this `RTCOutboundRtpStreamStats` object provides statistics.

The format of the ID string is not defined by the specification, so you cannot reliably make any assumptions about the contents of the string, or assume that the format of the string will remain unchanged for a given object type.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats

{{APIRef("WebRTC")}}

The **`RTCOutboundRtpStreamStats`** dictionary of the [WebRTC API](/en-US/docs/Web/API/WebRTC_API) is used to report metrics and statistics related to an outbound {{Glossary("RTP")}} stream being sent by an {{domxref("RTCRtpSender")}}.

The statistics can be obtained by iterating the {{domxref("RTCStatsReport")}} returned by {{domxref("RTCPeerConnection.getStats()")}} or {{domxref("RTCRtpSender.getStats()")}} until you find a report with the [`type`](/en-US/docs/Web/API/RTCOutboundRtpStreamStats/type) of `outbound-rtp`.

## Instance properties

- {{domxref("RTCOutboundRtpStreamStats.active", "active")}} {{experimental_inline}}
  - : A boolean that indicates whether this RTP stream is configured to be sent, or is disabled.
- {{domxref("RTCOutboundRtpStreamStats.frameHeight", "frameHeight")}}
  - : An integer indicating the height of the last encoded frame, in pixels.
    _Undefined for audio streams._
- {{domxref("RTCOutboundRtpStreamStats.frameWidth", "frameWidth")}}
  - : An integer indicating the width of the last encoded frame, in pixels.
    _Undefined for audio streams._
- {{domxref("RTCOutboundRtpStreamStats.framesEncoded", "framesEncoded")}}
  - : The number of frames that have been successfully encoded so far for sending on this RTP stream.
    _Undefined for audio streams._
- {{domxref("RTCOutboundRtpStreamStats.framesPerSecond", "framesPerSecond")}}
  - : A number that represents the encoded frames sent in the last second.
    _Undefined for audio streams._
- {{domxref("RTCOutboundRtpStreamStats.framesSent", "framesSent")}}
  - : A positive integer that represents the total number of encoded frames sent on this RTP stream.
    _Undefined for audio streams._
- {{domxref("RTCOutboundRtpStreamStats.headerBytesSent", "headerBytesSent")}}
  - : A positive integer that represents the total number of RTP header and padding bytes sent for this SSRC.
- {{domxref("RTCOutboundRtpStreamStats.keyFramesEncoded", "keyFramesEncoded")}} {{experimental_inline}}
  - : A positive integer that represents the total number of key frames successfully encoded in this RTP media stream.
    _Undefined for audio streams._
- {{domxref("RTCOutboundRtpStreamStats.mediaSourceId", "mediaSourceId")}}
  - : A string that represents the id of the stats object of the track currently attached to the sender of this stream.
- {{domxref("RTCOutboundRtpStreamStats.mid", "mid")}}
  - : A string that uniquely identifies the pairing of source and destination of the transceiver's stream.
    This is the value of the corresponding {{domxref("RTCRtpTransceiver.mid")}} unless that is null, in which case the statistic property is not present.
- {{domxref("RTCOutboundRtpStreamStats.nackCount", "nackCount")}}
  - : An integer value indicating the total number of Negative ACKnowledgement (NACK) packets this `RTCRtpSender` has received from the remote {{domxref("RTCRtpReceiver")}}.
    This locally-computed value provides an indication of the error resiliency of the connection.
- {{domxref("RTCOutboundRtpStreamStats.qpSum", "qpSum")}}
  - : A 64-bit value containing the sum of the QP values for every frame encoded by this {{domxref("RTCRtpSender")}}.
    This locally-computed value provides an indication of how heavily compressed the data is.
    _Undefined for audio streams._
- {{domxref("RTCOutboundRtpStreamStats.qualityLimitationDurations", "qualityLimitationDurations")}} {{experimental_inline}}
  - : A map of the reasons that a media stream's resolution or framerate has been reduced, and the time that the quality was reduced for each reason.
    _Undefined for audio streams._
- {{domxref("RTCOutboundRtpStreamStats.qualityLimitationReason", "qualityLimitationReason")}} {{experimental_inline}}
  - : A string indicating the reason why the stream is being quality-limited.
    One of: `none`, `cpu`, `bandwidth`, or `other`.
    _Undefined for audio streams._
- {{domxref("RTCOutboundRtpStreamStats.remoteId", "remoteId")}}
  - : A string which identifies the {{domxref("RTCRemoteInboundRtpStreamStats")}} object that provides statistics for the remote peer for this same SSRC.
    This ID is stable across multiple calls to `getStats()`.
- {{domxref("RTCOutboundRtpStreamStats.retransmittedBytesSent", "retransmittedBytesSent")}}
  - : A positive integer that represents the total number of payload bytes retransmitted for the source associated with this stream.
- {{domxref("RTCOutboundRtpStreamStats.retransmittedPacketsSent", "retransmittedPacketsSent")}}
  - : A positive integer that represents the total number of packets retransmitted for the source associated with this stream.
- {{domxref("RTCOutboundRtpStreamStats.rid", "rid")}}
  - : A string that indicates the RTP stream ID for a corresponding video stream.
- {{domxref("RTCOutboundRtpStreamStats.scalabilityMode", "scalabilityMode")}} {{experimental_inline}}
  - : A string that represents the scalability mode for the RTP stream, if one has been configured.
- {{domxref("RTCOutboundRtpStreamStats.targetBitrate", "targetBitrate")}}
  - : A number that represents the bit rate that the `RTCRtpSender`'s codec is currently attempting to achieve for the stream.
- {{domxref("RTCOutboundRtpStreamStats.totalEncodeTime", "totalEncodeTime")}}
  - : A number that represents the total number of seconds that have been spent encoding the frames encoded for this stream {{domxref("RTCRtpSender")}}.
    _Undefined for audio streams._
- {{domxref("RTCOutboundRtpStreamStats.totalEncodedBytesTarget", "totalEncodedBytesTarget")}} {{experimental_inline}}
  - : A cumulative sum of the _target_ frame sizes for all of the frames encoded so far.
    This will likely differ from the total of the _actual_ frame sizes.
    _Undefined for audio streams._
- {{domxref("RTCOutboundRtpStreamStats.totalPacketSendDelay", "totalPacketSendDelay")}}
  - : A number that represents the total time in seconds that packets have spent buffered locally before being transmitted.

### Sent RTP stream statistics

<!-- RTCSentRtpStreamStats -->

- {{domxref("RTCOutboundRtpStreamStats.bytesSent", "bytesSent")}} {{optional_inline}}
  - : A positive integer indicating the total number of bytes sent for this SSRC, including retransmissions. <!-- [RFC3550] section 6.4.1 -->
- {{domxref("RTCOutboundRtpStreamStats.packetsSent", "packetsSent")}} {{optional_inline}}
  - : A positive integer indicating the total number of RTP packets sent for this SSRC, including retransmissions. <!-- [RFC3550] section 6.4.1 -->

### Common RTP stream statistics

<!-- RTCRtpStreamStats -->

- {{domxref("RTCOutboundRtpStreamStats.codecId", "codecId")}} {{optional_inline}}
  - : A string that uniquely identifies the object that was inspected to produce the {{domxref("RTCCodecStats")}} object associated with this {{Glossary("RTP")}} stream.
- {{domxref("RTCOutboundRtpStreamStats.kind", "kind")}}
  - : A string indicating whether the {{domxref("MediaStreamTrack")}} associated with the stream is an audio or a video track.
- {{domxref("RTCOutboundRtpStreamStats.ssrc", "ssrc")}}
  - : A positive integer that identifies the SSRC of the RTP packets in this stream.
- {{domxref("RTCOutboundRtpStreamStats.transportId", "transportId")}} {{optional_inline}}
  - : A string that uniquely identifies the object which was inspected to produce the {{domxref("RTCTransportStats")}} object associated with this RTP stream.

### Common instance properties

The following properties are common to all WebRTC statistics objects.

<!-- RTCStats -->

- {{domxref("RTCOutboundRtpStreamStats.id", "id")}}
  - : A string that uniquely identifies the object that is being monitored to produce this set of statistics.
- {{domxref("RTCOutboundRtpStreamStats.timestamp", "timestamp")}}
  - : A {{domxref("DOMHighResTimeStamp")}} object indicating the time at which the sample was taken for this statistics object.
- {{domxref("RTCOutboundRtpStreamStats.type", "type")}}
  - : A string with the value `"outbound-rtp"`, indicating the type of statistics that the object contains.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCStatsReport")}}
# RTCOutboundRtpStreamStats: keyFramesEncoded property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`keyFramesEncoded`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary represents the total number of key frames successfully encoded in this RTP media stream.
This includes, for example, key frames in VP8 ({{rfc("6386")}}) or IDR-frames in H.264 ({{rfc("6184")}}).

Note that the number of delta frames is calculated by subtracting this value from the total number of frames ({{domxref("RTCOutboundRtpStreamStats.framesEncoded","framesEncoded")}} - `keyFramesEncoded`).

> [!NOTE]
> The value does not exist for audio.

## Value

A positive integer.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: kind property

{{APIRef("WebRTC")}}

The **`kind`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary is a string indicating whether the described {{Glossary("RTP")}} stream contains audio or video media.

This string will always be the same as the {{domxref("MediaStreamTrack.kind", "kind")}} of the {{domxref("MediaStreamTrack")}} object carried by the stream.
It will also match the media type of the codec associated with this statistics objects (i.e., the MIME type of the associated codec's {{domxref("RTCCodecStats.mimeType")}} property).

## Value

The kind is always one of:

- `"audio"`
  - : The stream contains audio media.
- `"video"`
  - : The stream contains video media.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: mediaSourceId property

{{APIRef("WebRTC")}}

The **`mediaSourceId`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary represents the ID of the statistics object of the track currently attached to the sender of this stream.

This can then be used to obtain the corresponding {{domxref("RTCVideoSourceStats")}} or {{domxref("RTCAudioSourceStats")}}.

## Value

A string containing the ID of a media source statistics object.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: mid property

{{APIRef("WebRTC")}}

The **`mid`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary is a string that contains the media ID negotiated between the local and remote peers.
This uniquely identifies the pairing of source and destination for the transceiver's stream.

## Value

The value of the corresponding {{domxref("RTCRtpTransceiver.mid")}}, unless that value is null, in which case this statistic property is not present.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: nackCount property

{{APIRef("WebRTC")}}

The **`nackCount`** property of the
{{domxref("RTCOutboundRtpStreamStats")}} dictionary is a numeric value indicating the
number of times the {{domxref("RTCRtpSender")}} described by this object received a
**NACK** packet from the remote receiver.

A NACK (Negative
ACKnowledgement, also called "Generic NACK") packet is used by the
{{domxref("RTCRtpReceiver")}} to inform the sender that one or more {{Glossary("RTP")}}
packets it sent were lost in transport.

## Value

An integer value indicating how many times the sender received a NACK packet from the
receiver, indicating the loss of one or more packets.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: packetsSent property

{{APIRef("WebRTC")}}

The **`packetsSent`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary represents the total number of RTP packets sent on this stream, including retransmissions.

## Value

A positive integer.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: qpSum property

{{APIRef("WebRTC")}}

The **`qpSum`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary is a value generated by adding the **Quantization Parameter** (**QP**) values for every frame this sender has produced to date on the video track corresponding to this `RTCOutboundRtpStreamStats` object.

In general, the higher this number is, the more heavily compressed the video data is.

## Value

An unsigned 64-bit integer value which indicates the sum of the quantization parameter (QP) value for every frame sent so far on the track described by the {{domxref("RTCOutboundRtpStreamStats")}} object.
Since the value of QP is typically larger to indicate higher compression factors, the larger this sum is, the more heavily compressed the stream generally has been.

> [!NOTE]
> This value is only available for video media.

## Usage notes

[Quantization](https://en.wikipedia.org/wiki/Quantization) is the process of applying lossy compression
to a range of values, resulting in a single **quantum value**. This value
takes the place of the range of values, thereby reducing the number of different values
that appear in the overall data set, making the data more compressible. The quantization
process and the amount of compression can be controlled using one or more parameters.

It's important to keep in mind that the value of QP can change periodically—even every
frame—so it's difficult to know for certain how substantial the compression is. The best
you can do is make an estimate. You can use the value of
{{domxref("RTCSentRtpStreamStats.framesEncoded")}} to get the number of frames that have
been encoded so far, and compute an average from there. See [Calculating average quantization](#calculating_average_quantization) below for a function that does this.

Also, the exact meaning of the QP value depends on the {{Glossary("codec")}} being
used. For example, for the VP8 codec, the QP value can be anywhere from 1 to 127 and is
found in the frame header element `"y_ac_qi"`, whose value is defined in
{{RFC(6386, "", "19.2")}}. H.264 uses a QP which ranges from 0 to 51; in this case, it's an
index used to derive a scaling matrix used during the quantization process.
Additionally, QP is not likely to be the only parameter the codec uses to adjust the
compression. See the individual codec specifications for details.

## Examples

### Calculating average quantization

The `calculateAverageQP()` function shown below computes the average QP for the object that contains RTP stream statistics, returning 0 if the object doesn't describe an RTP stream.

```js
function calculateAverageQP(stats) {
  let frameCount = 0;

  switch (stats.type) {
    case "inbound-rtp":
    case "remote-inbound-rtp":
      frameCount = stats.framesDecoded;
      break;
    case "outbound-rtp":
    case "remote-outbound-rtp":
      frameCount = stats.framesEncoded;
      break;
    default:
      return 0;
  }

  return status.qpSum / frameCount;
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: qualityLimitationDurations property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`qualityLimitationDurations`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary is a map of the reasons that a media stream's quality has been reduced by a codec during encoding, and the time during which the quality was reduced for each reason.

This quality reduction may include changes such as reduced frame rate or resolution, or an increase in compression factor.
The information can be used to diagnose throughput issues and optimize performance.

> [!NOTE]
> This property only exists for video media.

## Value

A {{jsxref("Map")}} of quality limitation reasons to a number which represents the time in seconds that the stream has been quality limited for that reason.

The allowed quality limitation reason values are the strings:

- `none`
  - : The quality is not limited.
- `cpu`
  - : The quality is primarily limited due to CPU load.
- `bandwidth`
  - : The quality is primarily limited due to congestion cues during bandwidth estimation, such as inter-arrival time and round-trip time.
- `other`
  - : The quality is primarily limited for a reason other than the above.

## Examples

### Get total time the stream has been quality limited

The sum of all entries except `qualityLimitationDurations["none"]` gives the total time that the stream has been limited.

```js
// Get the outbound RTP stream stats
pc.getStats().then((stats) => {
  stats.forEach((report) => {
    if (report.type === "outbound-rtp") {
      const qualityLimitations = report.qualityLimitationDurations;
      if (qualityLimitations) {
        let totalTimeLimited = 0;

        console.log("Quality Limitations:");
        qualityLimitations.forEach((duration, reason) => {
          console.log(`- ${reason}: ${duration} seconds`);
          if (reason !== "none") {
            totalTimeLimited += duration;
          }
        });
        console.log(`Total time limited: ${totalTimeLimited}`);
      }
    }
  });
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: qualityLimitationReason property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`qualityLimitationReason`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary is a string indicating the reason why the media quality in the stream is currently being reduced by the codec during encoding, or `none` if no quality reduction is being performed.

This quality reduction may include changes such as reduced frame rate or resolution, or an increase in compression factor.
Note that the user agent report the most limiting factor.
If the most limiting factor cannot be determined the result will be reported using the priority order: "bandwidth", "cpu", "other".

The amount of time the encoded media has had its quality reduced in each of the potential ways that can be done can be found in {{domxref("RTCOutboundRtpStreamStats.qualityLimitationDurations", "qualityLimitationDurations")}}.

> [!NOTE]
> The property is undefined for audio streams.

## Value

A string with one of the following values:

- `none`
  - : The quality is not limited.
- `cpu`
  - : The quality is primarily limited due to CPU load.
- `bandwidth`
  - : The quality is primarily limited due to congestion cues during bandwidth estimation, such as inter-arrival time and round-trip time.
- `other`
  - : The quality is primarily limited for a reason other than the above.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: remoteId property

{{APIRef("WebRTC")}}

The **`remoteId`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary specifies the {{domxref("RTCOutboundRtpStreamStats.id", "id")}} of the {{domxref("RTCRemoteInboundRtpStreamStats")}} object representing the remote peer's {{domxref("RTCRtpReceiver")}} which is sending the media to the local peer for this SSRC.

## Value

A string containing the ID of the {{domxref("RTCRemoteInboundRtpStreamStats")}} object that represents the remote peer's {{domxref("RTCRtpReceiver")}} for the synchronization source represented by this stats object.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: retransmittedBytesSent property

{{APIRef("WebRTC")}}

The **`retransmittedBytesSent`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary represents the total number of payload bytes retransmitted for the source associated with this stream.

RTX (Retransmission) is one of several mechanisms that WebRTC uses for retransmitting lost payload bytes, and broadly refers to support for the special packets defined in {{rfc("4588")}}.
RTX has to be negotiated between the sender and receiver during initial handshake.
If RTX has not been negotiated the retransmitted bytes will be sent over the same SSRC; otherwise the bytes are sent on a separate SSRC but are still accounted for in this property.

The retransmitted bytes sent are included in the count reported by {{domxref("RTCOutboundRtpStreamStats.bytesSent", "bytesSent")}}.

## Value

A positive integer indicating the number of retransmitted payload bytes for the source.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: retransmittedPacketsSent property

{{APIRef("WebRTC")}}

The **`retransmittedPacketsSent`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary represents the total number of packets retransmitted for the source associated with this stream.

RTX (Retransmission) is one of several mechanisms that WebRTC uses for retransmitting lost payload bytes, and broadly refers to support for the special packets defined in {{rfc("4588")}}.
RTX has to be negotiated between the sender and receiver during initial handshake.
If RTX has not been negotiated the retransmitted packets will be sent over the same SSRC; otherwise the bytes are sent on a separate SSRC but are still accounted for in this property.

The retransmitted packets are included in the count reported by {{domxref("RTCOutboundRtpStreamStats.packetsSent", "packetsSent")}}.

## Value

A positive integer indicating the number of retransmitted packets for the source.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: rid property

{{APIRef("WebRTC")}}

The **`rid`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary is a string that specifies the RTP stream ID, if defined.

The property is only defined where the `rid` has been set for the corresponding {{domxref("RTCRtpSender")}}.
If set, this value will be present regardless of whether the RID RTP header extension has been negotiated.

## Value

The value of the [`encodings.rid`](/en-US/docs/Web/API/RTCRtpSender/setParameters#rid) argument passed to {{domxref("RTCRtpSender.setParameters()")}}, if any, when the corresponding transceiver is created.
The property is undefined if the stream ID was not set.

> [!NOTE]
> The property is undefined for audio streams.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: scalabilityMode property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`scalabilityMode`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary represents the scalability mode for the RTP stream, if one has been configured.
If not configured, the property is undefined.

The mode is used in [Scalable Video Coding (SVC)](https://w3c.github.io/webrtc-svc/) to define how define how a video stream may be encoded to allow for adaptation to different network conditions and receiver capabilities.
Different codecs allow for various kinds of scalability, such as providing different resolution, different frame rates, or different quality levels for a particular video.

The mode may be configured, for example, by specifying the scalability mode as a parameter option in {{domxref("VideoEncoder.configure()")}}, {{domxref("RTCRtpSender.setParameters()")}}, or {{domxref("RTCPeerConnection.addTransceiver()")}}.

> [!NOTE]
> The property is undefined for audio streams.

## Value

A string indicating the configured scalability mode, such as "L1T1".
If no mode has been configured, the property is undefined.

The set of allowed modes are defined in [Scalable Video Coding (SVC) Extension for WebRTC](https://w3c.github.io/webrtc-svc/#scalabilitymodes*) (w3c.github.io/webrtc-svc).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: ssrc property

{{APIRef("WebRTC")}}

The **`ssrc`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary contains a positive integer value that identifies the synchronization source (SSRC) of this stream of {{Glossary("RTP")}} packets.

A source might be something like a microphone, or a mixer application that combines multiple sources.
All packets from the same source share the same time source and sequence space, and so can be ordered relative to each other.
Note that two streams with the same `ssrc` value refer to the same source.

## Value

A positive 32-bit integer uniquely identifying the SSRC of the RTP packets whose statistics are covered by this {{domxref("RTCOutboundRtpStreamStats")}} object.

The manner in which SSRC values are generated is not mandated by the specification, although it does make recommendations.
You should not make any assumptions based on the value of `ssrc` other than that any two objects with the same `ssrc` value refer to the same source.
See {{RFC("3550", "", "8")}} for additional information about `ssrc`.

> [!NOTE]
> The specification includes an example that generates values for `ssrc` using MD5.
> While not part of the standard, exactly, it is a good mechanism that may be used by some browsers; others may use other methods, such as random number generators.
> _Do not_ rely upon these values meaning anything other than "these objects are associated with the same source."

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCRtpReceiver.getSynchronizationSources()")}}
- {{domxref("RTCEncodedAudioFrame.getMetadata()")}}
# RTCOutboundRtpStreamStats: targetBitrate property

{{APIRef("WebRTC")}}

The **`targetBitrate`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary represents the current target bitrate of the codec in use by the stream.

The value is dynamic, reflecting the encoder settings and other factors such as network conditions and available bandwidth.
It should correlate closely to the payload bytes sent per second (excluding retransmissions).

## Value

A number representing the target rate in bits per second.
This is defined in the same way as the {{rfc("3890","Transport Independent Application Specific (TIAS)")}} bitrate.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCOutboundRtpStreamStats.bytesSent")}}
- {{domxref("RTCOutboundRtpStreamStats.retransmittedBytesSent")}}
# RTCOutboundRtpStreamStats: timestamp property

{{APIRef("WebRTC")}}

The **`timestamp`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary is a {{domxref("DOMHighResTimeStamp")}} object specifying the time at which the data in the object was sampled.

## Value

A {{domxref("DOMHighResTimeStamp")}} value indicating the time at which the activity described by the statistics in this object was recorded, in milliseconds elapsed since the beginning of January 1, 1970, UTC.

The value should be accurate to within a few milliseconds but may not be entirely precise, either because of hardware or operating system limitations or because of [fingerprinting](/en-US/docs/Glossary/Fingerprinting) protection in the form of reduced clock precision or accuracy.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: totalEncodedBytesTarget property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`totalEncodedBytesTarget`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary represents the sum of the target frame sizes for all of the frames encoded so far.

The codec has a target maximum size for each frame that it is asked to compress, in bytes.
This property indicates the cumulative total of the target sizes for each frame at the current time.
This will probably differ from the total of the actual frame sizes.
You can compare to {{domxref("RTCOutboundRtpStreamStats/bytesSent","bytesSent")}} in order to estimate how closely the codec is matching its target.

The value increases every time {{domxref("RTCOutboundRtpStreamStats/framesEncoded","framesEncoded")}} goes up.

> [!NOTE]
> The property is undefined for audio streams.

## Value

The sum of the target frame sizes in bytes, represented as a positive integer.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: totalEncodeTime property

{{APIRef("WebRTC")}}

The **`totalEncodeTime`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary represents the total number of seconds spent encoding the {{domxref("RTCOutboundRtpStreamStats/framesEncoded","framesEncoded")}} frames for this stream ({{domxref("RTCRtpSender")}}).

The average encode time can be calculated by dividing this value by `framesEncoded`.
The time it takes to encode one frame is the time between sending the encoder a frame and the encoder returning encoded data for that frame.
It does not include any time spent packetizing the resulting data.

> [!NOTE]
> The property is undefined for audio streams.

## Value

A number representing the total time spent encoding frames, in seconds.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: totalPacketSendDelay property

{{APIRef("WebRTC")}}

The **`totalPacketSendDelay`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary represents the total time in seconds that packets have spent buffered locally before being transmitted.

The individual packet delay is the time between a packet being emitted from the RTP packetizer and it being handed over to the OS network socket.
The individual delay is added to `totalPacketSendDelay` when {{domxref("RTCOutboundRtpStreamStats/framesEncoded","packetsSent")}} is incremented.

> [!NOTE]
> The property is undefined for audio streams.

## Value

The delay in seconds, represented as a number.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: transportId property

{{APIRef("WebRTC")}}

The **`transportId`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary is a string that uniquely identifies the associated {{domxref("RTCTransportStats")}} statistics object for this RTP stream's underlying transport.

`RTCOutboundRtpStreamStats` and `RTCTransportStats` objects are correlated by iterating the {{domxref("RTCStatsReport")}} to find the statistics objects where `RTCOutboundRtpStreamStats.transportId` is equal to {{domxref("RTCTransportStats.id")}}.

## Value

A string that contains the {{domxref("RTCTransportStats.id","id")}} of the object that was inspected to produce the {{domxref("RTCTransportStats")}} object associated with this RTP stream.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCOutboundRtpStreamStats: type property

{{APIRef("WebRTC")}}

The **`type`** property of the {{domxref("RTCOutboundRtpStreamStats")}} dictionary is a string with the value `"outbound-rtp"`.

Different statistics are obtained by iterating the {{domxref("RTCStatsReport")}} object returned by a call to {{domxref("RTCPeerConnection.getStats()")}}.
The type indicates the set of statistics available through the object in a particular iteration step.
A value of `"outbound-rtp"` indicates that the statistics available in the current step are those defined in {{domxref("RTCOutboundRtpStreamStats")}}.

## Value

A string with the value `"outbound-rtpp"`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCPeerConnection: addIceCandidate() method

{{APIRef("WebRTC")}}

The **`addIceCandidate()`** method of the {{domxref("RTCPeerConnection")}} interface adds a new remote candidate to the connection's remote description, which describes the state of the remote end of the connection.

When a website or app using {{domxref("RTCPeerConnection")}} receives a new ICE candidate from the remote peer over its signaling channel, it delivers the newly-received candidate to the browser's {{Glossary("ICE")}} agent by calling **`RTCPeerConnection.addIceCandidate()`**.
This adds this new remote candidate to the `RTCPeerConnection`'s remote description, which describes the state of the remote end of the connection.

If the `candidate` parameter is missing or a value of `null` is given when calling `addIceCandidate()`, the added ICE candidate is an "end-of-candidates" indicator.
The same is the case if the value of the specified object's {{domxref("RTCIceCandidate.candidate", "candidate")}} is either missing or an empty string (`""`), it signals that all remote candidates have been delivered.

The end-of-candidates notification is transmitted to the remote peer using a candidate with an a-line value of `end-of-candidates`.

During negotiation, your app will likely receive many candidates which you'll deliver to the ICE agent in this way, allowing it to build up a list of potential connection methods.
This is covered in more detail in the articles [WebRTC connectivity](/en-US/docs/Web/API/WebRTC_API/Connectivity) and
[Signaling and video calling](/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling).

## Syntax

```js-nolint
addIceCandidate(candidate)

addIceCandidate(candidate, successCallback) // deprecated
addIceCandidate(candidate, successCallback, failureCallback) // deprecated
```

### Parameters

- `candidate` {{optional_inline}}
  - : An {{domxref("RTCIceCandidate")}} object, or an object that has the following properties:

    <!-- RTCIceCandidateInit in spec -->
    - `candidate` {{optional_inline}}
      - : A string describing the properties of the candidate, taken directly from the [SDP](/en-US/docs/Web/API/WebRTC_API/Protocols#sdp) attribute `"candidate"`.
        The candidate string specifies the network connectivity information for the candidate.
        If the `candidate` is an empty string (`""`), the end of the candidate list has been reached; this candidate is known as the "end-of-candidates" marker.

        The syntax of the candidate string is described in {{RFC(5245, "", 15.1)}}.
        For an a-line (attribute line) that looks like this:

        ```plain
        a=candidate:4234997325 1 udp 2043278322 192.0.2.172 44323 typ host
        ```

        the corresponding `candidate` string's value will be:

        ```plain
        "candidate:4234997325 1 udp 2043278322 192.0.2.172 44323 typ host"`
        ```

        The {{Glossary("user agent")}} always prefers candidates with the highest {{domxref("RTCIceCandidate.priority", "priority")}}, all else being equal.
        In the example above, the priority is `2043278322`. The attributes are all separated by a single space character, and are in a specific order.
        The complete list of attributes for this example candidate is:
        - {{domxref("RTCIceCandidate.foundation", "foundation")}} = 4234997325
        - {{domxref("RTCIceCandidate.component", "component")}} = `"rtp"` (the number 1 is encoded to this string; 2 becomes `"rtcp"`)
        - {{domxref("RTCIceCandidate.protocol", "protocol")}} = `"udp"`
        - {{domxref("RTCIceCandidate.priority", "priority")}} = 2043278322
        - {{domxref("RTCIceCandidate/address", "ip")}} = `"192.0.2.172"`
        - {{domxref("RTCIceCandidate.port", "port")}} = 44323
        - {{domxref("RTCIceCandidate.type", "type")}} = `"host"`

        Additional information can be found in {{domxref("RTCIceCandidate.candidate")}}.

        > [!NOTE]
        > For backward compatibility with older versions of the WebRTC specification, the constructor also accepts this string directly as an argument.

    - `sdpMid` {{optional_inline}}
      - : A string containing the identification tag of the media stream with which the candidate is associated, or `null` if there is no associated media stream. The default is `null`.

        Additional information can be found in {{domxref("RTCIceCandidate.sdpMid")}}.

    - `sdpMLineIndex` {{optional_inline}}
      - : A number property containing the zero-based index of the m-line with which the candidate is associated, within the [SDP](/en-US/docs/Web/API/WebRTC_API/Protocols#sdp) of the media description, or `null` if no such associated exists. The default is `null`.

        Additional information can be found in {{domxref("RTCIceCandidate.sdpMLineIndex")}}.

    - `usernameFragment` {{optional_inline}}
      - : A string containing the username fragment (usually referred to in shorthand as "ufrag" or "ice-ufrag").
        This fragment, along with the ICE password ("ice-pwd"), uniquely identifies a single ongoing ICE interaction (including for any communication with the {{Glossary("STUN")}} server).

        The string is generated by WebRTC at the beginning of the session.
        It may be up to 256 characters long, and at least 24 bits must contain random data.
        It has no default value and is not present unless set explicitly.

        Additional information can be found in {{domxref("RTCIceCandidate.usernameFragment")}}.

    The method will throw a {{jsxref("TypeError")}} exception if both `sdpMid` and `sdpMLineIndex` are `null`.

    The contents of the object should be constructed from a message received over the signaling channel, describing a newly received ICE candidate that's ready to be delivered to the local ICE agent.

    If no `candidate` object is specified, or its value is `null`, an end-of-candidates signal is sent to the remote peer using the `end-of-candidates` a-line, formatted like this:

    ```plain
    a=end-of-candidates
    ```

### Deprecated parameters

In older code and documentation, you may see a callback-based version of this function.
This has been deprecated and its use is **strongly** discouraged.
You should update any existing code to use the {{jsxref("Promise")}}-based version of `addIceCandidate()` instead.
The parameters for the older form of `addIceCandidate()` are described below, to aid in updating existing code.

- `successCallback` {{deprecated_inline}}
  - : A function to be called when the ICE candidate has been successfully added.
    This function receives no input parameters and doesn't return a value.
- `failureCallback` {{deprecated_inline}}
  - : A function to be called if attempting to add the ICE candidate fails.
    Receives as input a {{domxref("DOMException")}} object describing why failure occurred.

### Return value

A {{jsxref("Promise")}} that is fulfilled when the candidate has been successfully added to the remote peer's description by the ICE agent.
The promise does not receive any input parameters.

### Exceptions

When an error occurs while attempting to add the ICE candidate, the {{jsxref("Promise")}} returned by this method is rejected, returning one of the errors below as the {{domxref("DOMException.name", "name")}} attribute in the specified {{domxref("DOMException")}} object passed to the rejection handler.

- {{jsxref("TypeError")}}
  - : Returned if the specified candidate's {{domxref("RTCIceCandidate.sdpMid", "sdpMid")}} and {{domxref("RTCIceCandidate.sdpMLineIndex", "sdpMLineIndex")}} are both `null`.
- `InvalidStateError` {{domxref("DOMException")}}
  - : Returned if the `RTCPeerConnection` currently has no remote peer established ({{domxref("RTCPeerConnection.remoteDescription", "remoteDescription")}} is `null`).
- `OperationError` {{domxref("DOMException")}}
  - : Returned in one of the following situations:
    - The value specified for {{domxref("RTCIceCandidate.sdpMid", "sdpMid")}} is non-`null` and doesn't match the media description ID of any media description included within the {{domxref("RTCPeerConnection.remoteDescription", "remoteDescription")}}.
    - The specified value of {{domxref("RTCIceCandidate.sdpMLineIndex", "sdpMLineIndex")}} is greater than or equal to the number of media descriptions included in the remote description.
    - The specified {{domxref("RTCIceCandidate.usernameFragment", "ufrag")}}
      doesn't match the `ufrag` field in any of the remote descriptions being considered.
    - One or more of the values in the {{domxref("RTCIceCandidate", "candidate")}} string are invalid or could not be parsed.
    - Attempting to add the candidate fails for any reason.

## Examples

This code snippet shows how to signal ICE candidates across an arbitrary signaling channel.

```js
// This example assumes that the other peer is using a signaling channel as follows:
//
// pc.onicecandidate = (event) => {
//   if (event.candidate) {
//     signalingChannel.send(JSON.stringify({ice: event.candidate})); // "ice" is arbitrary
//   } else {
//     // All ICE candidates have been sent
//   }
// }

signalingChannel.onmessage = (receivedString) => {
  const message = JSON.parse(receivedString);
  if (message.ice) {
    // A typical value of ice here might look something like this:
    //
    // {candidate: "candidate:0 1 UDP 2122154243 192.0.2.43 53421 typ host", sdpMid: "0", …}
    //
    // Pass the whole thing to addIceCandidate:

    pc.addIceCandidate(message.ice).catch((e) => {
      console.log(`Failure during addIceCandidate(): ${e.name}`);
    });
  } else {
    // handle other things you might be signaling, like sdp
  }
};
```

The last candidate to be signaled this way by the remote peer will be a special candidate denoting end-of-candidates.
Out of interest, end-of-candidates may be manually indicated as follows:

```js
pc.addIceCandidate({ candidate: "" });
```

However, in most cases you won't need to look for this explicitly, since the events driving the {{domxref("RTCPeerConnection")}} will deal with it for you, sending the appropriate events.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- [Signaling and video calling](/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling)
- [Introduction to WebRTC protocols](/en-US/docs/Web/API/WebRTC_API/Protocols)
- [WebRTC connectivity](/en-US/docs/Web/API/WebRTC_API/Connectivity)
- [Lifetime of a WebRTC session](/en-US/docs/Web/API/WebRTC_API/Session_lifetime)
# RTCPeerConnection: addstream event

{{APIRef("WebRTC")}}{{Deprecated_Header}}{{Non-standard_Header}}

The obsolete **`addstream`** event is sent to an {{domxref("RTCPeerConnection")}} when new media, in the form of a {{domxref("MediaStream")}} object, has been added to it.

> [!WARNING]
> This event has been removed from the WebRTC specification. You should instead watch for the {{domxref("RTCPeerConnection.track_event", "track")}} event, which is sent for each media track added to the `RTCPeerConnection`.

You can, similarly, watch for streams to be removed from the connection by monitoring the {{domxref("RTCPeerConnection.removestream_event", "removestream")}} event.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("addstream", (event) => { })

onaddstream = (event) => { }
```

## Event type

A {{domxref("MediaStreamEvent")}}. Inherits from {{domxref("Event")}}.

{{InheritanceDiagram("MediaStreamEvent")}}

## Event properties

_A {{domxref("MediaStreamEvent")}} being an {{domxref("Event")}}, this event also implements these properties_.

- {{domxref("MediaStreamEvent.stream")}} {{ReadOnlyInline}}
  - : Contains the {{domxref("MediaStream")}} containing the stream associated with the event.

## Examples

This example looks to determine if the user's browser supports the {{domxref("RTCPeerConnection.track_event", "track")}} event. If it does, a `track` event listener is set up; otherwise, an `addstream` event listener is set up. `pc` is an `RTCPeerConnection`.

```js
if (pc.addTrack !== undefined) {
  pc.ontrack = (ev) => {
    ev.streams.forEach((stream) => doAddStream(stream));
  };
} else {
  pc.onaddstream = (ev) => {
    doAddStream(ev.stream);
  };
}
```

This calls a function `doAddStream()` once for each stream being added to the {{domxref("RTCPeerConnection")}}, regardless of whether the browser sends `addstream` or `track`.

You can also use the {{domxref("EventTarget.addEventListener", "addEventListener()")}} method to set an event listener:

```js
pc.addEventListener("addstream", (ev) => doAddStream(ev.stream), false);
```

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCPeerConnection.addStream()")}}
- {{domxref("MediaStreamEvent")}}
# RTCPeerConnection: addStream() method

{{APIRef("WebRTC")}}{{Deprecated_Header}}{{non-standard_header}}

The **`addStream()`** method of the {{domxref("RTCPeerConnection")}} interface adds a {{domxref("MediaStream")}} as a local source of audio or video.
Instead of using this obsolete method, you should instead use {{domxref("RTCPeerConnection.addTrack", "addTrack()")}} once for each track you wish to send to the remote peer.

If the {{domxref("RTCPeerConnection.signalingState", "signalingState")}} is set to `closed`, an `InvalidStateError` is raised.
If the {{domxref("RTCPeerConnection.signalingState", "signalingState")}} is set to `stable`, the event {{DOMxRef("RTCPeerConnection/negotiationneeded_event", "negotiationneeded")}} is sent on the {{domxref("RTCPeerConnection")}} to indicate that {{Glossary("ICE")}} negotiation must be repeated to consider the new stream.

## Syntax

```js-nolint
addStream(mediaStream)
```

### Parameters

- `mediaStream`
  - : A {{domxref("MediaStream")}} object indicating the stream to add to the WebRTC peer connection.

### Return value

None.

## Example

This simple example adds the audio and video stream coming from the user's camera to the connection.

```js
navigator.mediaDevices.getUserMedia({ video: true, audio: true }, (stream) => {
  const pc = new RTCPeerConnection();
  pc.addStream(stream);
});
```

## Migrating to addTrack()

[Compatibility allowing](#browser_compatibility), you should update your code to instead use the {{domxref("RTCPeerConnection.addTrack", "addTrack()")}} method:

```js
navigator.getUserMedia({ video: true, audio: true }, (stream) => {
  const pc = new RTCPeerConnection();
  stream.getTracks().forEach((track) => {
    pc.addTrack(track, stream);
  });
});
```

The newer {{domxref("RTCPeerConnection.addTrack", "addTrack()")}} API avoids confusion over whether later changes to the track-makeup of a stream affects a peer connection (they do not).

The exception is in Chrome, where `addStream()` _does_ make the peer connection sensitive to later stream changes (though such changes do not fire the {{DOMxRef("RTCPeerConnection/negotiationneeded_event", "negotiationneeded")}} event).
If you are relying on the Chrome behavior, note that other browsers do not have it.
You can write web compatible code using feature detection instead:

```js
// Add a track to a stream and the peer connection said stream was added to:

stream.addTrack(track);
if (pc.addTrack) {
  pc.addTrack(track, stream);
} else {
  // If you have code listening for negotiationneeded events:
  setTimeout(() => pc.dispatchEvent(new Event("negotiationneeded")));
}

// Remove a track from a stream and the peer connection said stream was added to:

stream.removeTrack(track);
if (pc.removeTrack) {
  pc.removeTrack(pc.getSenders().find((sender) => sender.track === track));
} else {
  // If you have code listening for negotiationneeded events:
  setTimeout(() => pc.dispatchEvent(new Event("negotiationneeded")));
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
# RTCPeerConnection: addTrack() method

{{APIRef("WebRTC")}}

The **`addTrack()`** method of the {{domxref("RTCPeerConnection")}} interface adds a new media track to the set of tracks which will be transmitted to the other peer.

> [!NOTE]
> Adding a track to a connection triggers renegotiation by firing a {{DOMxRef("RTCPeerConnection/negotiationneeded_event", "negotiationneeded")}} event.
> See [Starting negotiation](/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling#starting_negotiation) for details.

## Syntax

```js-nolint
addTrack(track)
addTrack(track, stream1)
addTrack(track, stream1, stream2)
addTrack(track, stream1, stream2, /* …, */ streamN)
```

### Parameters

- `track`
  - : A {{domxref("MediaStreamTrack")}} object representing the media track to add to the peer connection.
- `stream1`, …, `streamN` {{optional_inline}}
  - : One or more local {{domxref("MediaStream")}} objects to which the track should be added.

The specified `track` doesn't necessarily have to already be part of any of the specified `stream`s.
Instead, the `stream`s are a way to group tracks together on the receiving end of the connection, making sure they are synchronized.
Any tracks that are added to the same stream on the local end of the connection will be on the same stream on the remote end.

### Return value

The {{domxref("RTCRtpSender")}} object which will be used to transmit the media data.

> [!NOTE]
> Every `RTCRtpSender` is paired with an {{domxref("RTCRtpReceiver")}} to make up an {{domxref("RTCRtpTransceiver")}}.
> The associated receiver is muted (indicating that it is not able to deliver packets) until and unless one or more streams are added to the receiver by the remote peer.

### Exceptions

- `InvalidAccessError` {{domxref("DOMException")}}
  - : Thrown if the specified track (or all of its underlying streams) is already part of the {{domxref("RTCPeerConnection")}}.
- `InvalidStateError` {{domxref("DOMException")}}
  - : Thrown if the {{domxref("RTCPeerConnection")}} is closed.

## Usage notes

### Adding tracks to multiple streams

After the `track` parameter, you can optionally specify one or more {{domxref("MediaStream")}} objects to add the track to.
Only tracks are sent from one peer to another, not streams.
Since streams are specific to each peer, specifying one or more streams means the other peer will create a corresponding stream (or streams) automatically on the other end of the connection, and will then automatically add the received track to those streams.

#### Streamless tracks

If no streams are specified, then the track is **streamless**.
This is perfectly acceptable, although it will be up to the remote peer to decide what stream to insert the track into, if any.
This is a very common way to use `addTrack()` when building many types of simple applications, where only one stream is needed.
For example, if all you're sharing with the remote peer is a single stream with an audio track and a video track, you don't need to deal with managing what track is in what stream, so you might as well just let the transceiver handle it for you.

Here's an example showing a function that uses {{domxref("MediaDevices.getUserMedia", "getUserMedia()")}} to obtain a stream from a user's camera and microphone, then adds each track from the stream to the peer connection, without specifying a stream for each track:

```js
async function openCall(pc) {
  const gumStream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: true,
  });
  for (const track of gumStream.getTracks()) {
    pc.addTrack(track);
  }
}
```

The result is a set of tracks being sent to the remote peer, with no stream associations.
The handler for the {{DOMxRef("RTCPeerConnection/track_event", "track")}} event on the remote peer will be responsible for determining what stream to add each track to, even if that means adding them all to the same stream.
The {{domxref("RTCPeerConnection.track_event", "ontrack")}} handler might look like this:

```js
let inboundStream = null;

pc.ontrack = (ev) => {
  if (ev.streams && ev.streams[0]) {
    videoElem.srcObject = ev.streams[0];
  } else {
    if (!inboundStream) {
      inboundStream = new MediaStream();
      videoElem.srcObject = inboundStream;
    }
    inboundStream.addTrack(ev.track);
  }
};
```

Here, the `track` event handler adds the track to the first stream specified by the event, if a stream is specified.
Otherwise, the first time `ontrack` is called, a new stream is created and attached to the video element, and then the track is added to the new stream.
From then on, new tracks are added to that stream.

You could also just create a new stream for each track received:

```js
pc.ontrack = (ev) => {
  if (ev.streams && ev.streams[0]) {
    videoElem.srcObject = ev.streams[0];
  } else {
    let inboundStream = new MediaStream(ev.track);
    videoElem.srcObject = inboundStream;
  }
};
```

#### Associating tracks with specific streams

By specifying a stream and allowing {{domxref("RTCPeerConnection")}} to create streams for you, the streams' track associations are automatically managed for you by the WebRTC infrastructure.
This includes things like changes to the transceiver's {{domxref("RTCRtpTransceiver.direction", "direction")}} and tracks being halted using {{domxref("RTCPeerConnection.removeTrack", "removeTrack()")}}.

For example, consider this function that an application might use to begin streaming a device's camera and microphone input over an {{domxref("RTCPeerConnection")}} to a remote peer:

```js
async function openCall(pc) {
  const gumStream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: true,
  });
  for (const track of gumStream.getTracks()) {
    pc.addTrack(track, gumStream);
  }
}
```

The remote peer might then use a {{DOMxRef("RTCPeerConnection/track_event", "track")}} event handler that looks like this:

```js
pc.ontrack = ({ streams: [stream] }) => (videoElem.srcObject = stream);
```

This sets the video element's current stream to the one that contains the track that's been added to the connection.

### Reused senders

This method returns a new `RTCRtpSender` or an existing instance for reuse.
An `RTCRtpSender` instance is only compatible for reuse if it meets the following criteria:

- There is no track already associated with the sender.
- The {{domxref("RTCRtpTransceiver")}} associated with the sender has a {{domxref("RTCRtpReceiver")}} whose {{domxref("RTCRtpReceiver.track", "track")}} property specifies a {{domxref("MediaStreamTrack")}} whose {{domxref("MediaStreamTrack.kind", "kind")}} is the same as the `kind` of the `track` parameter specified when calling
  `RTCPeerConnection.addTrack()`. This ensures that a transceiver only handles audio or video and never both.
- The {{domxref("RTCRtpTransceiver.currentDirection")}} property is not `"stopped"`.
- The `RTCRtpSender` being considered has never been used to send data.
  If the transceiver's {{domxref("RTCRtpTransceiver.currentDirection", "currentDirection")}} has ever been `"sendrecv"` or `"sendonly"`, the sender can't be reused.

If all of those criteria are met, the sender gets reused, which results in these changes occurring to the existing `RTCRtpSender` and its `RTCRtpTransceiver`:

- The `RTCRtpSender`'s {{domxref("RTCRtpSender.track", "track")}} is set to the specified track.
- The sender's set of associated streams is set to the list of streams passed into this method, `stream1`, …, `streamN`.
- The associated {{domxref("RTCRtpTransceiver")}} has its `currentDirection` updated to indicate that it is sending;
  if its current value is `"recvonly"`, it becomes `"sendrecv"`, and if its current value is `"inactive"`, it becomes `"sendonly"`.

### New senders

If no existing sender exists that can be reused, a new one is created. This also
results in the creation of the associated objects that must exist. The process of
creating a new sender results in these changes:

- The new `RTCRtpSender` is created with the specified track and set of stream(s).
- A new {{domxref("RTCRtpReceiver")}} is created with a _new_ {{domxref("MediaStreamTrack")}} as its {{domxref("RTCRtpReceiver.track", "track")}} property (not the track specified as a parameter when calling `addTrack()`).
  This track's {{domxref("MediaStreamTrack.kind", "kind")}} is set to match the `kind` of the track provided as an input parameter.
- A new {{domxref("RTCRtpTransceiver")}} is created and associated with the new sender and receiver.
- The new transceiver's {{domxref("RTCRtpTransceiver.direction", "direction")}} is set to `"sendrecv"`.
- The new transceiver is added to the `RTCPeerConnection`'s set of transceivers.

## Examples

This example is drawn from the code presented in the article [Signaling and video calling](/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling) and its corresponding sample code.
It comes from the `handleVideoOfferMsg()` method there, which is called when an offer message is received from the remote peer.

```js
const mediaConstraints = {
  audio: true, // We want an audio track
  video: true, // And we want a video track
};

const desc = new RTCSessionDescription(sdp);

pc.setRemoteDescription(desc)
  .then(() => navigator.mediaDevices.getUserMedia(mediaConstraints))
  .then((stream) => {
    previewElement.srcObject = stream;

    stream.getTracks().forEach((track) => pc.addTrack(track, stream));
  });
```

This code takes SDP which has been received from the remote peer and constructs a new {{domxref("RTCSessionDescription")}} to pass into {{domxref("RTCPeerConnection.setRemoteDescription", "setRemoteDescription()")}}.
Once that succeeds, it uses {{domxref("MediaDevices.getUserMedia()")}} to obtain access to the local webcam and microphone.

If that succeeds, the resulting stream is assigned as the source for a {{HTMLElement("video")}} element which is referenced by the variable `previewElement`.

The final step is to begin sending the local video across the peer connection to the caller.
This is done by adding each track in the stream by iterating over the list returned by {{domxref("MediaStream.getTracks()")}} and passing them to `addTrack()` along with the `stream` which they're a component of.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
- [Introduction to the Real-time Transport Protocol (RTP)](/en-US/docs/Web/API/WebRTC_API/Intro_to_RTP)
- {{DOMxRef("RTCPeerConnection/track_event", "track")}}
# RTCPeerConnection: addTransceiver() method

{{APIRef("WebRTC")}}

The **`addTransceiver()`** method of the {{domxref("RTCPeerConnection")}} interface creates a new {{domxref("RTCRtpTransceiver")}} and adds it to the set of transceivers associated with the `RTCPeerConnection`.
Each transceiver represents a bidirectional stream, with both an {{domxref("RTCRtpSender")}} and an {{domxref("RTCRtpReceiver")}} associated with it.

## Syntax

```js-nolint
addTransceiver(trackOrKind)
addTransceiver(trackOrKind, init)
```

### Parameters

- `trackOrKind`
  - : A {{domxref("MediaStreamTrack")}} to associate with the transceiver, or a string which is used as the {{domxref("MediaStreamTrack.kind", "kind")}} of the receiver's {{domxref("RTCRtpReceiver.track", "track")}}, and by extension of the {{domxref("RTCRtpReceiver")}} itself.
- `init` {{optional_inline}}
  - : An object for specifying any options when creating the new transceiver.
    Possible values are:
    - `direction` {{optional_inline}}
      - : The new transceiver's preferred directionality. This value is used to initialize the new {{domxref("RTCRtpTransceiver")}} object's {{domxref("RTCRtpTransceiver.direction")}} property.
    - `sendEncodings` {{optional_inline}}
      - : An array of encodings to allow when sending RTP media from the {{domxref("RTCRtpSender")}}.
        This is the same as the [`parameter.encodings`](/en-US/docs/Web/API/RTCRtpSender/setParameters#encodings) array passed to {{domxref("RTCRtpSender.setParameters()")}}.
    - `streams` {{optional_inline}}
      - : A list of {{domxref("MediaStream")}} objects to add to the transceiver's {{domxref("RTCRtpReceiver")}}; when the remote peer's {{domxref("RTCPeerConnection")}}'s {{domxref("RTCPeerConnection.track_event", "track")}} event occurs, these are the streams that will be specified by that event.

### Return value

The {{domxref("RTCRtpTransceiver")}} object which will be used to exchange the media data.

### Exceptions

- {{jsxref("TypeError")}}
  - : Thrown if `trackOrKind` was not either `"audio"` or `"video"`.

    If the `sendEncodings` argument is used, this error may also be thrown if there is a badly formatted `rid` member, some but not all encodings contain a `rid` member, or different encodings have the same `rid` value.

- {{jsxref("RangeError")}}
  - : Thrown if any of the `sendEncodings` encodings have a `maxFramerate` value less than 0.0, or a `scaleResolutionDownBy` value of less than 1.0.

- `InvalidStateError` {{domxref("DOMException")}}
  - : Thrown if the method is called when the associated connection is closed.

- `InvalidAccessError` {{domxref("DOMException")}}
  - : Thrown if the `sendEncodings` argument is used, and contains a read-only parameter other than `rid`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- [Introduction to the Real-time Transport Protocol (RTP)](/en-US/docs/Web/API/WebRTC_API/Intro_to_RTP)
- {{domxref("RTCPeerConnection.addTrack()")}} also creates transceivers
- {{domxref("RTCRtpReceiver")}} and {{domxref("RTCRtpSender")}}
# RTCPeerConnection: canTrickleIceCandidates property

{{APIRef("WebRTC")}}

The **`canTrickleIceCandidates`** read-only property of the {{domxref("RTCPeerConnection")}} interface returns a boolean value which indicates whether or not the remote peer can accept [trickled ICE candidates](https://datatracker.ietf.org/doc/html/draft-ietf-mmusic-trickle-ice).

**ICE trickling** is the process of continuing to send candidates after the initial offer or answer has already been sent to the other peer.

This property is only set after having called {{domxref("RTCPeerConnection.setRemoteDescription()")}}. Ideally, your signaling protocol provides a way to detect trickling support, so that you don't need to rely on this property.
A WebRTC browser will always support trickle ICE. If trickling isn't supported, or you aren't able to tell, you can check for a falsy value for this property and then wait until the value of {{domxref("RTCPeerConnection.iceGatheringState", "iceGatheringState")}} changes to `"completed"` before creating and sending the initial offer.
That way, the offer contains all of the candidates.

## Value

A boolean value that is `true` if the remote peer can accept trickled ICE candidates and `false` if it cannot.
If no remote peer has been established, this value is `null`.

> [!NOTE]
> This property's value is determined once the local peer has called {{domxref("RTCPeerConnection.setRemoteDescription()")}};
> the provided description is used by the ICE agent to determine whether or not the remote peer supports trickled ICE candidates.

## Examples

```js
const pc = new RTCPeerConnection();

function waitToCompleteIceGathering(pc) {
  return new Promise((resolve) => {
    pc.addEventListener(
      "icegatheringstatechange",
      (e) =>
        e.target.iceGatheringState === "complete" &&
        resolve(pc.localDescription),
    );
  });
}

// The following code might be used to handle an offer from a peer when
// it isn't known whether it supports trickle ICE.
async function newPeer(remoteOffer) {
  await pc.setRemoteDescription(remoteOffer);
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  if (pc.canTrickleIceCandidates) return pc.localDescription;
  const answer = await waitToCompleteIceGathering(pc);
  sendAnswerToPeer(answer); // To peer via signaling channel
}
// Handle error with try/catch

pc.addEventListener(
  "icecandidate",
  (e) => pc.canTrickleIceCandidates && sendCandidateToPeer(e.candidate),
);
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCPeerConnection.addIceCandidate()")}}
- [Lifetime of a WebRTC session](/en-US/docs/Web/API/WebRTC_API/Session_lifetime)
# RTCPeerConnection: close() method

{{APIRef("WebRTC")}}

The **`close()`** method of the {{domxref("RTCPeerConnection")}} interface closes the current peer connection.

Calling this method terminates the `RTCPeerConnection`'s ICE agent, ending any ongoing ICE processing and any active streams.
This also releases any resources in use by the ICE agent, including TURN permissions.
All {{domxref("RTCRtpSender")}} objects are considered to be stopped once this returns (they may still be in the process of stopping, but for all intents and purposes, they're stopped).

Once this method returns, the signaling state as returned by {{domxref("RTCPeerConnection.signalingState")}} is `closed`.

Make sure that you `delete` all references to the previous {{domxref("RTCPeerConnection")}} before attempting to create a new one that connects to the same remote peer, as not doing so might result in some errors depending on the browser.

## Syntax

```js-nolint
close()
```

### Parameters

None.

### Return value

None (`undefined`).

## Example

```js
const pc = new RTCPeerConnection();
const dc = pc.createDataChannel("my channel");

dc.onmessage = (event) => {
  console.log(`received: ${event.data}`);
  pc.close(); // We decided to close after the first received message
};

dc.onopen = () => {
  console.log("datachannel open");
};

dc.onclose = () => {
  console.log("datachannel close");
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCPeerConnection")}}
- {{domxref("RTCPeerConnection.signalingState")}}
# RTCPeerConnection: connectionState property

{{APIRef("WebRTC")}}

The **`connectionState`** read-only property of the {{domxref("RTCPeerConnection")}} interface indicates the current state of the peer connection by returning one of the following string values: `new`, `connecting`, `connected`, `disconnected`, `failed`, or `closed`.

This state essentially represents the aggregate state of all ICE transports (which are of type {{domxref("RTCIceTransport")}} or {{domxref("RTCDtlsTransport")}}) being used by the connection.

When this property's value changes, a {{domxref("RTCPeerConnection.connectionstatechange_event", "connectionstatechange")}} event is sent to the {{domxref("RTCPeerConnection")}} instance.

## Value

A string representing the current state of the connection.
This can take on of the following values:

- `new`
  - : At least one of the connection's {{Glossary("ICE")}} transports ({{domxref("RTCIceTransport")}} or {{domxref("RTCDtlsTransport")}} objects) is in the `new` state, and none of them are in one of the following states: `connecting`, `checking`, `failed`, `disconnected`, or all of the connection's transports are in the `closed` state.
- `connecting`
  - : One or more of the {{Glossary("ICE")}} transports are currently in the process of establishing a connection;
    that is, their {{DOMxRef("RTCPeerConnection.iceConnectionState", "iceConnectionState")}} is either `checking` or `connected`, and no transports are in the `failed` state.
- `connected`
  - : Every {{Glossary("ICE")}} transport used by the connection is either in use (state `connected` or `completed`) or is closed (state `closed`);
    in addition, at least one transport is either `connected` or `completed`.
- `disconnected`
  - : At least one of the {{Glossary("ICE")}} transports for the connection is in the `disconnected` state and none of the other transports are in the states: `failed`, `connecting`, or `checking`.
- `failed`
  - : One or more of the {{Glossary("ICE")}} transports on the connection is in the `failed` state.
- `closed`
  - : The {{DOMxRef("RTCPeerConnection")}} is closed.

## Example

```js
const peerConnection = new RTCPeerConnection(configuration);

// …

const connectionState = peerConnection.connectionState;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Lifetime of a WebRTC session](/en-US/docs/Web/API/WebRTC_API/Session_lifetime)
- {{domxref("RTCPeerConnection")}}
- {{domxref("RTCPeerConnection.connectionstatechange_event", "connectionstatechange")}}
- {{domxref("RTCIceTransport.state")}}
- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
# RTCPeerConnection: connectionstatechange event

{{APIRef("WebRTC")}}

The **`connectionstatechange`** event is sent to the `onconnectionstatechange` event handler on an {{domxref("RTCPeerConnection")}} object after a new track has been added to an {{domxref("RTCRtpReceiver")}} which is part of the connection.
The new connection state can be found in {{domxref("RTCPeerConnection.connectionState", "connectionState")}}, and is one of the string values: `new`, `connecting`, `connected`, `disconnected`, `failed`, or `closed`.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("connectionstatechange", (event) => { })

onconnectionstatechange = (event) => { }
```

## Event type

A generic {{domxref("Event")}}.

## Examples

For an {{domxref("RTCPeerConnection")}} named `peerConnection`, this example uses {{domxref("EventTarget.addEventListener", "addEventListener()")}} to handle changes to the connectivity of the WebRTC session.
It calls an app-defined function called `setOnlineStatus()` to update a status display.

```js
peerConnection.addEventListener("connectionstatechange", (event) => {
  switch (peerConnection.connectionState) {
    case "new":
    case "connecting":
      setOnlineStatus("Connecting…");
      break;
    case "connected":
      setOnlineStatus("Online");
      break;
    case "disconnected":
      setOnlineStatus("Disconnecting…");
      break;
    case "closed":
      setOnlineStatus("Offline");
      break;
    case "failed":
      setOnlineStatus("Error");
      break;
    default:
      setOnlineStatus("Unknown");
      break;
  }
});
```

You can also create a handler for the `connectionstatechange` event using the `RTCPeerConnection.onconnectionstatechange` property:

```js
peerConnection.onconnectionstatechange = (ev) => {
  switch (peerConnection.connectionState) {
    case "new":
    case "connecting":
      setOnlineStatus("Connecting…");
      break;
    // …
    default:
      setOnlineStatus("Unknown");
      break;
  }
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- [WebRTC connectivity](/en-US/docs/Web/API/WebRTC_API/Connectivity)
- [Lifetime of a WebRTC session](/en-US/docs/Web/API/WebRTC_API/Session_lifetime)
- {{domxref("RTCPeerConnection.connectionState")}}
# RTCPeerConnection: createAnswer() method

{{APIRef("WebRTC")}}

The **`createAnswer()`** method of the {{domxref("RTCPeerConnection")}} interface creates an {{Glossary("SDP")}} answer to an offer received from a remote peer during the offer/answer negotiation of a WebRTC connection.

The answer contains information about any media already attached to the session, codecs and options supported by the browser, and any {{Glossary("ICE")}} candidates already gathered.
The answer is delivered to the returned {{jsxref("Promise")}}, and should then be sent to the source of the offer to continue the negotiation process.

## Syntax

```js-nolint
createAnswer()
createAnswer(options)

createAnswer(successCallback, failureCallback) // deprecated
createAnswer(successCallback, failureCallback, options) // deprecated
```

### Parameters

- `options` {{optional_inline}}
  - : An optional object providing options requested for the answer.
    Currently, there are no available options.

### Deprecated parameters

In older code and documentation, you may see a callback-based version of this function.
This has been deprecated and its use is **strongly** discouraged.
You should update any existing code to use the {{jsxref("Promise")}}-based version of `createAnswer()` instead.
The parameters for the older form of `createAnswer()` are described below, to aid in updating existing code.

- `successCallback` {{deprecated_inline}}
  - : A [callback function](/en-US/docs/Glossary/Callback_function) which will be passed a single {{domxref("RTCSessionDescription")}} object describing the newly-created answer.
- `failureCallback` {{deprecated_inline}}
  - : A [callback function](/en-US/docs/Glossary/Callback_function) which will be passed a single {{domxref("DOMException")}} object explaining why the request to create an answer failed.
- `options` {{optional_inline}}
  - : An optional object providing options requested for the answer.

### Exceptions

- `NotReadableError`
  - : The identity provider wasn't able to provide an identity assertion.
- `OperationError`
  - : Generation of the SDP failed for some reason; this is a general failure catch-all exception.

### Return value

A {{jsxref("Promise")}} that fulfills with an object containing the same properties as an {{domxref("RTCSessionDescription")}} objects:

- `type`
  - : A string whose value is `"answer"`.
- `sdp`
  - : A string containing the SDP describing the session, to be delivered to the remote peer.

## Examples

Here is a segment of code taken from the code that goes with the article [Signaling and video calling](/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling).
This code comes from the handler for the message sent to carry an offer to another peer across the signaling channel.

> [!NOTE]
> Keep in mind that this is part of the signaling process, the transport layer for which is an implementation detail that's entirely up to you.
> In this case, a [WebSocket](/en-US/docs/Web/API/WebSockets_API) connection is used to send a {{Glossary("JSON")}} message with a `type` field with the value "video-answer" to the other peer, carrying the answer to the device which sent the offer to connect.
> The contents of the object being passed to the `sendToServer()` function, along with everything else in the promise fulfillment handler, depend entirely on your design

```js
pc.createAnswer()
  .then((answer) => pc.setLocalDescription(answer))
  .then(() => {
    // Send the answer to the remote peer through the signaling server.
  })
  .catch(handleGetUserMediaError);
```

This asks {{domxref("RTCPeerConnection")}} to create and return a new answer.
In our promise handler, the returned answer is set as the description of the local end of the connection by calling {{domxref("RTCPeerConnection.setLocalDescription", "setLocalDescription()")}}.

Once that succeeds, the answer is sent to the signaling server using whatever protocol you see fit.

{{jsxref("Promise.catch()")}} is used to trap and handle errors.

See [Handling the invitation](/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling#handling_the_invitation) in our WebRTC chat example to view the complete code from which this snippet is derived; that will help you understand the signaling process and how answers work.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCPeerConnection: createDataChannel() method

{{APIRef("WebRTC")}}

The **`createDataChannel()`** method of the {{domxref("RTCPeerConnection")}} interface creates a new channel linked with the remote peer, over which any kind of data may be transmitted.
This can be useful for back-channel content, such as images, file transfer, text chat, game update packets, and so forth.

If the new data channel is the first one added to the connection, renegotiation is started by delivering a {{DOMxRef("RTCPeerConnection/negotiationneeded_event", "negotiationneeded")}} event.

## Syntax

```js-nolint
createDataChannel(label)
createDataChannel(label, options)
```

### Parameters

- `label`
  - : A human-readable name for the channel.
    This string may not be longer than 65,535 bytes.
- `options` {{optional_inline}}
  - : An object providing configuration options for the data channel.
    It can contain the following fields:
    - `ordered` {{optional_inline}}
      - : Indicates whether or not messages sent on the {{domxref("RTCDataChannel")}} are required to arrive at their destination in the same order in which they were sent (`true`), or if they're allowed to arrive out-of-order (`false`).
        **Default: `true`.**
    - `maxPacketLifeTime` {{optional_inline}}
      - : The maximum number of milliseconds that attempts to transfer a message may take in unreliable mode.
        While this value is a 16-bit unsigned number, each user agent may clamp it to whatever maximum it deems appropriate.
        **Default: `null`.**
    - `maxRetransmits` {{optional_inline}}
      - : The maximum number of times
        the user agent should attempt to retransmit a message which fails the first time in unreliable mode.
        While this value is a 16-bit unsigned number, each user agent may clamp it to whatever maximum it deems appropriate.
        **Default: `null`.**
    - `protocol` {{optional_inline}}
      - : The name of the sub-protocol being used on the {{domxref("RTCDataChannel")}}, if any;
        otherwise, the empty string (`""`).
        **Default: empty string (`""`).**
        This string may not be longer than 65,535 _bytes_.
    - `negotiated` {{optional_inline}}
      - : By default (`false`), data channels are negotiated in-band, where one side calls `createDataChannel`, and the other side listens to the {{domxref("RTCDataChannelEvent")}} event using the {{DOMxRef("RTCPeerConnection.datachannel_event", "ondatachannel")}} event handler.
        Alternatively (`true`), they can be negotiated out of-band, where both sides call `createDataChannel` with an agreed-upon ID.
        **Default: `false`.**
    - `id` {{optional_inline}}
      - : A 16-bit numeric ID for the channel;
        permitted values are 0 to 65534.
        If you don't include this option, the user agent will select an ID for you.

> [!NOTE]
> These options represent the script-settable subset of the properties on the {{domxref("RTCDataChannel")}} interface.

### Return value

A new {{domxref("RTCDataChannel")}} object with the specified `label`, configured using the options specified by `options` if that parameter is included; otherwise, the defaults listed above are established.

### Exceptions

- `InvalidStateError` {{domxref("DOMException")}}
  - : Thrown if the {{domxref("RTCPeerConnection")}} is closed.
- {{jsxref("TypeError")}}
  - : Thrown in the following situations:
    - The label and/or protocol string is too long; these cannot be longer than 65,535 bytes (bytes, rather than characters).
    - The `id` is 65535. While this is a valid unsigned 16-bit value, it's not a permitted value for `id`.
- `SyntaxError` {{domxref("DOMException")}}
  - : Thrown if values were specified for both the `maxPacketLifeTime` and `maxRetransmits` options.
    You may specify a non-`null` value for only one of these.
- `ResourceInUse` {{domxref("DOMException")}}
  - : Thrown if an `id` was specified, but another {{domxref("RTCDataChannel")}} is already using the same value.
- `OperationError` {{domxref("DOMException")}}
  - : Thrown if either the specified `id` is already in use, or if no `id` was specified, the WebRTC layer was unable to automatically generate an ID because all IDs are in use.

## Examples

This example shows how to create a data channel and set up handlers for the {{DOMxRef("RTCDataChannel/open_event", "open")}} and {{DOMxRef("RTCDataChannel/message_event", "message")}} events to send and receive messages on it (For brevity, the example assumes onnegotiationneeded is set up).

```js
// Offerer side

const pc = new RTCPeerConnection(options);
const channel = pc.createDataChannel("chat");
channel.onopen = (event) => {
  channel.send("Hi you!");
};
channel.onmessage = (event) => {
  console.log(event.data);
};
```

```js
// Answerer side

const pc = new RTCPeerConnection(options);
pc.ondatachannel = (event) => {
  const channel = event.channel;
  channel.onopen = (event) => {
    channel.send("Hi back!");
  };
  channel.onmessage = (event) => {
    console.log(event.data);
  };
};
```

Alternatively, more symmetrical out-of-band negotiation can be used, using an agreed-upon id (0 here):

```js
// Both sides

const pc = new RTCPeerConnection(options);
const channel = pc.createDataChannel("chat", { negotiated: true, id: 0 });
channel.onopen = (event) => {
  channel.send("Hi!");
};
channel.onmessage = (event) => {
  console.log(event.data);
};
```

For a more thorough example showing how the connection and channel are established, see [A simple RTCDataChannel sample](/en-US/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCDataChannel")}}
- [A simple RTCDataChannel sample](/en-US/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample)
- {{domxref("RTCPeerConnection")}}
# RTCPeerConnection: createDTMFSender() method

{{APIRef("WebRTC")}}{{Deprecated_Header}}{{non-standard_header}}

The **`createDTMFSender()`** method of the {{domxref("RTCPeerConnection")}} interface creates a new {{domxref("RTCDTMFSender")}} object associated with the specified {{domxref("MediaStreamTrack")}}, which can be used to send DTMF tones over the connection.

This method is deprecated and should not be used. Instead, use the {{domxref("RTCRtpSender.dtmf")}} property to access the DTMF sender associated with a specific sender.

## Syntax

```js-nolint
createDTMFSender(track)
```

### Parameters

- `track`
  - : A {{domxref("MediaStreamTrack")}} object representing the track to associate with the new DTMF sender.

### Return value

A new {{domxref("RTCDTMFSender")}} object.

## Examples

This example creates a new DTMF sender associated with the specified track.

```js
navigator.getUserMedia({ audio: true }, (stream) => {
  const pc = new RTCPeerConnection();
  const track = stream.getAudioTracks()[0];
  const dtmfSender = pc.createDTMFSender(track);
});
```

This could be rewritten using the {{domxref("RTCRtpSender.dtmf")}} property:

```js
navigator.getUserMedia({ audio: true }, (stream) => {
  const pc = new RTCPeerConnection();
  const track = stream.getAudioTracks()[0];
  const sender = pc.addTrack(track, stream);
  const dtmfSender = sender.dtmf;
});
```

## Specifications

This feature is non-standard and not part of any specification.

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCDTMFSender")}}
- {{domxref("RTCRtpSender")}}
- {{domxref("RTCPeerConnection")}}
# RTCPeerConnection: createOffer() method

{{APIRef("WebRTC")}}

The **`createOffer()`** method of the {{domxref("RTCPeerConnection")}} interface initiates the creation of an {{Glossary("SDP")}} offer for the purpose of starting a new WebRTC connection to a remote peer.

The SDP offer includes information about any {{domxref("MediaStreamTrack")}} objects already attached to the WebRTC session, codec, and options supported by the browser, and any candidates already gathered by the {{Glossary("ICE")}} agent, for the purpose of being sent over the signaling channel to a potential peer to request a connection or to update the configuration of an existing connection.

## Syntax

```js-nolint
createOffer()
createOffer(options)

createOffer(successCallback, failureCallback) // deprecated
createOffer(successCallback, failureCallback, options) // deprecated
```

### Parameters

- `options` {{optional_inline}}
  - : An object providing the following options requested for the offer:
    - `iceRestart` {{optional_inline}}
      - : To restart ICE on an active connection, set this to `true`.
        This will cause the returned offer to have different credentials than those already in place.
        If you then apply the returned offer, ICE will restart.
        Specify `false` to keep the same credentials and therefore not restart ICE.
        **The default is `false`**. Instead of using this option, consider calling {{domxref("RTCPeerConnection.restartIce()")}}, which will automatically set this flag the next time `createOffer()` is called.
    - `offerToReceiveAudio` {{optional_inline}} {{deprecated_inline}}
      - : Provides additional control over the directionality of audio. For example, it can be used to ensure that audio can be received, regardless if audio is sent or not.
    - `offerToReceiveVideo` {{optional_inline}} {{deprecated_inline}}
      - : Provides additional control over the directionality of video. For example, it can be used to ensure that video can be received, regardless if video is sent or not.

### Deprecated parameters

In older code and documentation, you may see a callback-based version of this function.
This has been deprecated and its use is **strongly** discouraged.
You should update any existing code to use the {{jsxref("Promise")}}-based version of `createOffer()` instead.
The parameters for the older form of `createOffer()` are described below, to aid in updating existing code.

- `successCallback` {{deprecated_inline}}
  - : A [callback function](/en-US/docs/Glossary/Callback_function) which will be passed a single {{domxref("RTCSessionDescription")}} object describing the newly-created offer.
- `errorCallback` {{deprecated_inline}}
  - : A [callback function](/en-US/docs/Glossary/Callback_function) which will be passed a single {{domxref("DOMException")}} object explaining why the request to create an offer failed.
- `options` {{optional_inline}}
  - : An optional object providing options requested for the offer.

### Return value

A {{jsxref("Promise")}} that fulfills with an object containing the same properties as an {{domxref("RTCSessionDescription")}} objects:

- `type`
  - : A string whose value is `"offer"`.
- `sdp`
  - : A string containing the SDP describing the generated offer, to be delivered to the remote peer.

### Exceptions

These exceptions are returned by rejecting the returned promise.
Your rejection handler should examine the received exception to determine which occurred.

- `InvalidStateError` {{domxref("DOMException")}}
  - : Returned if the `RTCPeerConnection` is closed.
- `NotReadableError` {{domxref("DOMException")}}
  - : Returned if no certificate or set of certificates was provided for securing the connection, and `createOffer()` was unable to create a new one.
    Since all WebRTC connections are required to be secured, that results in an error.
- `OperationError` {{domxref("DOMException")}}
  - : Returned if examining the state of the system to determine resource availability in order to generate the offer failed for some reason.

## Examples

Here we see a handler for the {{DOMxRef("RTCPeerConnection/negotiationneeded_event", "negotiationneeded")}} event which creates the offer and sends it to the remote system over a signaling channel.

> [!NOTE]
> Keep in mind that this is part of the signaling process, the transport layer for which is an implementation detail that's entirely up to you.
> In this case, a [WebSocket](/en-US/docs/Web/API/WebSockets_API) connection is used to send a {{Glossary("JSON")}} message with a `type` field with the value "video-offer" to the other peer.
> The contents of the object being passed to the `sendToServer()` function, along with everything else in the promise fulfillment handler, depend entirely on your design.

```js
myPeerConnection
  .createOffer()
  .then((offer) => myPeerConnection.setLocalDescription(offer))
  .then(() => {
    sendToServer({
      name: myUsername,
      target: targetUsername,
      type: "video-offer",
      sdp: myPeerConnection.localDescription,
    });
  })
  .catch((reason) => {
    // An error occurred, so handle the failure to connect
  });
```

In this code, the offer is created, and once successful, the local end of the {{domxref("RTCPeerConnection")}} is configured to match by passing the offer (which is represented using an object in the same shape as {{domxref("RTCSessionDescription")}}) into {{domxref("RTCPeerConnection.setLocalDescription", "setLocalDescription()")}}.
Once that's done, the offer is sent to the remote system over the signaling channel; in this case, by using a custom function called `sendToServer()`.
The implementation of the signaling server is independent from the WebRTC specification, so it doesn't matter how the offer is sent as long as both the caller and potential receiver are using the same one.

Use {{jsxref("Promise.catch()")}} to trap and handle errors.

See [Signaling and video calling](/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling) for the complete example from which this snippet is derived; this will help you to understand how the signaling code here works.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCPeerConnection: currentLocalDescription property

{{APIRef("WebRTC")}}

The **`currentLocalDescription`** read-only property of the {{domxref("RTCPeerConnection")}} interface returns an {{domxref("RTCSessionDescription")}} object describing the local end of the connection as it was most recently successfully negotiated since the last time the {{domxref("RTCPeerConnection")}} finished negotiating and connecting to a remote peer.
Also included is a list of any ICE candidates that may already have been generated by the ICE agent since the offer or answer represented by the description was first instantiated.

To change the `currentLocalDescription`, call {{domxref("RTCPeerConnection.setLocalDescription()")}}, which triggers a series of events which leads to this value being set.
For details on what exactly happens and why the change isn't necessarily instantaneous, see [Pending and current descriptions](/en-US/docs/Web/API/WebRTC_API/Connectivity#pending_and_current_descriptions) in the WebRTC Connectivity page.

> [!NOTE]
> Unlike {{domxref("RTCPeerConnection.localDescription")}}, this value represents the actual current state of the local end of the connection;
> `localDescription` may specify a description which the connection is currently in the process of switching over to.

## Value

The current description of the local end of the connection, if one has been set.
If none has been successfully set, this value is `null`.

## Examples

This example looks at the `currentLocalDescription` and displays an alert containing the {{domxref("RTCSessionDescription")}} object's `type` and
`sdp` fields.

```js
const pc = new RTCPeerConnection();
// …
const sd = pc.currentLocalDescription;
if (sd) {
  alert(`Local session: type='${sd.type}'; sdp description='${sd.sdp}'`);
} else {
  alert("No local session yet.");
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

> [!NOTE]
> The addition of `currentLocalDescription` and {{domxref("RTCPeerConnection.pendingLocalDescription", "pendingLocalDescription")}} to the WebRTC spec is relatively recent.
> In browsers which don't support them, just use {{domxref("RTCPeerConnection.localDescription", "localDescription")}}.

## See also

- {{domxref("RTCPeerConnection.setLocalDescription()")}}, {{domxref("RTCPeerConnection.pendingLocalDescription")}}, {{domxref("RTCPeerConnection.localDescription")}}
- {{domxref("RTCPeerConnection.setRemoteDescription()")}}, {{domxref("RTCPeerConnection.remoteDescription")}}, {{domxref("RTCPeerConnection.pendingRemoteDescription")}}, {{domxref("RTCPeerConnection.currentRemoteDescription")}}
- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
# RTCPeerConnection: currentRemoteDescription property

{{APIRef("WebRTC")}}

The **`currentRemoteDescription`** read-only property of the {{domxref("RTCPeerConnection")}} interface returns an
{{domxref("RTCSessionDescription")}} object describing the remote end of the connection as it was most recently successfully negotiated since the last time the {{domxref("RTCPeerConnection")}} finished negotiating and connecting to a remote peer.
Also included is a list of any ICE candidates that may already have been generated by the ICE agent since the offer or answer represented by the description was first instantiated.

To change the `currentRemoteDescription`, call {{domxref("RTCPeerConnection.setRemoteDescription()")}}, which triggers a series of events which leads to this value being set.
For details on what exactly happens and why the change isn't necessarily instantaneous, see [Pending and current descriptions](/en-US/docs/Web/API/WebRTC_API/Connectivity#pending_and_current_descriptions) in the WebRTC Connectivity page.

> [!NOTE]
> Unlike {{domxref("RTCPeerConnection.remoteDescription")}}, this value represents the actual current state of the local end of the connection;
> `remoteDescription` may specify a description which the connection is currently in the process of switching over to.

## Value

The current description of the remote end of the connection, if one has been set.
If none has been successfully set, this value is `null`.

## Examples

This example looks at the `currentRemoteDescription` and displays an alert containing the {{domxref("RTCSessionDescription")}} object's `type` and `sdp` fields.

```js
const pc = new RTCPeerConnection();
// …
const sd = pc.currentRemoteDescription;
if (sd) {
  alert(`Local session: type='${sd.type}'; sdp description='${sd.sdp}'`);
} else {
  alert("No local session yet.");
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCPeerConnection.setRemoteDescription()")}}, {{domxref("RTCPeerConnection.pendingRemoteDescription")}}, {{domxref("RTCPeerConnection.remoteDescription")}}
- {{domxref("RTCPeerConnection.setRemoteDescription()")}}, {{domxref("RTCPeerConnection.remoteDescription")}}, {{domxref("RTCPeerConnection.pendingRemoteDescription")}}
- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
# RTCPeerConnection: datachannel event

{{APIRef("WebRTC")}}

A **`datachannel`** event is sent to an {{domxref("RTCPeerConnection")}} instance when an {{domxref("RTCDataChannel")}} has been added to the connection, as a result of the remote peer calling {{domxref("RTCPeerConnection.createDataChannel()")}}.

> [!NOTE]
> This event is _not_ dispatched when the local end of the connection creates the channel.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("datachannel", (event) => { })

ondatachannel = (event) => { }
```

## Event type

An {{domxref("RTCDataChannelEvent")}}. Inherits from {{domxref("Event")}}.

{{InheritanceDiagram("RTCDataChannelEvent")}}

## Event properties

_Also inherits properties from {{DOMxRef("Event")}}._

- {{DOMxRef("RTCDataChannelEvent.channel", "channel")}} {{ReadOnlyInline}}
  - : Returns the {{domxref("RTCDataChannel")}} associated with the event.

## Examples

This example sets up a function that handles `datachannel` events by gathering the information needed to communicate with the newly added {{domxref("RTCDataChannel")}} and by adding event handlers for the events that occur on that channel.

```js
pc.addEventListener("datachannel", (ev) => {
  receiveChannel = ev.channel;
  receiveChannel.onmessage = myHandleMessage;
  receiveChannel.onopen = myHandleOpen;
  receiveChannel.onclose = myHandleClose;
});
```

`receiveChannel` is set to the value of the event's {{domxref("RTCDataChannelEvent.channel", "channel")}} property, which specifies the `RTCDataChannel` object representing the data channel linking the remote peer to the local one.

This same code can also instead use the {{domxref("RTCPeerConnection")}} interface's `ondatachannel` event handler property, like this:

```js
pc.ondatachannel = (ev) => {
  receiveChannel = ev.channel;
  receiveChannel.onmessage = myHandleMessage;
  receiveChannel.onopen = myHandleOpen;
  receiveChannel.onclose = myHandleClose;
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- [Using WebRTC data channels](/en-US/docs/Web/API/WebRTC_API/Using_data_channels)
- [A simple RTCDataChannel sample](/en-US/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample)
- {{domxref("RTCDataChannelEvent")}}
- {{domxref("RTCPeerConnection.createDataChannel()")}}
# RTCPeerConnection: generateCertificate() static method

{{APIRef("WebRTC")}}

The **`generateCertificate()`** static function of the {{domxref("RTCPeerConnection")}} interface creates an X.509 certificate and corresponding private key, returning a promise that resolves with the new {{domxref("RTCCertificate")}} once it's generated.

## Syntax

```js-nolint
RTCPeerConnection.generateCertificate(keygenAlgorithm)
```

### Parameters

- `keygenAlgorithm`
  - : A [Web Crypto API](/en-US/docs/Web/API/Web_Crypto_API) algorithm identifier string or object. See {{domxref("SubtleCrypto.generateKey()")}} for details on the format of the object.

> [!NOTE]
> `generateCertificate()` is a static method, so it is always called on the `RTCPeerConnection` interface itself, not an instance thereof.

### Return value

A promise which resolves to a new {{domxref("RTCCertificate")}} object containing a new key based on the specified options.

### Exceptions

- `NotSupportedError` {{domxref("DOMException")}}
  - : Thrown if the normalized form of `keygenAlgorithm` specifies an algorithm or algorithm settings that the browser doesn't support, or which it does not allow for use with an {{domxref("RTCPeerConnection")}}.

Other errors may occur; for example, if the specified `keygenAlgorithm` can't be successfully converted into an {{domxref("RTCCertificateExpiration")}} dictionary, the error that occurs during that conversion will be thrown.

## Description

If a string is specified, it must be a [Web Crypto API](/en-US/docs/Web/API/Web_Crypto_API)-compatible algorithm name string.
Alternatively, you can provide specific details for the algorithm's configuration by providing an object based on one of the Web Crypto API's {{domxref("CryptoKey/algorithm","Algorithm")}} class's subclasses.

### Standard configurations

All browsers are required to support the following two configurations.
It's entirely possible that a browser's _default_ settings may be different, but these are always supported.

#### RSASSA-PKCS1-v1_5

```js
let stdRSACertificate = {
  name: "RSASSA-PKCS1-v1_5",
  modulusLength: 2048,
  publicExponent: new Uint8Array([1, 0, 1]),
  hash: "SHA-256",
};
```

#### ECDSA

```js
let stdECDSACertificate = {
  name: "ECDSA",
  namedCurve: "P-256",
};
```

### Certificate expiration time

By default the new certificate is configured with `expires` set to a value of 2592000000 milliseconds, or 30 days.
The expiration time cannot exceed 31536000000 milliseconds, or 365 days.
It's also useful to note that browsers may further restrict the expiration time of certificates if they choose.

## Examples

### Specifying algorithm details

This example requests a new RSASSA-PKCS1-v1_5 certificate using a SHA-256 hash and a modulus length of 2048.

```js
RTCPeerConnection.generateCertificate({
  name: "RSASSA-PKCS1-v1_5",
  hash: "SHA-256",
  modulusLength: 2048,
  publicExponent: new Uint8Array([1, 0, 1]),
}).then((cert) => {
  const pc = new RTCPeerConnection({ certificates: [cert] });
});
```

### Specifying an algorithm by name

The example below specifies a string requesting an [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm) certificate.

```js
RTCPeerConnection.generateCertificate("ECDSA");
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- [Web Crypto API](/en-US/docs/Web/API/Web_Crypto_API)
- [Website security](/en-US/docs/Learn_web_development/Extensions/Server-side/First_steps/Website_security)
- [Web security](/en-US/docs/Web/Security)
- {{Glossary("Symmetric-key cryptography")}}
- {{DOMxRef("Crypto")}}
# RTCPeerConnection: getConfiguration() method

{{APIRef("WebRTC")}}

The **`getConfiguration()`** method of the {{domxref("RTCPeerConnection")}} interface returns an object which indicates the current configuration of the {{domxref("RTCPeerConnection")}} on which the method is called.

The returned configuration is the last configuration applied via {{domxref("RTCPeerConnection.setConfiguration","setConfiguration()")}}, or if
`setConfiguration()` hasn't been called, the configuration the `RTCPeerConnection` was constructed with.
The configuration includes a list of the ICE servers used by the connection, information about transport policies, and identity information.

## Syntax

```js-nolint
getConfiguration()
```

### Parameters

None.

### Return value

An object describing the {{domxref("RTCPeerConnection")}}'s current configuration.
See [`RTCPeerConnection()`](/en-US/docs/Web/API/RTCPeerConnection/RTCPeerConnection#parameters) for more information on what options are allowed.

## Examples

This example adds a new certificate to an active connection if it doesn't already have
one in use.

```js
let configuration = myPeerConnection.getConfiguration();

if (configuration.certificates?.length === 0) {
  RTCPeerConnection.generateCertificate({
    name: "RSASSA-PKCS1-v1_5",
    hash: "SHA-256",
    modulusLength: 2048,
    publicExponent: new Uint8Array([1, 0, 1]),
  }).then((cert) => {
    configuration.certificates = [cert];
    myPeerConnection.setConfiguration(configuration);
  });
}
```

This example fetches the current configuration of the {{domxref("RTCPeerConnection")}}, then looks to see if it has any certificates set by examining whether or not (a) the configuration has a value for `certificates`, and (b) whether its length is zero.

If it's determined that there are no certificates in place, {{domxref("RTCPeerConnection.generateCertificate_static", "RTCPeerConnection.generateCertificate()")}} is called to create a new certificate; we provide a fulfillment handler which adds a new array containing the one newly-created certificate to the current configuration and passes it to {{domxref("RTCPeerConnection.setConfiguration", "setConfiguration()")}} to add the certificate to the connection.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCPeerConnection.setConfiguration()")}}
- {{domxref("RTCPeerConnection.RTCPeerConnection", "RTCPeerConnection()")}}
- {{domxref("RTCPeerConnection")}}
# RTCPeerConnection: getIdentityAssertion() method

{{APIRef("WebRTC")}}

The **`getIdentityAssertion()`** method of the {{domxref("RTCPeerConnection")}} interface initiates the gathering of an identity assertion.
This has an effect only if the {{domxref("RTCPeerConnection.signalingState", "signalingState")}} is not `"closed"`.

It is not expected for the application dealing with the `RTCPeerConnection`: this is automatically done; an explicit call only allows to anticipate the need.

## Syntax

```js-nolint
getIdentityAssertion()
```

### Parameters

None.

### Return value

A {{jsxref("Promise")}} which resolves to an identity assertion encoded as a string.

## Example

```js
const pc = new RTCPeerConnection();

pc.setIdentityProvider("developer.mozilla.org");
const assertion = await pc.getIdentityAssertion();
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
# RTCPeerConnection: getReceivers() method

{{APIRef("WebRTC")}}

The **`getReceivers()`** method of the {{domxref("RTCPeerConnection")}} interface returns an array of {{domxref("RTCRtpReceiver")}} objects, each of which represents one RTP receiver.
Each RTP receiver manages the reception and decoding of data for a {{domxref("MediaStreamTrack")}} on an {{domxref("RTCPeerConnection")}}.

## Syntax

```js-nolint
getReceivers()
```

### Parameters

None.

### Return value

An array of {{domxref("RTCRtpReceiver")}} objects, one for each track on the connection.
The array is empty if there are no RTP receivers on the connection.

The order of the returned `RTCRtpReceiver` instances is not defined by the specification, and may change from one call to `getReceivers()` to the next.

The array does not include receivers associated with transceivers that have been [stopped](/en-US/docs/Web/API/RTCRtpTransceiver/currentDirection) (following offer/answer).

## Example

tbd

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCRtpSender")}}
# RTCPeerConnection: getSenders() method

{{APIRef("WebRTC")}}

The **`getSenders()`** method of the {{domxref("RTCPeerConnection")}} interface returns an array of {{domxref("RTCRtpSender")}} objects, each of which represents the RTP sender responsible for transmitting one track's data.
A sender object provides methods and properties for examining and controlling the encoding and transmission of the track's data.

## Syntax

```js-nolint
getSenders()
```

### Parameters

None.

### Return value

An array of {{domxref("RTCRtpSender")}} objects, one for each track on the connection.
The array is empty if there are no RTP senders on the connection.

The order of the returned `RTCRtpSender` instances is not defined by the specification, and may change from one call to `getSenders()` to the next.

The array does not include senders associated with transceivers that have been [stopped](/en-US/docs/Web/API/RTCRtpTransceiver/currentDirection) (following offer/answer).

## Example

In this example, a `setMuting()` function is shown.
This function takes as input an {{domxref("RTCPeerConnection")}}, `pc`, and a Boolean, `muting`.
The function gets the list of the peer connection's senders and iterates over every sender, setting the corresponding media track's {{domxref("MediaStreamTrack.enabled", "enabled")}} to the inverse of the specified `muting`.

```js
function setMuting(pc, muting) {
  let senderList = pc.getSenders();

  senderList.forEach((sender) => {
    sender.track.enabled = !muting;
  });
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCRtpSender")}}
# RTCPeerConnection: getStats() method

{{APIRef("WebRTC")}}

The **`getStats()`** method of the {{domxref("RTCPeerConnection")}} interface returns a promise which resolves with data providing statistics about either the overall connection or about the specified {{domxref("MediaStreamTrack")}}.

## Syntax

```js-nolint
getStats()
getStats(selector)

getStats(selector, successCallback, failureCallback) // deprecated
```

### Parameters

- `selector` {{optional_inline}}
  - : A {{domxref("MediaStreamTrack")}} for which to gather statistics.
    If this is `null` (the default value), statistics will be gathered for the entire {{domxref("RTCPeerConnection")}}.

### Deprecated parameters

In older code and documentation, you may see a callback-based version of this function.
This has been deprecated and its use is **strongly** discouraged.
You should update any existing code to use the {{jsxref("Promise")}}-based version of `getStats()` instead.
The parameters for the older form of `getStats()` are described below, to aid in updating existing code.

- `successCallback` {{deprecated_inline}}
  - : A [callback function](/en-US/docs/Glossary/Callback_function) called once the report has been successfully generated.
- `failureCallback` {{deprecated_inline}}
  - : A [callback function](/en-US/docs/Glossary/Callback_function) called once the report has failed to be generated.

### Return value

A {{jsxref("Promise")}} which resolves with an {{domxref("RTCStatsReport")}} object providing connection statistics.
The report's contents depend on the `selector` and other details of the connection.

### Exceptions

This method does not throw exceptions; instead, it rejects the returned promise with one of the following errors:

- `InvalidAccessError` {{domxref("DOMException")}}
  - : Thrown when there is no {{domxref("RTCRtpSender")}} or {{domxref("RTCRtpReceiver")}} whose `track` matches the specified `selector`, or
    `selector` matches more than one sender or receiver.

## Examples

This example creates a periodic function using
{{domxref("Window.setInterval", "setInterval()")}} that collects
statistics for an {{domxref("RTCPeerConnection")}} every second, generating an
HTML-formatted report and inserting it into a specific element in the DOM.

```js
setInterval(() => {
  myPeerConnection.getStats(null).then((stats) => {
    let statsOutput = "";

    stats.forEach((report) => {
      statsOutput +=
        `<h2>Report: ${report.type}</h2>\n<strong>ID:</strong> ${report.id}<br>\n` +
        `<strong>Timestamp:</strong> ${report.timestamp}<br>\n`;

      // Now the statistics for this report; we intentionally drop the ones we
      // sorted to the top above

      Object.keys(report).forEach((statName) => {
        if (
          statName !== "id" &&
          statName !== "timestamp" &&
          statName !== "type"
        ) {
          statsOutput += `<strong>${statName}:</strong> ${report[statName]}<br>\n`;
        }
      });
    });

    document.querySelector(".stats-box").innerHTML = statsOutput;
  });
}, 1000);
```

This works by calling `getStats()`, then, when the promise is resolved, iterates over the {{domxref("RTCStatsReport")}} objects on the returned {{domxref("RTCStatsReport")}}.
A section is created for each report with a header and all of the statistics below, with the type, ID, and timestamp handled specially to place them at the top of the list.

Once the [HTML](/en-US/docs/Web/HTML) for the report is generated, it is injected into the element whose class is `"stats-box"` by setting its {{domxref("Element.innerHTML", "innerHTML")}} property.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCPeerConnection: getTransceivers() method

{{APIRef("WebRTC")}}

The **`getTransceivers()`** method of the {{domxref("RTCPeerConnection")}} interface returns a list of the {{domxref("RTCRtpTransceiver")}} objects being used to send and receive data on the connection.

## Syntax

```js-nolint
getTransceivers()
```

### Parameters

None.

### Return value

An array of the {{domxref("RTCRtpTransceiver")}} objects representing the transceivers handling sending and receiving all media on the `RTCPeerConnection`.
The array is in the order in which the transceivers were added to the connection.
The array does not include transceivers that have already been [stopped](/en-US/docs/Web/API/RTCRtpTransceiver/currentDirection) (following offer/answer).

## Examples

The following snippet of code stops all transceivers associated with an `RTCPeerConnection`.

```js
pc.getTransceivers().forEach((transceiver) => {
  transceiver.stop();
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- [Signaling and video calling](/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling)
- {{domxref("RTCPeerConnection.addTransceiver()")}}
- {{jsxref("Array.forEach()")}}
# RTCPeerConnection: icecandidate event

{{APIRef("WebRTC")}}

An **`icecandidate`** event is sent to an {{domxref("RTCPeerConnection")}} when:

- An {{domxref("RTCIceCandidate")}} has been identified and added to the local peer by a call to {{domxref("RTCPeerConnection.setLocalDescription()")}},
- Every {{domxref("RTCIceCandidate")}} correlated with a particular username fragment and password combination (a **generation**) has been so identified and added, and
- All ICE gathering on all transports is complete.

In the first two cases, the event handler should transmit the candidate to the remote peer over the signaling channel so the remote peer can add it to its set of remote candidates.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("icecandidate", (event) => { })

onicecandidate = (event) => { }
```

## Event type

An {{domxref("RTCPeerConnectionIceEvent")}}. Inherits from {{domxref("Event")}}.

{{InheritanceDiagram("RTCPeerConnectionIceEvent")}}

## Event properties

_A {{domxref("RTCPeerConnectionIceEvent")}} being an {{domxref("Event")}}, this event also implements the following property_.

- {{domxref("RTCPeerConnectionIceEvent.candidate")}} {{ReadOnlyInline}}
  - : Indicates the {{domxref("RTCIceCandidate")}} containing the candidate associated with the event.
    This will be the empty string if the event indicates that there are no further candidates to come in this **generation**, or `null` if all ICE gathering on all transports is complete.

## Description

There are three reasons why the `icecandidate` event is fired on an {{domxref("RTCPeerConnection")}}.

### Sharing a new candidate

The majority of `icecandidate` events are fired to indicate that a new candidate has been gathered. This candidate needs to be delivered to the remote peer over the signaling channel your code manages.

```js
rtcPeerConnection.onicecandidate = (event) => {
  if (event.candidate !== null) {
    sendCandidateToRemotePeer(event.candidate);
  } else {
    /* there are no more candidates coming during this negotiation */
  }
};
```

The remote peer, upon receiving the candidate, will add the candidate to its candidate pool by calling {{domxref("RTCPeerConnection.addIceCandidate", "addIceCandidate()")}}, passing in the {{domxref("RTCPeerConnectionIceEvent.candidate", "candidate")}} string you have passed along using the signaling server.

### Indicating the end of a generation of candidates

When an ICE negotiation session runs out of candidates to propose for a given {{domxref("RTCIceTransport")}}, it has completed gathering for a **generation** of candidates. That this has occurred is indicated by an `icecandidate` event whose {{domxref("RTCPeerConnectionIceEvent.candidate", "candidate")}} string is empty (`""`).

You should deliver this to the remote peer just like any standard candidate, as described under [Sharing a new candidate](#sharing_a_new_candidate) above. This ensures that the remote peer is given the end-of-candidates notification as well. As you see in the code in the previous section, every candidate is sent to the other peer, including any that might have an empty candidate string. Only candidates for which the event's {{domxref("RTCPeerConnectionIceEvent.candidate", "candidate")}} property is `null` are not forwarded across the signaling connection.

The end-of-candidates indication is described in [section 9.3 of the Trickle ICE draft specification](https://datatracker.ietf.org/doc/html/draft-ietf-mmusic-trickle-ice-02#section-9.3) (note that the section number is subject to change as the specification goes through repeated drafts).

### Indicating that ICE gathering is complete

Once all ICE transports have finished gathering candidates and the value of the {{domxref("RTCPeerConnection")}} object's {{domxref("RTCPeerConnection.iceGatheringState", "iceGatheringState")}} has made the transition to `complete`, an `icecandidate` event is sent with the value of `candidate` set to `null`.

This signal exists for backward compatibility purposes and does _not_ need to be delivered onward to the remote peer (which is why the code snippet above checks to see if `event.candidate` is `null` prior to sending the candidate along).

If you need to perform any special actions when there are no further candidates expected, you're much better off watching the ICE gathering state by watching for {{domxref("RTCPeerConnection.icegatheringstatechange_event", "icegatheringstatechange")}} events:

```js
pc.addEventListener("icegatheringstatechange", (ev) => {
  switch (pc.iceGatheringState) {
    case "new":
      /* gathering is either just starting or has been reset */
      break;
    case "gathering":
      /* gathering has begun or is ongoing */
      break;
    case "complete":
      /* gathering has ended */
      break;
  }
});
```

As you can see in this example, the `icegatheringstatechange` event lets you know when the value of the {{domxref("RTCPeerConnection")}} property {{domxref("RTCPeerConnection.iceGatheringState", "iceGatheringState")}} has been updated. If that value is now `complete`, you know that ICE gathering has just ended.

This is a more reliable approach than looking at the individual ICE messages for one indicating that the ICE session is finished.

## Examples

This example creates a simple handler for the `icecandidate` event that uses a function called `sendMessage()` to create and send a reply to the remote peer through the signaling server.

First, an example using {{domxref("EventTarget.addEventListener", "addEventListener()")}}:

```js
pc.addEventListener("icecandidate", (ev) => {
  if (ev.candidate !== null) {
    sendMessage({
      type: "new-ice-candidate",
      candidate: ev.candidate,
    });
  }
});
```

You can also set the `onicecandidate` event handler property directly:

```js
pc.onicecandidate = (ev) => {
  if (ev.candidate !== null) {
    sendMessage({
      type: "new-ice-candidate",
      candidate: ev.candidate,
    });
  }
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- [Signaling and video calling](/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling)
# RTCPeerConnection: icecandidateerror event

{{APIRef("WebRTC")}}

The [WebRTC API](/en-US/docs/Web/API/WebRTC_API) event **`icecandidateerror`** is sent to an {{domxref("RTCPeerConnection")}} if an error occurs while performing ICE negotiations through a {{Glossary("STUN")}} or {{Glossary("TURN")}} server. The event object is of type {{domxref("RTCPeerConnectionIceErrorEvent")}}, and contains information describing the error in some amount of detail.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("icecandidateerror", (event) => { })

onicecandidateerror = (event) => { }
```

## Event type

An {{domxref("RTCPeerConnectionIceErrorEvent")}}. Inherits from {{domxref("Event")}}.

{{InheritanceDiagram("RTCPeerConnectionIceErrorEvent")}}

## Event properties

_The `RTCPeerConnectionIceErrorEvent` interface includes the properties found on the {{domxref("Event")}} interface, as well as the following properties:_

- {{domxref("RTCPeerConnectionIceErrorEvent.address", "address")}} {{ReadOnlyInline}}
  - : A string providing the local IP address used to communicate with the {{Glossary("STUN")}} or {{Glossary("TURN")}} server being used to negotiate the connection, or `null` if the local IP address has not yet been exposed as part of a local ICE candidate.
- {{domxref("RTCPeerConnectionIceErrorEvent.errorCode", "errorCode")}} {{ReadOnlyInline}}
  - : An unsigned integer value stating the numeric [STUN error code](https://www.iana.org/assignments/stun-parameters/stun-parameters.xhtml#stun-parameters-6) returned by the STUN or TURN server. If no host candidate can reach the server, this property is set to the number 701, which is outside the range of valid STUN error codes. The 701 error is fired only once per server URL, and only while the {{domxref("RTCPeerConnection.iceGatheringState", "iceGatheringState")}} is `gathering`.
- {{domxref("RTCPeerConnectionIceErrorEvent.errorText", "errorText")}} {{ReadOnlyInline}}
  - : A string containing the STUN reason text returned by the STUN or TURN server. If communication with the STUN or TURN server couldn't be established at all, this string will be a browser-specific string explaining the error.
- {{domxref("RTCPeerConnectionIceErrorEvent.port", "port")}} {{ReadOnlyInline}}
  - : An unsigned integer value giving the port number over which communication with the STUN or TURN server is taking place, using the IP address given in `address`. `null` if the connection hasn't been established (that is, if `address` is `null`).
- {{domxref("RTCPeerConnectionIceErrorEvent.url", "url")}} {{ReadOnlyInline}}
  - : A string indicating the URL of the STUN or TURN server with which the error occurred.

## Description

The error object's {{domxref("RTCPeerConnectionIceErrorEvent.errorCode", "errorCode")}} property is one of the numeric STUN error codes. There is one additional, WebRTC-specific, error which lies outside the valid STUN error code range: 701. Error 701 indicates that none of the ICE candidates were able to successfully make contact with the STUN or TURN server.

The 701 error is fired only once per server URL from the list of available STUN or TURN servers provided when creating the {{domxref("RTCPeerConnection")}}. These errors occur only when the connection's [ICE gathering state](/en-US/docs/Web/API/RTCPeerConnection/iceGatheringState) is `gathering`.

## Example

The following example establishes a handler for `icecandidateerror`s that occur on the {{domxref("RTCPeerConnection")}} `pc`. This handler looks specifically for 701 errors that indicate that candidates couldn't reach the STUN or TURN server.

When this happens, the server URL and the error message are passed to a function called `reportConnectFail()` to log or output the connection failure.

```js
pc.addEventListener("icecandidateerror", (event) => {
  if (event.errorCode === 701) {
    reportConnectFail(event.url, event.errorText);
  }
});
```

Note that if multiple STUN and/or TURN servers are provided when creating the connection, this error may happen more than once, if more than one of those servers fails. Each provided server is tried until a connection is established.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCPeerConnection: iceConnectionState property

{{APIRef("WebRTC")}}

The **`iceConnectionState`** read-only property of the {{domxref("RTCPeerConnection")}} interface returns a string which state of the {{Glossary("ICE")}} agent associated with the {{domxref("RTCPeerConnection")}}: `new`, `checking`, `connected`, `completed`, `failed`, `disconnected`, and `closed`.

It describes the current state of the ICE agent and its connection to the ICE server;
that is, the {{Glossary("STUN")}} or {{Glossary("TURN")}} server.

You can detect when this value has changed by watching for the {{DOMxRef("RTCPeerConnection.iceconnectionstatechange_event", "iceconnectionstatechange")}} event.

## Value

The current state of the ICE agent and its connection. The value is one of the following strings:

- `new`
  - : The ICE agent is gathering addresses or is waiting to be given remote candidates through calls to {{domxref("RTCPeerConnection.addIceCandidate()")}} (or both).
- `checking`
  - : The ICE agent has been given one or more remote candidates and is checking pairs of local and remote candidates against one another
    to try to find a compatible match, but has not yet found a pair which will allow the peer connection to be made.
    It is possible that gathering of candidates is also still underway.
- `connected`
  - : A usable pairing of local and remote candidates has been found for all components of the connection, and the connection has been established.
    It is possible that gathering is still underway, and it is also possible that the ICE agent is still checking candidates against one another looking for a better connection to use.
- `completed`
  - : The ICE agent has finished gathering candidates, has checked all pairs against one another, and has found a connection for all components.
- `failed`
  - : The ICE candidate has checked all candidates pairs against one another and has failed to find compatible matches for all components of the connection.
    It is, however, possible that the ICE agent did find compatible connections for some components.
- `disconnected`
  - : Checks to ensure that components are still connected failed for at least one component of the {{domxref("RTCPeerConnection")}}.
    This is a less stringent test than `failed` and may trigger intermittently and resolve just as spontaneously on less reliable networks, or during temporary disconnections.
    When the problem resolves, the connection may return to the `connected` state.
- `closed`
  - : The ICE agent for this {{domxref("RTCPeerConnection")}} has shut down and is no longer handling requests.

## Examples

```js
const pc = new RTCPeerConnection();
const state = pc.iceConnectionState;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- {{DOMxRef("RTCPeerConnection.iceconnectionstatechange_event", "iceconnectionstatechange")}}
- {{domxref("RTCPeerConnection")}}
# RTCPeerConnection: iceconnectionstatechange event

{{APIRef("WebRTC")}}

An **`iceconnectionstatechange`** event is sent to an {{domxref("RTCPeerConnection")}} object each time the {{Glossary("ICE")}} connection state changes during the negotiation process.
The new ICE connection state is available in the object's {{domxref("RTCPeerConnection.iceConnectionState", "iceConnectionState")}} property.

One common task performed by the `iceconnectionstatechange` event listener is to trigger [ICE restart](/en-US/docs/Web/API/WebRTC_API/Session_lifetime#ice_restart) when the state changes to `failed`.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("iceconnectionstatechange", (event) => { })

oniceconnectionstatechange = (event) => { }
```

## Event type

A generic {{domxref("Event")}}.

## Usage notes

A successful connection attempt will typically involve the state starting at `new`, then transitioning through `checking`, then `connected`, and finally `completed`. However, under certain circumstances, the `connected` state can be skipped, causing a connection to transition directly from the `checking` state to `completed`. This can happen when only the last checked candidate is successful, and the gathering and end-of-candidates signals both occur before the successful negotiation is completed.

### ICE connection state during ICE restarts

When an ICE restart is processed, the gathering and connectivity checking process is started over from the beginning, which will cause the `iceConnectionState` to transition to `connected` if the ICE restart was triggered while in the `completed` state. If ICE restart is initiated while in the transient `disconnected` state, the state transitions instead to `checking`, essentially indicating that the negotiation is ignoring the fact that the connection had been temporarily lost.

### State transitions as negotiation ends

When the negotiation process runs out of candidates to check, the ICE connection transitions to one of two states. If no suitable candidates were found, the state transitions to `failed`. If at least one suitable candidate was successfully identified, the state transitions to `completed`. The ICE layer makes this determination upon receiving the end-of-candidates signal, which is provided by calling {{domxref("RTCPeerConnection.addIceCandidate", "addIceCandidate()")}} with a candidate whose {{domxref("RTCIceCandidate.candidate", "candidate")}} property is an empty string (""), or by setting the {{domxref("RTCPeerConnection")}} property {{domxref("RTCPeerConnection.canTrickleIceCandidates", "canTrickleIceCandidates")}} to `false`.

## Examples

An event handler for this event can be added using the `oniceconnectionstatechange` property or by using {{domxref("EventTarget.addEventListener", "addEventListener()")}} on the `RTCPeerConnection`.

In this example, a handler for `iceconnectionstatechange` is set up to update a call state indicator by using the value of {{domxref("RTCPeerConnection.iceConnectionState", "iceConnectionState")}} to create a string which corresponds to the name of a CSS class that we can assign to the status indicator to cause it to reflect the current state of the connection.

```js
pc.addEventListener("iceconnectionstatechange", (ev) => {
  let stateElem = document.querySelector("#call-state");
  stateElem.className = `${pc.iceConnectionState}-state`;
});
```

This can also be written as:

```js
pc.oniceconnectionstatechange = (ev) => {
  let stateElem = document.querySelector("#call-state");
  stateElem.className = `${pc.iceConnectionState}-state`;
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCPeerConnection")}}
- {{domxref("RTCPeerConnection.iceConnectionState")}}
# RTCPeerConnection: iceGatheringState property

{{APIRef("WebRTC")}}

The **`iceGatheringState`** read-only property of the {{domxref("RTCPeerConnection")}} interface returns a string that describes the overall ICE gathering state for this connection.
This lets you detect, for example, when collection of ICE candidates has finished.

You can detect when the value of this property changes by watching for an event of type {{domxref("RTCPeerConnection/icegatheringstatechange_event", "icegatheringstatechange")}}.

Note that **`iceGatheringState`** represents the overall gathering state of the connection, including every {{domxref("RTCIceTransport")}} used by every {{domxref("RTCRtpSender")}} and every {{domxref("RTCRtpReceiver")}} on the entire connection.
This contrasts with {{domxref("RTCIceTransport.gatheringState")}}, which represents the gathering state for a single transport.

## Value

The possible values are:

- `new`
  - : The peer connection was just created and hasn't done any networking yet.
- `gathering`
  - : The ICE agent is in the process of gathering candidates for the connection.
- `complete`
  - : The ICE agent has finished gathering candidates.
    If something happens that requires collecting new candidates, such as a new interface being added or the addition of a new ICE server, the state will revert to `gathering` to gather those candidates.

## Example

```js
const pc = new RTCPeerConnection();
const state = pc.iceGatheringState;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{DOMxRef("RTCPeerConnection/icegatheringstatechange_event", "icegatheringstatechange")}}
- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
# RTCPeerConnection: icegatheringstatechange event

{{APIRef("WebRTC")}}

The **`icegatheringstatechange`** event is sent to the `onicegatheringstatechange` event handler on an {{domxref("RTCPeerConnection")}} when the state of the {{Glossary("ICE")}} candidate gathering process changes.
This signifies that the value of the connection's {{domxref("RTCPeerConnection.iceGatheringState", "iceGatheringState")}} property has changed.

When ICE first starts to gather connection candidates, the value changes from `new` to `gathering` to indicate that the process of collecting candidate configurations for the connection has begun. When the value changes to `complete`, all of the transports that make up the `RTCPeerConnection` have finished gathering ICE candidates.

> [!NOTE]
> While you can determine that ICE candidate gathering is complete by watching for `icegatheringstatechange` events and checking for the value of {{domxref("RTCPeerConnection.iceGatheringState", "iceGatheringState")}} to become `complete`, you can also have your handler for the {{domxref("RTCPeerConnection.icecandidate_event", "icecandidate")}} event look to see if its {{domxref("RTCPeerConnectionIceEvent.candidate", "candidate")}} property is `null`. This also indicates that collection of candidates is finished.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("icegatheringstatechange", (event) => { })

onicegatheringstatechange = (event) => { }
```

## Event type

A generic {{domxref("Event")}}.

## Examples

This example creates a handler for `icegatheringstatechange` events.

```js
pc.onicegatheringstatechange = (ev) => {
  let connection = ev.target;

  switch (connection.iceGatheringState) {
    case "gathering":
      /* collection of candidates has begun */
      break;
    case "complete":
      /* collection of candidates is finished */
      break;
  }
};
```

Likewise, you can use {{domxref("EventTarget.addEventListener", "addEventListener()")}} to add a listener for `icegatheringstatechange` events:

```js
pc.addEventListener("icegatheringstatechange", (ev) => {
  let connection = ev.target;

  switch (connection.iceGatheringState) {
    case "gathering":
      // collection of candidates has begun
      break;
    case "complete":
      // collection of candidates is finished
      break;
  }
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- [Signaling and video calling](/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling)
- [WebRTC connectivity](/en-US/docs/Web/API/WebRTC_API/Connectivity)
- [Lifetime of a WebRTC session](/en-US/docs/Web/API/WebRTC_API/Session_lifetime)
# RTCPeerConnection

{{APIRef("WebRTC")}}

The **`RTCPeerConnection`** interface represents a WebRTC connection between the local computer and a remote peer.
It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed.

{{InheritanceDiagram}}

## Constructor

- {{DOMxRef("RTCPeerConnection.RTCPeerConnection", "RTCPeerConnection()")}}
  - : Returns a new `RTCPeerConnection`, representing a connection between the local device and a remote peer.

## Instance properties

_Also inherits properties from {{DOMxRef("EventTarget")}}._

- {{DOMxRef("RTCPeerConnection.canTrickleIceCandidates", "canTrickleIceCandidates")}} {{ReadOnlyInline}}
  - : Returns a boolean value which indicates whether or not the remote peer can accept [trickled ICE candidates](https://datatracker.ietf.org/doc/html/draft-ietf-mmusic-trickle-ice).
- {{DOMxRef("RTCPeerConnection.connectionState", "connectionState")}} {{ReadOnlyInline}}
  - : Indicates the current state of the peer connection by returning one of the strings: `new`, `connecting`, `connected`, `disconnected`, `failed`, or `closed`.
- {{DOMxRef("RTCPeerConnection.currentLocalDescription", "currentLocalDescription")}} {{ReadOnlyInline}}
  - : Returns an {{DOMxRef("RTCSessionDescription")}} object describing the local end of the connection as it was most recently successfully negotiated since the last time this `RTCPeerConnection` finished negotiating and connecting to a remote peer.
    Also included is a list of any ICE candidates that may already have been generated by the ICE agent since the offer or answer represented by the description was first instantiated.
- {{DOMxRef("RTCPeerConnection.currentRemoteDescription", "currentRemoteDescription")}} {{ReadOnlyInline}}
  - : Returns an {{DOMxRef("RTCSessionDescription")}} object describing the remote end of the connection as it was most recently successfully negotiated since the last time this `RTCPeerConnection` finished negotiating and connecting to a remote peer.
    Also included is a list of any ICE candidates that may already have been generated by the ICE agent since the offer or answer represented by the description was first instantiated.
- {{DOMxRef("RTCPeerConnection.iceConnectionState", "iceConnectionState")}} {{ReadOnlyInline}}
  - : Returns a string which state of the ICE agent associated with this RTCPeerConnection.
    It can be one of the following values: `new`, `checking`, `connected`, `completed`, `failed`, `disconnected`, or `closed`.
- {{DOMxRef("RTCPeerConnection.iceGatheringState", "iceGatheringState")}} {{ReadOnlyInline}}
  - : Returns a string that describes connection's ICE gathering state.
    This lets you detect, for example, when collection of ICE candidates has finished.
    Possible values are: `new`, `gathering`, or `complete`.
- {{DOMxRef("RTCPeerConnection.localDescription", "localDescription")}} {{ReadOnlyInline}}
  - : Returns an {{DOMxRef("RTCSessionDescription")}}
    describing the session for the local end of the connection.
    If it has not yet been set, returns `null`.
- {{DOMxRef("RTCPeerConnection.peerIdentity", "peerIdentity")}} {{ReadOnlyInline}}
  - : Returns a {{jsxref("Promise")}} that resolves to an {{DOMxRef("RTCIdentityAssertion")}} which contains a string identifying the remote peer.
    Once this promise resolves successfully, the resulting identity is the target peer identity and will not change for the duration of the connection.
- {{DOMxRef("RTCPeerConnection.pendingLocalDescription", "pendingLocalDescription")}} {{ReadOnlyInline}}
  - : Returns an {{DOMxRef("RTCSessionDescription")}} object describing a pending configuration change for the local end of the connection.
    This does not describe the connection as it currently stands, but as it may exist in the near future.
- {{DOMxRef("RTCPeerConnection.pendingRemoteDescription", "pendingRemoteDescription")}} {{ReadOnlyInline}}
  - : Returns an {{DOMxRef("RTCSessionDescription")}} object
    describing a pending configuration change for the remote end of the connection.
    This does not describe the connection as it currently stands, but as it may exist in the near future.
- {{DOMxRef("RTCPeerConnection.remoteDescription", "remoteDescription")}} {{ReadOnlyInline}}
  - : Returns an {{DOMxRef("RTCSessionDescription")}} object describing the session, including configuration and media information, for the remote end of the connection.
    If this hasn't been set yet, this returns `null`.
- {{DOMxRef("RTCPeerConnection.sctp", "sctp")}} {{ReadOnlyInline}}
  - : Returns an {{DOMxRef("RTCSctpTransport")}} object describing the {{Glossary("SCTP")}} transport layer over which SCTP data is being sent and received.
    If SCTP hasn't been negotiated, this value is `null`.
- {{DOMxRef("RTCPeerConnection.signalingState", "signalingState")}} {{ReadOnlyInline}}
  - : Returns a string describing the state of the signaling process on the local end of the connection while connecting or reconnecting to another peer.
    It is one of the following values: `stable`, `have-local-offer`, `have-remote-offer`, `have-local-pranswer`, `have-remote-pranswer`, or `closed`.

## Static methods

- {{DOMxRef("RTCPeerConnection.generateCertificate_static", "RTCPeerConnection.generateCertificate()")}}
  - : Creates an X.509 certificate and its corresponding private key, returning a {{jsxref("Promise")}} that resolves with the new {{DOMxRef("RTCCertificate")}} once it is generated.

## Instance methods

_Also inherits methods from {{DOMxRef("EventTarget")}}._

- {{DOMxRef("RTCPeerConnection.addIceCandidate", "addIceCandidate()")}}
  - : Adds a new remote candidate to the `RTCPeerConnection`'s remote description, which describes the state of the remote end of the connection.
- {{DOMxRef("RTCPeerConnection.addTrack", "addTrack()")}}
  - : Adds a new {{DOMxRef("MediaStreamTrack")}} to the set of tracks which will be transmitted to the other peer.
- {{DOMxRef("RTCPeerConnection.addTransceiver", "addTransceiver()")}}
  - : Creates a new {{DOMxRef("RTCRtpTransceiver")}} and adds it to the set of transceivers associated with the connection.
    Each transceiver represents a bidirectional stream, with both an {{DOMxRef("RTCRtpSender")}} and an {{DOMxRef("RTCRtpReceiver")}} associated with it.
- {{DOMxRef("RTCPeerConnection.close", "close()")}}
  - : Closes the current peer connection.
- {{DOMxRef("RTCPeerConnection.createAnswer", "createAnswer()")}}
  - : Initiates the creation of an {{Glossary("SDP")}} answer to an offer received from a remote peer during the offer/answer negotiation of a WebRTC connection.
    The answer contains information about any media already attached to the session, codecs and options supported by the browser, and any {{Glossary("ICE")}} candidates already gathered.
- {{DOMxRef("RTCPeerConnection.createDataChannel", "createDataChannel()")}}
  - : Initiates the creation a new channel linked with the remote peer, over which any kind of data may be transmitted.
    This can be useful for back-channel content, such as images, file transfer, text chat, game update packets, and so forth.
- {{DOMxRef("RTCPeerConnection.createOffer", "createOffer()")}}
  - : Initiates the creation of an {{Glossary("SDP")}} offer for the purpose of starting a new WebRTC connection to a remote peer.
    The SDP offer includes information about any {{DOMxRef("MediaStreamTrack")}} objects already attached to the WebRTC session, codec, and options supported by the browser, as well as any candidates already gathered by the {{Glossary("ICE")}} agent, for the purpose of being sent over the signaling channel to a potential peer to request a connection or to update the configuration of an existing connection.
- {{DOMxRef("RTCPeerConnection.getConfiguration", "getConfiguration()")}}
  - : Returns an object which indicates the current configuration of the connection.
- {{DOMxRef("RTCPeerConnection.getIdentityAssertion", "getIdentityAssertion()")}}
  - : Initiates the gathering of an identity assertion and returns a {{jsxref("Promise")}} which resolves to an identity assertion encoded as a string.
    This has an effect only if {{DOMxRef("RTCPeerConnection.signalingState", "signalingState")}} is not `closed`.
- {{DOMxRef("RTCPeerConnection.getReceivers", "getReceivers()")}}
  - : Returns an array of {{DOMxRef("RTCRtpReceiver")}} objects, each of which represents one {{Glossary("RTP")}} receiver.
- {{DOMxRef("RTCPeerConnection.getSenders", "getSenders()")}}
  - : Returns an array of {{DOMxRef("RTCRtpSender")}} objects, each of which represents the {{Glossary("RTP")}} sender responsible for transmitting one track's data.
- {{DOMxRef("RTCPeerConnection.getStats", "getStats()")}}
  - : Returns a {{jsxref("Promise")}} which resolves with data providing statistics about either the overall connection or about the specified {{DOMxRef("MediaStreamTrack")}}.
- {{DOMxRef("RTCPeerConnection.getTransceivers", "getTransceivers()")}}
  - : Returns a list of all the {{DOMxRef("RTCRtpTransceiver")}} objects being used to send and receive data on the connection.
- {{DOMxRef("RTCPeerConnection.removeTrack", "removeTrack()")}}
  - : Tells the local end of the connection to stop sending media from the specified track, without actually removing the corresponding {{DOMxRef("RTCRtpSender")}} from the list of senders
    as reported by {{DOMxRef("RTCPeerConnection.getSenders", "getSenders()")}}.
    If the track is already stopped, or is not in the connection's senders list, this method has no effect.
- {{DOMxRef("RTCPeerConnection.restartIce", "restartIce()")}}
  - : Allows to easily request that ICE candidate gathering be redone on both ends of the connection.
    This simplifies the process by allowing the same method to be used by either the caller or the receiver to trigger an {{Glossary("ICE")}} restart.
- {{DOMxRef("RTCPeerConnection.setConfiguration", "setConfiguration()")}}
  - : Sets the current configuration of the connection based on the values included in the specified object.
    This lets you change the {{Glossary("ICE")}} servers used by the connection and which transport policies to use.
- {{DOMxRef("RTCPeerConnection.setIdentityProvider", "setIdentityProvider()")}}
  - : Sets the Identity Provider (IdP) to the triplet given in parameter: its name, the protocol used to communicate with it and an username.
    The protocol and the username are optional.
- {{DOMxRef("RTCPeerConnection.setLocalDescription", "setLocalDescription()")}}
  - : Changes the local description associated with the connection.
    This description specifies the properties of the local end of the connection, including the media format.
    It returns a {{jsxref("Promise")}} which is fulfilled once the description has been changed, asynchronously.
- {{DOMxRef("RTCPeerConnection.setRemoteDescription", "setRemoteDescription()")}}
  - : Sets the specified session description as the remote peer's current offer or answer.
    The description specifies the properties of the remote end of the connection, including the media format.
    It returns a {{jsxref("Promise")}} which is fulfilled once the description has been changed, asynchronously.

### Obsolete methods

- {{DOMxRef("RTCPeerConnection.addStream", "addStream()")}} {{Deprecated_Inline}} {{Non-standard_Inline}}
  - : Adds a {{DOMxRef("MediaStream")}} as a local source of audio or video.
    Instead of using this obsolete method, you should instead use {{DOMxRef("RTCPeerConnection.addTrack", "addTrack()")}} once for each track you wish to send to the remote peer.
- {{DOMxRef("RTCPeerConnection.createDTMFSender", "createDTMFSender()")}} {{Deprecated_Inline}} {{non-standard_inline}}
  - : Creates a new {{DOMxRef("RTCDTMFSender")}}, associated to a specific {{DOMxRef("MediaStreamTrack")}}, that will be able to send {{Glossary("DTMF")}} phone signaling over the connection.
- {{DOMxRef("RTCPeerConnection.removeStream", "removeStream()")}} {{Deprecated_Inline}} {{Non-standard_Inline}}
  - : Removes a {{DOMxRef("MediaStream")}} as a local source of audio or video.
    Because this method is obsolete, you should instead use {{DOMxRef("RTCPeerConnection.removeTrack", "removeTrack()")}}.

## Events

Listen to these events using {{domxref("EventTarget.addEventListener", "addEventListener()")}} or by assigning an event listener to the `oneventname` property of this interface.

- {{domxref("RTCPeerConnection.connectionstatechange_event", "connectionstatechange")}}
  - : Sent when the overall connectivity status of the `RTCPeerConnection` changes.
- {{domxref("RTCPeerConnection.datachannel_event", "datachannel")}}
  - : Sent when the remote peer adds an {{domxref("RTCDataChannel")}} to the connection.
- {{domxref("RTCPeerConnection.icecandidate_event", "icecandidate")}}
  - : Sent to request that the specified candidate be transmitted to the remote peer.
- {{domxref("RTCPeerConnection.icecandidateerror_event", "icecandidateerror")}}
  - : Sent to the connection if an error occurred during {{Glossary("ICE")}} candidate gathering. The event describes the error.
- {{domxref("RTCPeerConnection.iceconnectionstatechange_event", "iceconnectionstatechange")}}
  - : Sent when the state of the {{Glossary("ICE")}} connection changes, such as when it disconnects.
- {{domxref("RTCPeerConnection.icegatheringstatechange_event", "icegatheringstatechange")}}
  - : Sent when the {{Glossary("ICE")}} layer's gathering state, reflected by {{domxref("RTCPeerConnection.iceGatheringState", "iceGatheringState")}}, changes.
    This indicates whether ICE negotiation has not yet begun (`new`), has begun gathering candidates (`gathering`), or has completed (`complete`).
- {{domxref("RTCPeerConnection.negotiationneeded_event", "negotiationneeded")}}
  - : Sent when negotiation or renegotiation of the {{Glossary("ICE")}} connection needs to be performed;
    this can happen both when first opening a connection as well as when it is necessary to adapt to changing network conditions.
    The receiver should respond by creating an offer and sending it to the other peer.
- {{domxref("RTCPeerConnection.signalingstatechange_event", "signalingstatechange")}}
  - : Sent when the connection's {{Glossary("ICE")}} signaling state changes.
- {{domxref("RTCPeerConnection.track_event", "track")}}
  - : Sent after a new track has been added to one of the {{domxref("RTCRtpReceiver")}} instances which comprise the connection.

### Obsolete events

- {{domxref("RTCPeerConnection.addstream_event", "addstream")}} {{Deprecated_Inline}} {{Non-standard_Inline}}
  - : Sent when a new {{domxref("MediaStream")}} has been added to the connection.
    Instead of listening for this obsolete event, you should listen for {{domxref("RTCPeerConnection.track_event", "track")}} events;
    one is sent for each {{domxref("MediaStreamTrack")}} added to the connection.
- {{domxref("RTCPeerConnection.removestream_event", "removestream")}} {{Deprecated_Inline}} {{Non-standard_Inline}}
  - : Sent when a {{domxref("MediaStream")}} is removed from the connection.
    Instead of listening for this obsolete event, you should listen for {{domxref("MediaStream.removetrack_event", "removetrack")}} events on each stream.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- <https://github.com/jesup/nightly-gupshup/blob/master/static/js/chat.js>
- [Get started with WebRTC](https://web.dev/articles/webrtc-basics)
- [TutorRoom](https://github.com/chrisjohndigital/TutorRoom): Node.js HTML video capture, peer-to-peer video and file sharing application ([source on GitHub](https://github.com/chrisjohndigital/TutorRoom))
# RTCPeerConnection: localDescription property

{{APIRef("WebRTC")}}

The **`localDescription`** read-only property of the {{domxref("RTCPeerConnection")}} interface returns an {{domxref("RTCSessionDescription")}} describing the session for the local end of the connection.
If it has not yet been set, this is `null`.

## Value

On a more fundamental level, the returned value is the value of {{domxref("RTCPeerConnection.pendingLocalDescription")}} if that property isn't `null`;
otherwise, the value of {{domxref("RTCPeerConnection.currentLocalDescription")}} is returned.
See [Pending and current descriptions](/en-US/docs/Web/API/WebRTC_API/Connectivity#pending_and_current_descriptions) in the WebRTC Connectivity page for details on this algorithm and why it's used.

## Example

This example looks at the `localDescription` and displays an alert containing the {{domxref("RTCSessionDescription")}} object's `type` and `sdp` fields.

```js
const pc = new RTCPeerConnection();
// …
const sd = pc.localDescription;
if (sd) {
  alert(`Local session: type='${sd.type}'; sdp description='${sd.sdp}'`);
} else {
  alert("No local session yet.");
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCPeerConnection.setLocalDescription()")}}, {{domxref("RTCPeerConnection.pendingLocalDescription")}}, {{domxref("RTCPeerConnection.currentLocalDescription")}}
- {{domxref("RTCPeerConnection.setRemoteDescription()")}}, {{domxref("RTCPeerConnection.remoteDescription")}}, {{domxref("RTCPeerConnection.pendingRemoteDescription")}}, {{domxref("RTCPeerConnection.currentRemoteDescription")}}
- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
# RTCPeerConnection: negotiationneeded event

{{APIRef("WebRTC")}}

A **`negotiationneeded`** event is sent to the {{domxref("RTCPeerConnection")}} when negotiation of the connection through the signaling channel is required.
This occurs both during the initial setup of the connection as well as any time a change to the communication environment requires reconfiguring the connection.

The `negotiationneeded` event is first dispatched to the {{domxref("RTCPeerConnection")}} when media is first added to the connection. This starts the process of {{Glossary("ICE")}} negotiation by instructing your code to begin exchanging ICE candidates through the signaling server. See [Signaling transaction flow](/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling#signaling_transaction_flow) for a description of the signaling process that begins with a `negotiationneeded` event.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("negotiationneeded", (event) => { })

onnegotiationneeded = (event) => { }
```

## Event type

A generic {{domxref("Event")}}.

## Examples

In this example, we use {{domxref("EventTarget.addEventListener", "addEventListener()")}} to create an event handler for `negotiationneeded`. Its role is to create an {{Glossary("SDP")}} offer and send it through the signaling channel to the remote peer.

```js
pc.addEventListener("negotiationneeded", (ev) => {
  pc.createOffer()
    .then((offer) => pc.setLocalDescription(offer))
    .then(() =>
      sendSignalingMessage({
        type: "video-offer",
        sdp: pc.localDescription,
      }),
    )
    .catch((err) => {
      // handle error
    });
});
```

After creating the offer, the local end is configured by calling {{domxref("RTCPeerConnection.setLocalDescription()")}}; then a signaling message is created and sent to the remote peer through the signaling server, to share that offer with the other peer. The other peer should recognize this message and follow up by creating its own {{domxref("RTCPeerConnection")}}, setting the remote description with {{domxref("RTCPeerConnection.setRemoteDescription", "setRemoteDescription()")}}, and then creating an answer to send back to the offering peer.

You can also set an event handler for the `negotiationneeded` event by assigning the event handler function to the `onnegotiationneeded` property:

```js
pc.onnegotiationneeded = (ev) => {
  pc.createOffer()
    .then((offer) => pc.setLocalDescription(offer))
    .then(() =>
      sendSignalingMessage({
        type: "video-offer",
        sdp: pc.localDescription,
      }),
    )
    .catch((err) => {
      // handle error
    });
};
```

For a more detailed example, see [Starting negotiation](/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling#starting_negotiation).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- [Signaling and video calling](/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling)
- [Lifetime of a WebRTC session](/en-US/docs/Web/API/WebRTC_API/Session_lifetime)
- [WebRTC connectivity](/en-US/docs/Web/API/WebRTC_API/Connectivity)
- [Introduction to WebRTC protocols](/en-US/docs/Web/API/WebRTC_API/Protocols)
# RTCPeerConnection: peerIdentity property

{{APIRef("WebRTC")}}

The **`peerIdentity`** read-only property of the {{domxref("RTCPeerConnection")}} interface returns a JavaScript {{jsxref("Promise")}} that resolves to an {{domxref("RTCIdentityAssertion")}} which contains a string identifying the remote peer.
Once this promise resolves successfully, the resulting identity is the **target peer identity** and cannot change for the duration of the connection.

## Value

A JavaScript {{jsxref("Promise")}} which resolves to an {{domxref("RTCIdentityAssertion")}} that describes the remote peer's identity.

If an error occurs while attempting to validate an incoming identity assertion (that is, the information describing a peer's identity), the promise is rejected.
If there isn't already a target peer identity, `peerIdentity` is set to a newly created promise and the process begins again, until the process succeeds or no further attempts to authenticate occur.

> [!NOTE]
> The promise returned by {{domxref("RTCPeerConnection.setRemoteDescription", "setRemoteDescription()")}} cannot resolve until any target peer identity that's been set is validated.
> If the identity hasn't been validated yet, the promise returned by `setRemoteDescription()` will be rejected.
> If there's no target peer identity, `setRemoteDescription()` doesn't need to wait for validation to occur before it resolves.

## Examples

In this example, a function, `getIdentityAssertion()`, is created which asynchronously waits for the peer's identity to be verified, then returns the identity to the caller.
If an error occurs and the promise is rejected, this logs the error to the console and returns `null` to the caller.

```js
let pc = new RTCPeerConnection();

// …

async function getIdentityAssertion(pc) {
  try {
    const identity = await pc.peerIdentity;
    return identity;
  } catch (err) {
    console.log("Error identifying remote peer: ", err);
    return null;
  }
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
# RTCPeerConnection: pendingLocalDescription property

{{APIRef("WebRTC")}}

The **`pendingLocalDescription`** read-only property of the {{domxref("RTCPeerConnection")}} interface returns an {{domxref("RTCSessionDescription")}} object describing a pending configuration change for the local end of the connection.

This does not describe the connection as it currently stands, but as it may exist in the near future.
Use {{domxref("RTCPeerConnection.currentLocalDescription")}} or {{domxref("RTCPeerConnection.localDescription")}} to get the current state of the endpoint.
For details on the difference, see [Pending and current descriptions](/en-US/docs/Web/API/WebRTC_API/Connectivity#pending_and_current_descriptions) in the WebRTC Connectivity page.

## Value

If a local description change is in progress, this is an {{domxref("RTCSessionDescription")}} describing the proposed configuration.
Otherwise, this returns `null`.

## Examples

This example looks at the `pendingLocalDescription` to determine whether or not there's a description change being processed.

```js
const pc = new RTCPeerConnection();
// …
const sd = pc.pendingLocalDescription;
if (sd) {
  // There's a description change underway!
} else {
  // No description change pending
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

> [!NOTE]
> The addition of `pendingLocalDescription` and {{domxref("RTCPeerConnection.currentLocalDescription", "currentLocalDescription")}} to the WebRTC spec is relatively recent.
> In browsers which don't support them, only {{domxref("RTCPeerConnection.localDescription", "localDescription")}} is available.

## See also

- {{domxref("RTCPeerConnection.setLocalDescription()")}}, {{domxref("RTCPeerConnection.currentLocalDescription")}}, {{domxref("RTCPeerConnection.localDescription")}}
- {{domxref("RTCPeerConnection.setRemoteDescription()")}}, {{domxref("RTCPeerConnection.remoteDescription")}}, {{domxref("RTCPeerConnection.pendingRemoteDescription")}}, {{domxref("RTCPeerConnection.currentRemoteDescription")}}
- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
# RTCPeerConnection: pendingRemoteDescription property

{{APIRef("WebRTC")}}

The **`pendingRemoteDescription`** read-only property of the {{domxref("RTCPeerConnection")}} interface returns an {{domxref("RTCSessionDescription")}} object describing a pending configuration change for the remote end of the connection.

This does not describe the connection as it currently stands, but as it may exist in the near future.
Use {{domxref("RTCPeerConnection.currentRemoteDescription")}} or {{domxref("RTCPeerConnection.remoteDescription")}} to get the current session
description for the remote endpoint.
For details on the difference, see [Pending and current descriptions](/en-US/docs/Web/API/WebRTC_API/Connectivity#pending_and_current_descriptions) in the WebRTC Connectivity page.

## Value

If a remote description change is in progress, this is an {{domxref("RTCSessionDescription")}} describing the proposed configuration.
Otherwise, this returns `null`.

## Examples

This example looks at the `pendingRemoteDescription` to determine whether or not there's a description change being processed.

```js
const pc = new RTCPeerConnection();
// …
const sd = pc.pendingRemoteDescription;
if (sd) {
  // There's a description change underway!
} else {
  // No description change pending
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

> [!NOTE]
> The addition of `pendingRemoteDescription` and {{domxref("RTCPeerConnection.currentRemoteDescription", "currentRemoteDescription")}} to the WebRTC spec is relatively recent.
> In browsers which don't support them, only {{domxref("RTCPeerConnection.remoteDescription", "remoteDescription")}} is available.

## See also

- {{domxref("RTCPeerConnection.setRemoteDescription()")}},
  {{domxref("RTCPeerConnection.currentRemoteDescription")}},
  {{domxref("RTCPeerConnection.remoteDescription")}}
- {{domxref("RTCPeerConnection.setLocalDescription()")}},
  {{domxref("RTCPeerConnection.localDescription")}},
  {{domxref("RTCPeerConnection.pendingLocalDescription")}},
  {{domxref("RTCPeerConnection.currentLocalDescription")}}
- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
# RTCPeerConnection: remoteDescription property

{{APIRef("WebRTC")}}

The **`remoteDescription`** read-only property of the {{domxref("RTCPeerConnection")}} interface returns a {{domxref("RTCSessionDescription")}} describing the session (which includes configuration and media information) for the remote end of the connection.
If this hasn't been set yet, this is `null`.

The returned value typically reflects a remote description which has been received over the signaling server (as either an offer or an answer) and then put into effect by your code calling {{domxref("RTCPeerConnection.setRemoteDescription()")}} in response.

## Value

On a more fundamental level, the returned value is the value of {{domxref("RTCPeerConnection.pendingRemoteDescription")}} if that property isn't
`null`;
otherwise, the value of {{domxref("RTCPeerConnection.currentRemoteDescription")}} is returned.
See [Pending and current descriptions](/en-US/docs/Web/API/WebRTC_API/Connectivity#pending_and_current_descriptions) in the WebRTC Connectivity page for details on this algorithm and why it's used.

## Example

This example looks at the `remoteDescription` and displays an alert containing the {{domxref("RTCSessionDescription")}} object's `type` and `sdp` fields.

```js
const pc = new RTCPeerConnection();
// …
const sd = pc.remoteDescription;
if (sd) {
  alert(`Remote session: type='${sd.type}'; sdp description='${sd.sdp}'`);
} else {
  alert("No remote session yet.");
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCPeerConnection.setRemoteDescription()")}}, {{domxref("RTCPeerConnection.pendingRemoteDescription")}}, {{domxref("RTCPeerConnection.currentRemoteDescription")}}
- {{domxref("RTCPeerConnection.setLocalDescription()")}}, {{domxref("RTCPeerConnection.pendingLocalDescription")}}, {{domxref("RTCPeerConnection.currentLocalDescription")}}, {{domxref("RTCPeerConnection.localDescription")}}
- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
# RTCPeerConnection: removestream event

{{APIRef("WebRTC")}}{{Deprecated_Header}}{{Non-standard_Header}}

The obsolete **`removestream`** event was sent to an {{domxref("RTCPeerConnection")}} to inform it that a {{domxref("MediaStream")}} had been removed from the connection.
You can use the `RTCPeerConnection` interface's `onremovestream` property to set a handler for this event.

This is the counterpart to the {{domxref("RTCPeerConnection.addstream_event", "addstream")}} event, which is also obsolete.

> [!WARNING]
> This event has been removed from the WebRTC specification in favor of the existing {{DOMxRef("MediaStream/removetrack_event", "removetrack")}} event on the remote {{domxref("MediaStream")}} and the corresponding event handler property of the remote {{domxref("MediaStream")}}. The {{domxref("RTCPeerConnection")}} API is now track-based, so having zero tracks in the remote stream is equivalent to the remote stream being removed, which caused a `removestream` event.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("removestream", (event) => { })

onremovestream = (event) => { }
```

## Event type

A {{domxref("MediaStreamEvent")}}. Inherits from {{domxref("Event")}}.

{{InheritanceDiagram("MediaStreamEvent")}}

## Event properties

_A {{domxref("MediaStreamEvent")}} being an {{domxref("Event")}}, this event also implements these properties_.

- {{domxref("MediaStreamEvent.stream")}} {{ReadOnlyInline}}
  - : Contains the {{domxref("MediaStream")}} containing the stream associated with the event.

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCPeerConnection.removeStream()")}}
- {{domxref("MediaStream.removetrack_event", "removetrack")}}
# RTCPeerConnection: removeStream() method

{{APIRef("WebRTC")}}{{Deprecated_Header}}{{Non-standard_Header}}

The **`removeStream()`** method of the {{domxref("RTCPeerConnection")}} interface removes a {{domxref("MediaStream")}} as a local source of audio or video.
If the negotiation already happened, a new one will be needed for the remote peer to be able to use it.
Because this method has been deprecated, you should instead use {{domxref("RTCPeerConnection.removeTrack", "removeTrack()")}} if your target browser versions have implemented it.

If the {{domxref("RTCPeerConnection.signalingState", "signalingState")}} is set to `"closed"`, an `InvalidStateError` is raised.
If the {{domxref("RTCPeerConnection.signalingState", "signalingState")}} is set to `"stable"`, the event {{DOMxRef("RTCPeerConnection/negotiationneeded_event", "negotiationneeded")}} is sent on the {{domxref("RTCPeerConnection")}}.

## Syntax

```js-nolint
removeStream(mediaStream)
```

### Parameters

- `mediaStream`
  - : A {{domxref("MediaStream")}} specifying the stream to remove from the connection.

### Return value

{{jsxref("undefined")}}.

## Example

```js
let pc;
let videoStream;
navigator.getUserMedia({ video: true }, (stream) => {
  pc = new RTCPeerConnection();
  videoStream = stream;
  pc.addStream(stream);
});
document.getElementById("closeButton").addEventListener("click", (event) => {
  pc.removeStream(videoStream);
  pc.close();
});
```

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCPeerConnection.removeTrack()")}}
- {{domxref("RTCPeerConnection.addTrack()")}}
- {{domxref("RTCPeerConnection.addStream()")}}
# RTCPeerConnection: removeTrack() method

{{APIRef("WebRTC")}}

The **`removeTrack()`** method of the {{domxref("RTCPeerConnection")}} interface tells the local end of the connection to stop sending media from the specified track, without actually removing the corresponding {{domxref("RTCRtpSender")}} from the list of senders as reported by {{domxref("RTCPeerConnection.getSenders()")}}.
If the track is already stopped, or is not in the connection's senders list, this method has no effect.

If the connection has already been negotiated ({{domxref("RTCPeerConnection.signalingState", "signalingState")}} is set to `"stable"`), it is marked as needing to be negotiated again; the remote peer won't experience the change until this negotiation occurs.
A {{DOMxRef("RTCPeerConnection/negotiationneeded_event", "negotiationneeded")}} event is sent to the {{domxref("RTCPeerConnection")}} to let the local end know this negotiation must occur.

## Syntax

```js-nolint
removeTrack(sender)
```

### Parameters

- `sender`
  - : A {{domxref("RTCRtpSender")}} specifying the sender to remove from the connection.

### Return value

`undefined`.

### Exceptions

- `InvalidStateError` {{domxref("DOMException")}}
  - : Thrown if the connection is not open.

## Example

This example adds a video track to a connection and sets up a listener on a close button which removes the track when the user clicks the button.

```js
let pc;
let sender;
navigator.getUserMedia({ video: true }, (stream) => {
  pc = new RTCPeerConnection();
  const [track] = stream.getVideoTracks();
  sender = pc.addTrack(track, stream);
});

document.getElementById("closeButton").addEventListener("click", (event) => {
  pc.removeTrack(sender);
  pc.close();
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
# RTCPeerConnection: restartIce() method

{{APIRef("WebRTC")}}

The **`restartIce()`** method of the {{domxref("RTCPeerConnection")}} interface allows a web application to request that {{Glossary("ICE")}} candidate gathering be redone on both ends of the connection.
This simplifies the process by allowing the same method to be used by either the caller or the receiver to trigger an ICE restart.

After `restartIce()` returns, the offer returned by the next call to {{domxref("RTCPeerConnection.createOffer", "createOffer()")}} is automatically configured to trigger ICE restart on both the local peer (once the local peer has been set) and on the remote peer, once the offer is sent across your signaling mechanism and the remote peer has set its description as well.

`restartIce()` causes the
{{domxref("RTCPeerConnection.negotiationneeded_event", "negotiationneeded")}} event to be fired on the `RTCPeerConnection` to inform the application that it should perform negotiation using its signaling channel.

If negotiation fails to complete—either due to rollback or because incoming offers are in the process of being negotiated—the {{domxref("RTCPeerConnection")}} will remember that you requested ICE restart.
The next time the connection's {{domxref("RTCPeerConnection.signalingState", "signalingState")}} changes to `stable`, the connection will fire the {{domxref("RTCPeerConnection.negotiationneeded_event", "negotiationneeded")}} event.
This process continues until an ICE restart has been successfully completed.

## Syntax

```js-nolint
restartIce()
```

### Parameters

None.

### Return value

None ({{jsxref("undefined")}}).

## Usage notes

After calling `restartIce()`, the next offer created using {{domxref("RTCPeerConnection.createOffer", "createOffer()")}} will initiate ICE restart once sent to the remote peer over your signaling mechanism.
Restarting ICE essentially resets ICE so that it creates all new candidates using new credentials.
Existing media transmissions continue uninterrupted during this process.

For details about how ICE restart works, see [ICE restart](/en-US/docs/Web/API/WebRTC_API/Session_lifetime#ice_restart) and {{RFC(5245, "ICE specification", "9.1.1.1")}}.

## Examples

This example creates a handler for the {{domxref("RTCPeerConnection.iceconnectionstatechange_event", "iceconnectionstatechange")}} event that handles a transition to the `failed` state by restarting ICE in order to try again.

```js
pc.addEventListener("iceconnectionstatechange", (event) => {
  if (pc.iceConnectionState === "failed") {
    /* possibly reconfigure the connection in some way here */
    /* then request ICE restart */
    pc.restartIce();
  }
});
```

With this code in place, a transition to the `failed` state during ICE negotiation will cause a {{domxref("RTCPeerConnection.negotiationneeded_event", "negotiationneeded")}} event to be fired, in response to which your code should renegotiate as usual.
However, because you have called `restartIce()`, your call to {{domxref("RTCPeerConnection.createOffer", "createOffer()")}} which occurs in the handler for `negotiationneeded` will trigger an ICE restart rather than just a regular renegotiation.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- [Lifetime of a WebRTC session](/en-US/docs/Web/API/WebRTC_API/Session_lifetime)
- [Signaling and video calling](/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling)
# RTCPeerConnection: RTCPeerConnection() constructor

{{APIRef("WebRTC")}}

The **`RTCPeerConnection()`** constructor returns a newly-created {{domxref("RTCPeerConnection")}}, which represents a connection between the local device and a remote peer.

## Syntax

```js-nolint
new RTCPeerConnection()
new RTCPeerConnection(configuration)
```

### Parameters

- `configuration` {{optional_inline}}
  - : An object providing options to configure the new connection:
    - `bundlePolicy` {{optional_inline}}
      - : Specifies how to handle negotiation of candidates when the remote peer is not compatible with the [SDP BUNDLE standard](https://datatracker.ietf.org/doc/rfc8843/). If the remote endpoint is BUNDLE-aware, all media tracks and data channels are bundled onto a single transport at the completion of negotiation, regardless of policy used, and any superfluous transports that were created initially are closed at that point.

        In technical terms, a BUNDLE lets all media flow between two peers flow across a single **5-tuple**; that is, from a single IP and port on one peer to a single IP and port on the other peer, using the same transport protocol.

        This must be one of the following string values, if not `balanced` is assumed:
        - `"balanced"`
          - : The ICE agent initially creates one {{domxref("RTCDtlsTransport")}} for each type of content added: audio, video, and data channels. If the remote endpoint is not BUNDLE-aware, then each of these DTLS transports handles all the communication for one type of data.
        - `"max-compat"`
          - : The ICE agent initially creates one {{domxref("RTCDtlsTransport")}} per media track and a separate one for data channels. If the remote endpoint is not BUNDLE-aware, everything is negotiated on these separate DTLS transports.
        - `"max-bundle"`
          - : The ICE agent initially creates only a single {{domxref("RTCDtlsTransport")}} to carry all of the {{DOMxRef("RTCPeerConnection")}}'s data. If the remote endpoint is not BUNDLE-aware, then only a single track will be negotiated and the rest ignored.

    - `certificates` {{optional_inline}}
      - : An {{jsxref("Array")}} of objects of type {{domxref("RTCCertificate")}} which are used by the connection for authentication. If this property isn't specified, a set of certificates is generated automatically for each {{domxref("RTCPeerConnection")}} instance. Although only one certificate is used by a given connection, providing certificates for multiple algorithms may improve the odds of successfully connecting in some circumstances. See [Using certificates](#using_certificates) for further information.

        > [!NOTE]
        > This configuration option cannot be changed after it is first specified; once the certificates have been set, this property is ignored in future calls to {{domxref("RTCPeerConnection.setConfiguration()")}}.

    - `iceCandidatePoolSize` {{optional_inline}}
      - : An unsigned 16-bit integer value which specifies the size of the prefetched ICE candidate pool. The default value is 0 (meaning no candidate prefetching will occur). You may find in some cases that connections can be established more quickly by allowing the ICE agent to start fetching ICE candidates before you start trying to connect, so that they're already available for inspection when {{domxref("RTCPeerConnection.setLocalDescription()")}} is called.

        > [!NOTE]
        > Changing the size of the ICE candidate pool may trigger the beginning of ICE gathering.

    - `iceServers` {{optional_inline}}
      - : An array of objects, each describing one server which may be used by the ICE agent; these are typically STUN and/or TURN servers. If this isn't specified, the connection attempt will be made with no STUN or TURN server available, which limits the connection to local peers. Each object may have the following properties:
        - `credential` {{optional_inline}}
          - : The credential to use when logging into the server. This is only used if the object represents a TURN server.
        - `credentialType` {{optional_inline}} {{Deprecated_Inline}} {{Non-standard_Inline}}
          - : If the object represents a TURN server, this attribute specifies what kind of `credential` is to be used when connecting. The default is `"password"`.
        - `urls`
          - : This **required** property is either a single string or an array of strings, each specifying a URL which can be used to connect to the server.
        - `username` {{optional_inline}}
          - : If the object represents a TURN server, then this is the username to use during the authentication.

    - `iceTransportPolicy` {{optional_inline}}
      - : A string representing the current ICE transport policy. Possible values are:
        - `"all"`
          - : All ICE candidates will be considered. This is the default value.
        - `"public"` {{deprecated_inline}}
          - : Only ICE candidates with public IP addresses will be considered.
        - `"relay"`
          - : Only ICE candidates whose IP addresses are being relayed, such as those being passed through a TURN server, will be considered.

    - `peerIdentity` {{optional_inline}}
      - : A string which specifies the target peer identity for the {{domxref("RTCPeerConnection")}}. If this value is set (it defaults to `null`), the `RTCPeerConnection` will not connect to a remote peer unless it can successfully authenticate with the given name.
    - `rtcpMuxPolicy` {{optional_inline}}
      - : A string which specifies the RTCP mux policy to use when gathering ICE candidates, in order to support non-multiplexed RTCP. Possible values are:
        - `"negotiate"`
          - : Instructs the ICE agent to gather both {{Glossary("RTP")}} and {{Glossary("RTCP")}} candidates. If the remote peer can multiplex RTCP, then RTCP candidates are multiplexed atop the corresponding RTP candidates. Otherwise, both the RTP and RTCP candidates are returned, separately.
        - `"require"`
          - : Tells the ICE agent to gather ICE candidates for only RTP, and to multiplex RTCP atop them. If the remote peer doesn't support RTCP multiplexing, then session negotiation fails. This is the default value.

### Return value

A newly-created {{domxref("RTCPeerConnection")}} object, configured as described by `configuration`, if specified; otherwise, configured to appropriate basic defaults.

## Using certificates

When you wish to provide your own certificates for use by an {{domxref("RTCPeerConnection")}} instead of having the `RTCPeerConnection` generate them automatically, you do so by calling the static {{domxref("RTCPeerConnection.generateCertificate_static", "RTCPeerConnection.generateCertificate()")}} function.

The `certificates` property's value cannot be changed once it's first specified. If it's included in the configuration passed into a call to a connection's {{domxref("RTCPeerConnection.setConfiguration", "setConfiguration()")}}, it is ignored.

This attribute supports providing multiple certificates because even though a given DTLS connection uses only one certificate, providing multiple certificates allows support for multiple encryption algorithms. The implementation of `RTCPeerConnection` will choose which certificate to use based on the algorithms it and the remote peer support, as determined during DTLS handshake.

If you don't provide certificates, new ones are generated automatically. One obvious benefit to providing your own is identity key continuity—if you use the same certificate for subsequent calls, the remote peer can tell you're the same caller. This also avoids the cost of generating new keys.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Signaling and video calling](/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling)
- [WebRTC architecture overview](/en-US/docs/Web/API/WebRTC_API/Protocols)
- [Lifetime of a WebRTC session](/en-US/docs/Web/API/WebRTC_API/Session_lifetime)
- {{domxref("RTCPeerConnection")}}
# RTCPeerConnection: sctp property

{{APIRef("WebRTC")}}

The **`sctp`** read-only property of the {{domxref("RTCPeerConnection")}} interface returns an {{domxref("RTCSctpTransport")}} describing the {{Glossary("SCTP")}} transport over which SCTP data is being sent and received.
If SCTP hasn't been negotiated, this value is `null`.

The SCTP transport is used for transmitting and receiving data for any and all {{domxref("RTCDataChannel")}}s on the peer connection.

## Value

A {{domxref("RTCSctpTransport")}} object describing the SCTP transport being used by the {{domxref("RTCPeerConnection")}} for transmitting and receiving on its data channels, or `null` if SCTP negotiation hasn't happened.

## Example

```js
const peerConnection = new RTCPeerConnection();

const channel = peerConnection.createDataChannel("Mydata");
channel.onopen = (event) => {
  channel.send("sending a message");
};
channel.onmessage = (event) => {
  console.log(event.data);
};

// Determine the largest message size that can be sent

const sctp = peerConnection.sctp;
const maxMessageSize = sctp.maxMessageSize;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCPeerConnection")}}
- {{domxref("RTCDataChannel")}}
- {{Glossary("SCTP")}}
# RTCPeerConnection: setConfiguration() method

{{APIRef("WebRTC")}}

The **`setConfiguration()`** method of the {{domxref("RTCPeerConnection")}} interface sets the current configuration of the connection based on the values included in the specified object.
This lets you change the ICE servers used by the connection and which transport policies to use.

The most common use case for this method (and even then, probably not a very common use case) is to replace the set of ICE servers to be used. Two potential scenarios in which this might be done:

- The {{domxref("RTCPeerConnection")}} was instantiated without specifying any ICE servers.
  If, for example, the {{domxref("RTCPeerConnection.RTCPeerConnection()", "RTCPeerConnection()")}} constructor was called with no parameters, you would have to then call `setConfiguration()` to add ICE servers before ICE negotiation could begin.
- Renegotiation of the connection is needed, and a different set of ICE servers needs to be used for some reason.
  Perhaps the user has moved into a new region, so using new regional ICE servers is necessary, for example.
  In this situation, one might call `setConfiguration()` to switch to new regional ICE servers, then initiate an [ICE restart](/en-US/docs/Web/API/WebRTC_API/Session_lifetime#ice_restart).

> [!NOTE]
> You cannot change the identity information for a connection once it's already been set.

## Syntax

```js-nolint
setConfiguration(configuration)
```

### Parameters

- `configuration`
  - : An object which provides the options to be set.
    The changes are not additive; instead, the new values completely replace the existing ones.
    See [`RTCPeerConnection()`](/en-US/docs/Web/API/RTCPeerConnection/RTCPeerConnection#parameters) for more information on what options are allowed.

### Return value

None ({{jsxref("undefined")}}).

### Exceptions

- `InvalidAccessError` {{domxref("DOMException")}}
  - : Thrown if one or more of the URLs specified in `configuration.iceServers` is a {{Glossary("TURN")}} server, but complete login information is not provided (that is, either the `username` or `credential` is missing, or if `credentialType` is `"password"` and `credential` is not a string).
    This prevents successful login to the server.
- `InvalidModificationError` {{domxref("DOMException")}}
  - : Thrown if the `configuration` includes changed identity information, but the connection already has identity information specified.
    This happens if `configuration.peerIdentity` or `configuration.certificates` are set and their values differ from the current configuration.
    This may also be thrown if there are changes to `configuration.bundlePolicy` or `configuration.rtcpMuxPolicy`, or to `configuration.iceCandidatePoolSize` when {{domxref("RTCPeerConnection.setLocalDescription()")}} has already been called.
- `InvalidStateError` {{domxref("DOMException")}}
  - : Thrown if the {{domxref("RTCPeerConnection")}} is closed.
- `SyntaxError` {{domxref("DOMException")}}
  - : Thrown if the `configuration.iceServers` contains no URLs or if one of the values in the list is invalid.
- `NotSupportedError` {{domxref("DOMException")}}
  - : Thrown if `configuration.iceServers` contains a URL with a scheme that is not supported.

## Example

In this example, it has already been determined that ICE restart is needed, and that negotiation needs to be done using a different ICE server.

```js
const restartConfig = {
  iceServers: [
    {
      urls: "turn:asia.turn-server.net",
      username: "allie@oopcode.com",
      credential: "topsecretpassword",
    },
  ],
};

myPeerConnection.setConfiguration(restartConfig);

myPeerConnection.restartIce();

myPeerConnection
  .createOffer() // restartIce() causes iceRestart to be set true
  .then((offer) => myPeerConnection.setLocalDescription(offer))
  .then(() => {
    // send the offer to the other peer using the signaling server
  })
  .catch(window.reportError);
```

First, a new object is created, `restartConfig`, specifying the new ICE server and its credentials.
This is then passed into `setConfiguration()`.
ICE negotiation is restarted by calling {{domxref("RTCPeerConnection.restartIce()", "restartIce()")}}, which causes the next offer created to include the new ICE server information.
From there, we handle the process as usual, by setting the local description to the returned offer and then sending that offer to the other peer.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCPeerConnection.getConfiguration()")}}
- {{domxref("RTCPeerConnection.RTCPeerConnection", "RTCPeerConnection()")}}
- {{domxref("RTCPeerConnection")}}
# RTCPeerConnection: setIdentityProvider() method

{{APIRef("WebRTC")}}

The **`setIdentityProvider()`** method of the {{domxref("RTCPeerConnection")}} interface sets the Identity Provider (IdP) to the triplet given in parameter: its name, the protocol used to communicate with it (optional) and an optional username.
The IdP will be used only when an assertion is needed.

If the {{domxref("RTCPeerConnection.signalingState", "signalingState")}} is set to `"closed"`, an `InvalidStateError` is raised.

## Syntax

```js-nolint
setIdentityProvider(domainname)
setIdentityProvider(domainname, protocol)
setIdentityProvider(domainname, protocol, username)
```

### Parameters

- `domainname`
  - : A string representing the domain name where the IdP is.
- `protocol` {{optional_Inline}}
  - : A string representing the protocol used to communicate with the IdP.
    It defaults to `"default"` and is used to determine the URL where the IdP is listening.
- `username` {{optional_Inline}}
  - : A string representing the username associated with the IdP.

### Return value

None ({{jsxref("undefined")}}).

## Example

```js
const pc = new RTCPeerConnection();

pc.setIdentityProvider("developer.mozilla.org");
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
# RTCPeerConnection: setLocalDescription() method

{{APIRef("WebRTC")}}

The **`setLocalDescription()`** method of the {{domxref("RTCPeerConnection")}} interface changes the local description associated with the connection.
This description specifies the properties of the local end of the connection, including the media format.
The method takes a single parameter—the session description—and it returns a {{jsxref("Promise")}} which is fulfilled once the description has been changed, asynchronously.

If `setLocalDescription()` is called while a connection is already in place, it means renegotiation is underway (possibly to adapt to changing network conditions).
Because descriptions will be exchanged until the two peers agree on a configuration, the description submitted by calling `setLocalDescription()` does not immediately take effect.
Instead, the current connection configuration remains in place until negotiation is complete. Only then does the agreed-upon configuration take effect.

## Syntax

```js-nolint
setLocalDescription()
setLocalDescription(sessionDescription)

setLocalDescription(sessionDescription, successCallback, errorCallback) // deprecated
```

### Parameters

- `sessionDescription` {{optional_inline}}
  - : An object which specifies the configuration to be applied to the local end of the connection. It should contain the following properties:
    - `type` {{optional_inline}}
      - : A string indicating the type of the session description. If you don't explicitly provide a session description, the WebRTC runtime will try to handle it correctly. If the signaling state is one of `stable`, `have-local-offer`, or `have-remote-pranswer`, the WebRTC runtime automatically creates a new offer and sets that as the new local description. Otherwise, `setLocalDescription()` creates an answer, which becomes the new local description.
    - `sdp` {{optional_inline}}
      - : A string containing the SDP describing the session. If sdp is not provided, it defaults to an empty string. If `type` is `"rollback"`, `sdp` must be null or an empty string.

    If the description is omitted, the WebRTC runtime tries to automatically do the right thing.

    You can also pass an actual {{domxref("RTCSessionDescription")}} instance, but there's no difference. For this reason, the `RTCSessionDescription` constructor is deprecated.

In older code and documentation, you may see a callback-based version of this function used.
This has been deprecated and its use is **strongly** discouraged, as it will be removed in the future.
You should update any existing code to use the {{jsxref("Promise")}}-based version of `setLocalDescription()` instead.
The parameters for the older form of `setLocalDescription()` are described below, to aid in updating existing code.

- `successCallback` {{deprecated_inline}}
  - : A JavaScript {{jsxref("Function")}} which accepts no input parameters to be called once the description has been successfully set.
    At that time, the offer can be sent to a remote peer via the signaling server.
- `errorCallback` {{deprecated_inline}}
  - : A function matching the signature `RTCPeerConnectionErrorCallback` which gets called if the description can't be set.
    It is passed a single {{domxref("DOMException")}} object explaining why the request failed.

This deprecated form of the method returns instantaneously without waiting for the actual setting to be done: in case of success, the `successCallback` will be called; in case of failure, the `errorCallback` will be called.

### Return value

A {{jsxref("Promise")}} which is fulfilled once the value of {{domxref("RTCPeerConnection.localDescription")}} is successfully changed or rejected if the change cannot be applied (for example, if the specified description is incompatible with one or both of the peers on the connection).
The promise's fulfillment handler receives no input parameters.

> [!NOTE]
> The process of changing descriptions actually involves intermediary steps handled by the WebRTC layer to ensure that an active connection can be changed without losing the connection if the change does not succeed.
> See [Pending and current descriptions](/en-US/docs/Web/API/WebRTC_API/Connectivity#pending_and_current_descriptions) in the WebRTC Connectivity page for more details on this process.

### Deprecated exceptions

When using the deprecated callback-based version of `setLocalDescription()`, the following exceptions may occur:

- `InvalidStateError` {{domxref("DOMException")}} {{deprecated_inline}}
  - : Thrown if the connection's {{domxref("RTCPeerConnection.signalingState", "signalingState")}} is `"closed"`, indicating that the connection is not currently open, so negotiation cannot take place.
- `InvalidSessionDescriptionError` {{domxref("DOMException")}} {{deprecated_inline}}
  - : Thrown if the `sessionDescription` parameter is invalid.

## Examples

### Implicit descriptions

One of the advantages of the parameter-free form of `setLocalDescription()` is that it lets you simplify your negotiation code substantially.
This is all your {{domxref("RTCPeerConnection.negotiationneeded_event", "negotiationneeded")}} event handler needs to look like, for the most part.
Just add the signaling server code, which here is represented by the call to `signalRemotePeer()`.

```js
pc.addEventListener("negotiationneeded", async (event) => {
  await pc.setLocalDescription();
  signalRemotePeer({ description: pc.localDescription });
});
```

Other than error handling, that's about it!

### Providing your own offer or answer

The example below shows the implementation of a handler for the {{DOMxRef("RTCPeerConnection/negotiationneeded_event", "negotiationneeded")}} event that explicitly creates an offer, rather than letting `setLocalDescription()` do it.

```js
async function handleNegotiationNeededEvent() {
  try {
    const offer = await pc.createOffer();
    pc.setLocalDescription(offer);
    signalRemotePeer({ description: pc.localDescription });
  } catch (err) {
    window.reportError(err);
  }
}
```

This begins by creating an offer by calling {{domxref("RTCPeerConnection.createOffer()", "createOffer()")}}; when that succeeds, we call `setLocalDescription()`.
We can then send the newly-created offer along to the other peer using the signaling server, which here is done by calling a function
called `signalRemotePeer()`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCSessionDescription")}}
# RTCPeerConnection: setRemoteDescription() method

{{APIRef("WebRTC")}}

The **`setRemoteDescription()`** method of the {{domxref("RTCPeerConnection")}} interface sets the specified session description as the remote peer's current offer or answer.
The description specifies the properties of the remote end of the connection, including the media format.
The method takes a single parameter—the session description—and it returns a {{jsxref("Promise")}} which is fulfilled once the description has been changed, asynchronously.

This is typically called after receiving an offer or answer from another peer over the signaling server.
Keep in mind that if `setRemoteDescription()` is called while a connection is already in place, it means renegotiation is underway (possibly to adapt to changing network conditions).

Because descriptions will be exchanged until the two peers agree on a configuration, the description submitted by calling `setRemoteDescription()` does not immediately take effect.
Instead, the current connection configuration remains in place until negotiation is complete.
Only then does the agreed-upon configuration take effect.

## Syntax

```js-nolint
setRemoteDescription(sessionDescription)

// deprecated
setRemoteDescription(sessionDescription, successCallback, errorCallback)
```

### Parameters

- `sessionDescription`
  - : An object which specifies the remote peer's current offer or answer. It should contain the following properties:
    - `type`
      - : A string indicating the type of the session description. See {{domxref("RTCSessionDescription.type")}}.
    - `sdp` {{optional_inline}}
      - : A string containing the SDP describing the session. If sdp is not provided, it defaults to an empty string. If `type` is `"rollback"`, `sdp` must be null or an empty string. See {{domxref("RTCSessionDescription.sdp")}}.

    You can also pass an actual {{domxref("RTCSessionDescription")}} instance, but there's no difference. For this reason, the `RTCSessionDescription` constructor is deprecated.

In older code and documentation, you may see a callback-based version of this function used.
This has been deprecated and its use is _strongly_ discouraged.
You should update any existing code to use the {{jsxref("Promise")}}-based version of `setRemoteDescription()` instead.
The parameters for the older form of `setRemoteDescription()` are described below, to aid in updating existing code.

- `successCallback` {{deprecated_inline}}
  - : A JavaScript {{jsxref("Function")}} which accepts no input parameters to be called once the description has been successfully set.
    At that time, the offer can be sent to a remote peer via the signaling server.
- `errorCallback` {{deprecated_inline}}
  - : A function matching the signature `RTCPeerConnectionErrorCallback` which gets called if the description can't be set.
    It is passed a single {{domxref("DOMException")}} object explaining why the request failed.

This deprecated form of the method returns instantaneously without waiting for the actual setting to be done: in case of success, the `successCallback` will be called; in case of failure, the `errorCallback` will be called.

### Return value

A {{jsxref("Promise")}} which is fulfilled once the value of the connection's {{domxref("RTCPeerConnection.remoteDescription", "remoteDescription")}} is successfully changed or rejected if the change cannot be applied (for example, if the specified description is incompatible with one or both of the peers on the connection).
The promise fulfillment handler receives no input parameters.

> [!NOTE]
> The process of changing descriptions actually involves intermediary steps handled by the WebRTC layer to ensure that an active connection can be changed without losing the connection if the change does not succeed.
> See [Pending and current descriptions](/en-US/docs/Web/API/WebRTC_API/Connectivity#pending_and_current_descriptions) in the WebRTC Connectivity page for more details on this process.

### Exceptions

The following exceptions are reported to the rejection handler for the promise returned by `setRemoteDescription()`:

- `InvalidAccessError` {{domxref("DOMException")}}
  - : Returned if the content of the description is invalid.
- `InvalidStateError` {{domxref("DOMException")}}
  - : Returned if the {{domxref("RTCPeerConnection")}} is closed, or it's in a state that is not compatible with the specified description's
    {{domxref("RTCSessionDescription.type", "type")}}.
    For example, this exception is thrown if the `type` is `rollback` and the signaling state is one of `stable`, `have-local-pranswer`, or `have-remote-pranswer` because you cannot roll back a connection that's either fully established or is in the final stage of becoming connected.
- `OperationError` {{domxref("DOMException")}}
  - : Returned if an error does not match the ones specified here. This includes identity validation errors.
- `RTCError` {{domxref("DOMException")}}
  - : Returned with the {{domxref("RTCError.errorDetail", "errorDetail")}} set to `sdp-syntax-error` if the {{Glossary("SDP")}} specified by {{domxref("RTCSessionDescription.sdp")}} is not valid.
    The error object's {{domxref("RTCError.sdpLineNumber", "sdpLineNumber")}} property indicates the line number within the SDP on which the syntax error was detected.
- {{jsxref("TypeError")}}
  - : Returned if the `sessionDescription` is missing the {{domxref("RTCSessionDescription.type", "type")}} property, or no description parameter was provided at all.

When using the deprecated callback-based version of `setRemoteDescription()`, the following exceptions may occur:

- `InvalidStateError` {{deprecated_inline}}
  - : The connection's {{domxref("RTCPeerConnection.signalingState", "signalingState")}} is `"closed"`, indicating that the connection is not currently open, so negotiation cannot take place.
- `InvalidSessionDescriptionError` {{deprecated_inline}}
  - : The `sessionDescription` parameter is invalid.

## Usage notes

When you call `setRemoteDescription()`, the ICE agent checks to make sure the {{domxref("RTCPeerConnection")}} is in either the `stable` or `have-remote-offer` {{domxref("RTCPeerConnection.signalingState", "signalingState")}}.
These states indicate that either an existing connection is being renegotiated or that an offer previously specified by an earlier call to `setRemoteDescription()` is to be replaced with the new offer.
In either of those two cases, we're at the beginning of the negotiation process, and the offer is set as the remote description.

On the other hand, if we're in the middle of an ongoing negotiation and an offer is passed into `setRemoteDescription()`, the ICE agent automatically begins an ICE rollback in order to return the connection to a stable signaling state, then, once the rollback is completed, sets the remote description to the specified offer.
This begins a new negotiation session, with the newly-established offer as the starting point.

Upon starting the new negotiation with the newly-established offer, the local peer is now the callee, even if it was previously the caller.
This happens instead of throwing an exception, thereby reducing the number of potential errors which might occur, and simplifies the processing you need to do when you receive an offer, by eliminating the need to handle the offer/answer process differently depending on whether the local peer is the caller or callee.

> [!NOTE]
> Earlier implementations of WebRTC would throw an exception if an offer was set outside a `stable` or `have-remote-offer` state.

## Examples

Here we see a function which handles an offer received from the remote peer.
This code is derived from the example and tutorial in the article [Signaling and video calling](/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling); take a look at that for more details and a more in-depth explanation of what's going on.

```js
function handleOffer(msg) {
  createMyPeerConnection();

  myPeerConnection
    .setRemoteDescription(msg.description)
    .then(() => navigator.mediaDevices.getUserMedia(mediaConstraints))
    .then((stream) => {
      document.getElementById("local_video").srcObject = stream;
      return myPeerConnection.addStream(stream);
    })
    .then(() => myPeerConnection.createAnswer())
    .then((answer) => myPeerConnection.setLocalDescription(answer))
    .then(() => {
      // Send the answer to the remote peer using the signaling server
    })
    .catch(handleGetUserMediaError);
}
```

After creating our {{domxref("RTCPeerConnection")}} and saving it as `myPeerConnection`, we pass the description included in the received offer
message, `msg`, directly into `setRemoteDescription()` to tell the user agent's WebRTC layer what configuration the caller has proposed using.
When our promise fulfillment handler is called, indicating that this has been done, we create a stream, add it to the connection, then create an SDP answer and call {{domxref("RTCPeerConnection.setLocalDescription", "setLocalDescription()")}} to set that as the configuration at our end of the call before forwarding that answer to the caller.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCPeerConnection.remoteDescription")}},
  {{domxref("RTCPeerConnection.pendingRemoteDescription")}},
  {{domxref("RTCPeerConnection.currentRemoteDescription")}}
- {{domxref("RTCSessionDescription")}}
# RTCPeerConnection: signalingState property

{{APIRef("WebRTC")}}

The **`signalingState`** read-only property of the {{domxref("RTCPeerConnection")}} interface returns a string value describing the state of the signaling process on the local end of the connection while connecting or reconnecting to another peer.
See [Signaling](/en-US/docs/Web/API/WebRTC_API/Session_lifetime#signaling) in our WebRTC session lifetime page.

Because the signaling process is a state machine, being able to verify that your code is in the expected state when messages arrive can help avoid unexpected and avoidable failures.
For example, if you receive an answer while the `signalingState` isn't `"have-local-offer"`, you know that something is wrong, since you should only receive answers after creating an offer but before an answer has been received and passed into {{domxref("RTCPeerConnection.setLocalDescription()")}}. Your code will be more reliable if you watch for mismatched states like this and handle them gracefully.

This value may also be useful during debugging, for example.

In addition, when the value of this property changes, a {{DOMxRef("RTCPeerConnection/signalingstatechange_event", "signalingstatechange")}} event is sent to the {{domxref("RTCPeerConnection")}} instance.

## Value

The allowed string values are:

- `stable`
  - : There is no ongoing exchange of offer and answer underway.
    This may mean that the {{domxref("RTCPeerConnection")}} object is new, in which case both the {{domxref("RTCPeerConnection.localDescription", "localDescription")}} and {{domxref("RTCPeerConnection.remoteDescription", "remoteDescription")}} are `null`;
    it may also mean that negotiation is complete and a connection has been established.
- `have-local-offer`
  - : The local peer has called {{domxref("RTCPeerConnection.setLocalDescription()")}}, passing in SDP representing an offer (usually created by calling {{domxref("RTCPeerConnection.createOffer()")}}), and the offer has been applied successfully.
- `have-remote-offer`
  - : The remote peer has created an offer and used the signaling server to deliver it to the local peer, which has set the offer as the remote description by calling {{domxref("RTCPeerConnection.setRemoteDescription()")}}.
- `have-local-pranswer`
  - : The offer sent by the remote peer has been applied and an answer has been created (usually by calling {{domxref("RTCPeerConnection.createAnswer()")}}) and applied by calling {{domxref("RTCPeerConnection.setLocalDescription()")}}.
    This provisional answer describes the supported media formats and so forth, but may not have a complete set of ICE candidates included.
    Further candidates will be delivered separately later.
- `have-remote-pranswer`
  - : A provisional answer has been received and successfully applied in response to an offer previously sent and established by calling `setLocalDescription()`.
- `closed`
  - : The {{domxref("RTCPeerConnection")}} has been closed.

## Examples

```js
const pc = new RTCPeerConnection(configuration);
const state = pc.signalingState;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Lifetime of a WebRTC session](/en-US/docs/Web/API/WebRTC_API/Session_lifetime)
- {{domxref("RTCPeerConnection")}}
- {{DOMxRef("RTCPeerConnection/signalingstatechange_event", "signalingstatechange")}}
- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
# RTCPeerConnection: signalingstatechange event

{{APIRef("WebRTC")}}

A **`signalingstatechange`** event is sent to an {{domxref("RTCPeerConnection")}} to notify it that its signaling state, as indicated by the {{domxref("RTCPeerConnection.signalingState", "signalingState")}} property, has changed.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("signalingstatechange", (event) => { })

onsignalingstatechange = (event) => { }
```

## Event type

A generic {{domxref("Event")}}.

## Examples

Given an {{domxref("RTCPeerConnection")}}, `pc`, and an `updateStatus()` function that presents status information to the user, this code sets up an event handler to let the user know when the ICE negotiation process finishes up.

```js
pc.addEventListener("signalingstatechange", (ev) => {
  switch (pc.signalingState) {
    case "stable":
      updateStatus("ICE negotiation complete");
      break;
  }
});
```

Using `onsignalingstatechange`, it looks like this:

```js
pc.onsignalingstatechange = (ev) => {
  switch (pc.signalingState) {
    case "stable":
      updateStatus("ICE negotiation complete");
      break;
  }
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCPeerConnection.signalingState")}}
# RTCPeerConnection: track event

{{APIRef("WebRTC")}}

The **`track`** event is sent to the `ontrack` event handler on {{domxref("RTCPeerConnection")}}s after a new track has been added to an {{domxref("RTCRtpReceiver")}} which is part of the connection.

By the time this event is delivered, the new track has been fully added to the peer connection. See [Track event types](/en-US/docs/Web/API/RTCTrackEvent#track_event_types) for details.

This event is not cancellable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("track", (event) => { })

ontrack = (event) => { }
```

## Event type

An {{domxref("RTCTrackEvent")}}. Inherits from {{domxref("Event")}}.

{{InheritanceDiagram("RTCTrackEvent")}}

## Event properties

_Since `RTCTrackEvent` is based on {{domxref("Event")}}, its properties are also available._

- {{domxref("RTCTrackEvent.receiver", "receiver")}} {{ReadOnlyInline}}
  - : The {{domxref("RTCRtpReceiver")}} used by the track that's been added to the `RTCPeerConnection`.
- {{domxref("RTCTrackEvent.streams", "streams")}} {{ReadOnlyInline}} {{optional_inline}}
  - : An array of {{domxref("MediaStream")}} objects, each representing one of the media streams to which the added {{domxref("RTCTrackEvent.track", "track")}} belongs. By default, the array is empty, indicating a streamless track.
- {{domxref("RTCTrackEvent.track", "track")}} {{ReadOnlyInline}}
  - : The {{domxref("MediaStreamTrack")}} which has been added to the connection.
- {{domxref("RTCTrackEvent.transceiver", "transceiver")}} {{ReadOnlyInline}}
  - : The {{domxref("RTCRtpTransceiver")}} being used by the new track.

## Examples

This example shows code that creates a new {{domxref("RTCPeerConnection")}}, then adds a new `track` event handler.

```js
pc = new RTCPeerConnection({
  iceServers: [
    {
      urls: "turn:fake.turn-server.url",
      username: "some username",
      credential: "some-password",
    },
  ],
});

pc.addEventListener("track", (e) => {
  videoElement.srcObject = e.streams[0];
  hangupButton.disabled = false;
});
```

The event handler assigns the new track's first stream to an existing {{HTMLElement("video")}} element, identified using the variable `videoElement`.

You can also assign the event handler function to the `ontrack` property, rather than use {{domxref("EventTarget.addEventListener", "addEventListener()")}}.

```js
pc.ontrack = (e) => {
  videoElement.srcObject = e.streams[0];
  hangupButton.disabled = false;
  return false;
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCPeerConnectionIceErrorEvent: address property

{{APIRef("WebRTC")}}

The {{domxref("RTCPeerConnectionIceErrorEvent")}} property
**`address`** is a string which indicates the local IP address
being used to communicate with the {{Glossary("STUN")}} or {{Glossary("TURN")}} server
during negotiations. The error which occurred involved this address.

## Value

A string which specifies the local IP address of the network
connection to the ICE server with which negotiations were occurring when the error
occurred. This address identifies the network interface on the local device which is
being used to attempt to establish the connection to the remote peer.

This can be useful on multi-homed systems—devices with more than one network
connection—to determine which network interface is being used. For example, on a mobile
phone, there are typically at least two network interfaces available: the cellular
connection and a Wi-Fi connection.

If the local IP address isn't exposed as part of a local candidate, the value of
`address` is `null`.

## Examples

This example creates a handler for
{{domxref("RTCPeerConnection.icecandidateerror_event", "icecandidateerror")}} events
which creates human-readable messages describing the local network interface for the
connection as well as the ICE server that was being used to try to open the connection,
then calls a function to display those as well as the event's
{{domxref("RTCPeerConnectionIceErrorEvent.errorText", "errorText")}} property's
contents.

```js
pc.addEventListener("icecandidateerror", (event) => {
  let networkInfo = `[Local interface: ${event.address}:${event.port}`;
  let iceServerInfo = `[ICE server: ${event.url}`;

  showMessage(errorText, iceServerInfo, networkInfo);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCPeerConnectionIceErrorEvent

{{APIRef("WebRTC")}}

The **`RTCPeerConnectionIceErrorEvent`** interface—based upon the {{domxref("Event")}} interface—provides details pertaining to an {{Glossary("ICE")}} error announced by sending an {{domxref("RTCPeerConnection.icecandidateerror_event", "icecandidateerror")}} event to the {{domxref("RTCPeerConnection")}} object.

{{InheritanceDiagram}}

## Constructor

- {{domxref("RTCPeerConnectionIceErrorEvent.RTCPeerConnectionIceErrorEvent", "RTCPeerConnectionIceErrorEvent()")}}
  - : Creates and returns a new `RTCPeerConnectionIceErrorEvent` object, with its `type` and other properties initialized as specified in the parameters. You will not normally create an object of this type yourself.

## Instance properties

_The `RTCPeerConnectionIceErrorEvent` interface includes the properties found on the {{domxref("Event")}} interface, as well as the following properties:_

- {{domxref("RTCPeerConnectionIceErrorEvent.address", "address")}} {{ReadOnlyInline}}
  - : A string providing the local IP address used to communicate with the {{Glossary("STUN")}} or {{Glossary("TURN")}} server being used to negotiate the connection, or `null` if the local IP address has not yet been exposed as part of a local ICE candidate.
- {{domxref("RTCPeerConnectionIceErrorEvent.errorCode", "errorCode")}} {{ReadOnlyInline}}
  - : An unsigned integer value stating the numeric [STUN error code](https://www.iana.org/assignments/stun-parameters/stun-parameters.xhtml#stun-parameters-6) returned by the STUN or TURN server. If no host candidate can reach the server, this property is set to the number 701, which is outside the range of valid STUN error codes. The 701 error is fired only once per server URL, and only while the {{domxref("RTCPeerConnection.iceGatheringState", "iceGatheringState")}} is `gathering`.
- {{domxref("RTCPeerConnectionIceErrorEvent.errorText", "errorText")}} {{ReadOnlyInline}}
  - : A string containing the STUN reason text returned by the STUN or TURN server. If communication with the STUN or TURN server couldn't be established at all, this string will be a browser-specific string explaining the error.
- {{domxref("RTCPeerConnectionIceErrorEvent.port", "port")}} {{ReadOnlyInline}}
  - : An unsigned integer value giving the port number over which communication with the STUN or TURN server is taking place, using the IP address given in `address`. `null` if the connection hasn't been established (that is, if `address` is `null`).
- {{domxref("RTCPeerConnectionIceErrorEvent.url", "url")}} {{ReadOnlyInline}}
  - : A string indicating the URL of the STUN or TURN server with which the error occurred.

## Instance methods

_`RTCPeerConnectionIceErrorEvent` has no methods other than any provided by the parent interface, {{domxref("Event")}}._

## Examples

TBD

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCPeerConnectionIceEvent: candidate property

{{APIRef("WebRTC")}}

The read-only **`candidate`** property
of the {{domxref("RTCPeerConnectionIceEvent")}} interface returns the
{{domxref("RTCIceCandidate")}} associated with the event.

## Value

An {{domxref("RTCIceCandidate")}} object representing the ICE candidate that has been
received, or `null` to indicate that there are no further candidates for this
negotiation session.

## Example

```js
pc.onicecandidate = (ev) => {
  alert(
    `The ICE candidate (transport address: '${ev.candidate.candidate}') has been added to this connection.`,
  );
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCPeerConnection.icecandidate_event", "icecandidate")}}
- {{domxref("RTCPeerConnection")}}
# RTCPeerConnectionIceEvent

{{APIRef("WebRTC")}}

The **`RTCPeerConnectionIceEvent`** interface represents events that occur in relation to {{Glossary("ICE")}} candidates with the target, usually an {{domxref("RTCPeerConnection")}}.

Only one event is of this type: {{domxref("RTCPeerConnection.icecandidate_event", "icecandidate")}}.

{{InheritanceDiagram}}

## Instance properties

_A `RTCPeerConnectionIceEvent` being an {{domxref("Event")}}, this event also implements these properties_.

- {{domxref("RTCPeerConnectionIceEvent.candidate")}} {{ReadOnlyInline}}
  - : Contains the {{domxref("RTCIceCandidate")}} containing the candidate associated with the event, or `null` if this event indicates that there are no further candidates to come.

## Constructors

- {{domxref("RTCPeerConnectionIceEvent.RTCPeerConnectionIceEvent()", "RTCPeerConnectionIceEvent()")}}
  - : Returns a new `RTCPeerConnectionIceEvent`. It takes two parameters, the first being a string representing the type of the event; the second a dictionary containing the {{domxref("RTCIceCandidate")}} it refers to.

## Instance methods

_A `RTCPeerConnectionIceEvent` being an {{domxref("Event")}}, this event also implements these properties. There is no specific {{domxref("RTCDataChannelEvent")}} method._

## Examples

```js
pc.onicecandidate = (ev) => {
  console.log(
    `The ICE candidate ('${ev.candidate.candidate}') added to connection.`,
  );
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
- Its usual target: {{domxref("RTCPeerConnection")}}.
# RTCPeerConnectionIceEvent: RTCPeerConnectionIceEvent() constructor

{{APIRef("WebRTC")}}

The **`RTCPeerConnectionIceEvent()`** constructor creates a new
{{domxref("RTCPeerConnectionIceEvent")}} object.

## Syntax

```js-nolint
new RTCPeerConnectionIceEvent(type, options)
```

### Parameters

- `type`
  - : A string with the name of the event.
    It is case-sensitive and browsers always set it to `icecandidate`.
- `options` {{optional_inline}}
  - : An object that, _in addition of the properties defined in {{domxref("Event/Event", "Event()")}}_, can have the following properties:
    - `candidate`
      - : A {{domxref("RTCIceCandidate")}} representing the ICE candidate being concerned by the event.
        If `null`, the event indicates the end of candidate gathering.
    - `url`
      - : A string containing the URL of the STUN or TURN server which was used to gather the candidate.
        If the candidate was not gathered by a {{Glossary("STUN")}} or {{Glossary("TURN")}} server,
        this value must be `null`, which is also the default value.

### Return value

A new {{domxref("RTCPeerConnectionIceEvent")}} object, configured as specified in the provided options.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
- Its usual target: {{domxref("RTCPeerConnection")}}.
# RTCPeerConnectionStats: dataChannelsClosed property

{{APIRef("WebRTC")}}

The **`dataChannelsClosed`** property of the {{domxref("RTCPeerConnectionStats")}} dictionary indicates the number of unique {{domxref("RTCDataChannel")}} objects that have left the [`open`](/en-US/docs/Web/API/RTCDataChannel/readyState#open) state during their lifetime.

A channel will leave the `open` state if either end of the connection or the underlying transport is closed.
Note that channels that transition to [`closing`](/en-US/docs/Web/API/RTCDataChannel/readyState#closing) or [`closed`](/en-US/docs/Web/API/RTCDataChannel/readyState#closed) without ever being `open` are not counted in this number.

## Value

A positive integer that indicates the number of unique {{domxref("RTCDataChannel")}} objects that have left the [`open`](/en-US/docs/Web/API/RTCDataChannel/readyState#open) state during their lifetime.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCPeerConnectionStats: dataChannelsOpened property

{{APIRef("WebRTC")}}

The **`dataChannelsOpened`** property of the {{domxref("RTCPeerConnectionStats")}} dictionary indicates the number of unique {{domxref("RTCDataChannel")}} objects that have entered the [`open`](/en-US/docs/Web/API/RTCDataChannel/readyState#open) state during their lifetime.

## Value

A positive integer that indicates the number of unique {{domxref("RTCDataChannel")}} objects that have entered the [`open`](/en-US/docs/Web/API/RTCDataChannel/readyState#open) state during their lifetime.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCPeerConnectionStats: id property

{{APIRef("WebRTC")}}

The **`id`** property of the {{domxref("RTCPeerConnectionStats")}} dictionary is a string which uniquely identifies the object for which this object provides statistics.

Using the `id`, you can correlate this statistics object with others, in order to monitor statistics over time for a given WebRTC object, such as an {{domxref("RTCPeerConnection")}}, or an {{domxref("RTCDataChannel")}}.

## Value

A string that uniquely identifies the object for which this `RTCPeerConnectionStats` object provides statistics.

The format of the ID string is not defined by the specification, so you cannot reliably make any assumptions about the contents of the string, or assume that the format of the string will remain unchanged for a given object type.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCPeerConnectionStats

{{APIRef("WebRTC")}}

The **`RTCPeerConnectionStats`** dictionary of the [WebRTC API](/en-US/docs/Web/API/WebRTC_API) provides information about the high level peer connection ({{domxref("RTCPeerConnection")}}).

In particular, it provides the number of unique data channels that have been opened, and the number of opened channels that have been closed.
This allows the current number of open channels to be calculated.

These statistics can be obtained by iterating the {{domxref("RTCStatsReport")}} returned by {{domxref("RTCPeerConnection.getStats()")}} until you find a report with the [`type`](/en-US/docs/Web/API/RTCPeerConnectionStats/type) of `peer-connection`.

## Instance properties

- {{domxref("RTCPeerConnectionStats.dataChannelsOpened", "dataChannelsOpened")}}
  - : A positive integer value indicating the number of unique {{domxref("RTCDataChannel")}} objects that have entered the [`open`](/en-US/docs/Web/API/RTCDataChannel/readyState#open) state during their lifetime.
- {{domxref("RTCPeerConnectionStats.dataChannelsClosed", "dataChannelsClosed")}}
  - : A positive integer value indicating the number of unique {{domxref("RTCDataChannel")}} objects that have left the [`open`](/en-US/docs/Web/API/RTCDataChannel/readyState#open) state during their lifetime (channels that transition to [`closing`](/en-US/docs/Web/API/RTCDataChannel/readyState#closing) or [`closed`](/en-US/docs/Web/API/RTCDataChannel/readyState#closed) without ever being `open` are not counted in this number).
    A channel will leave the `open` state if either end of the connection or the underlying transport is closed.

### Common instance properties

The following properties are common to all WebRTC statistics objects.

<!-- RTCStats -->

- {{domxref("RTCPeerConnectionStats.id", "id")}}
  - : A string that uniquely identifies the object that is being monitored to produce this set of statistics.
- {{domxref("RTCPeerConnectionStats.timestamp", "timestamp")}}
  - : A {{domxref("DOMHighResTimeStamp")}} object indicating the time at which the sample was taken for this statistics object.
- {{domxref("RTCPeerConnectionStats.type", "type")}}
  - : A string with the value `"peer-connection"`, indicating the type of statistics that the object contains.

## Examples

This example shows a function to return the total number of open connections, or `null` if no statistics are provided.
This might be called in a loop, similar to the approach used in [`RTCPeerConnection.getStats()` example](/en-US/docs/Web/API/RTCPeerConnection/getStats#examples)

The function waits for the result of a call to {{domxref("RTCPeerConnection.getStats()")}} and then iterates the returned {{domxref("RTCStatsReport")}} to get just the stats of type `"peer-connection"`.
It then returns the total number of open channels, or `null`, using the data in the report.

```js
async function numberOpenConnections (peerConnection) {
  const stats = await peerConnection.getStats();
  let peerConnectionStats = null;

  stats.forEach((report) => {
    if (report.type === "peer-connection") {
      peerConnectionStats = report;
      break;
    }
  });

result = (typeof peerConnectionStats.dataChannelsOpened === 'undefined' || typeof peerConnectionStats.dataChannelsClosed=== 'undefined') ? null : peerConnectionStats.dataChannelsOpened - peerConnectionStats.dataChannelsClosed;
return result
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCPeerConnectionStats: timestamp property

{{APIRef("WebRTC")}}

The **`timestamp`** property of the {{domxref("RTCPeerConnectionStats")}} dictionary is a {{domxref("DOMHighResTimeStamp")}} object specifying the time at which the data in the object was sampled.

## Value

A {{domxref("DOMHighResTimeStamp")}} value indicating the time at which the activity described by the statistics in this object was recorded, in milliseconds elapsed since the beginning of January 1, 1970, UTC.

The value should be accurate to within a few milliseconds but may not be entirely precise, either because of hardware or operating system limitations or because of [fingerprinting](/en-US/docs/Glossary/Fingerprinting) protection in the form of reduced clock precision or accuracy.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCPeerConnectionStats: type property

{{APIRef("WebRTC")}}

The **`type`** property of the {{domxref("RTCPeerConnectionStats")}} dictionary is a string with the value `"peer-connection"`.

Different statistics are obtained by iterating the {{domxref("RTCStatsReport")}} object returned by a call to {{domxref("RTCPeerConnection.getStats()")}}.
The type indicates the set of statistics available through the object in a particular iteration step.
A value of `"peer-connection"` indicates that the statistics available in the current step are those defined in {{domxref("RTCPeerConnectionStats")}}.

## Value

A string with the value `"peer-connection"`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteInboundRtpStreamStats: codecId property

{{APIRef("WebRTC")}}

The **`codecId`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary is a string that uniquely identifies the object that was inspected to produce the data in the {{domxref("RTCCodecStats")}} for the {{Glossary("RTP")}} stream.

`RTCRemoteInboundRtpStreamStats` and `RTCCodecStats` objects are correlated by iterating the {{domxref("RTCStatsReport")}} to find the statistics objects where `RTCRemoteInboundRtpStreamStats.codecId` is equal to {{domxref("RTCCodecStats.id")}}.

## Value

A string that contains the {{domxref("RTCCodecStats.id","id")}} of the object that was inspected to produce the {{domxref("RTCCodecStats")}} object associated with this RTP stream.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteInboundRtpStreamStats: fractionLost property

{{APIRef("WebRTC")}}

The **`fractionLost`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary provides a value that can be used to determine the fraction of packets lost for this [synchronization source (SSRC)](/en-US/docs/Web/API/RTCRemoteInboundRtpStreamStats/ssrc) in the last reporting interval.

To convert the value to a percentage, divide it by 256 and multiply by 100.
For example, a value of 20 indicates a 7.8% packet loss.

Note that the value may not be precisely accurate due to the way that it is calculated, but it does provides a quick and convenient measure of the link quality.

## Value

A number giving the fraction packet loss in the last reporting interval, multiplied by 256.
The value is 0 if the calculated packet loss is negative.

> [!NOTE]
> The value comes from the 8-bit `fraction lost` field of the last Sender Report (SR) or Receiver Report (RR) RTCP packet.
> The algorithm for calculating the value is defined in [RFC 3550, Appendix A.3: Determining Number of Packets Expected and Lost](https://datatracker.ietf.org/doc/html/rfc3550#appendix-A.3).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{rfc("3550","SR: Sender Report RTCP Packet", "6.4.1")}}
- {{rfc("3550","RR: Receiver Report RTCP Packet", "6.4.2")}}
# RTCRemoteInboundRtpStreamStats: id property

{{APIRef("WebRTC")}}

The **`id`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary is a string that uniquely identifies the object for which this object provides statistics.

Using the `id`, you can correlate this statistics object with others, in order to monitor statistics over time for a given WebRTC object, such as an {{domxref("RTCPeerConnection")}}, or an {{domxref("RTCDataChannel")}}.

## Value

A string that uniquely identifies the object for which this `RTCRemoteInboundRtpStreamStats` object provides statistics.

The format of the ID string is not defined by the specification, so you cannot reliably make any assumptions about the contents of the string, or assume that the format of the string will remain unchanged for a given object type.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteInboundRtpStreamStats

{{APIRef("WebRTC")}}

The **`RTCRemoteInboundRtpStreamStats`** dictionary of the [WebRTC API](/en-US/docs/Web/API/WebRTC_API) is used to report statistics from the remote endpoint about a particular incoming RTP stream.
These will correspond to an outgoing RTP stream at the local end of the {{domxref("RTCPeerConnection")}}.

The statistics can be obtained by iterating the {{domxref("RTCStatsReport")}} returned by {{domxref("RTCPeerConnection.getStats()")}} or {{domxref("RTCRtpReceiver.getStats()")}} until you find a report with the [`type`](/en-US/docs/Web/API/RTCRemoteInboundRtpStreamStats/type) of `remote-inbound-rtp`.

## Instance properties

### Remote inbound specific statistics

<!-- RTCRemoteInboundRtpStreamStats -->

- {{domxref("RTCRemoteInboundRtpStreamStats.fractionLost", "fractionLost")}} {{optional_inline}}
  - : A number indicating the fraction of packets lost for this SSRC since the last sender or receiver report.
- {{domxref("RTCRemoteInboundRtpStreamStats.localId", "localId")}} {{optional_inline}}
  - : A string that is used to find the local {{domxref("RTCOutboundRtpStreamStats")}} object that shares the same [synchronization source (SSRC)](/en-US/docs/Web/API/RTCRemoteInboundRtpStreamStats/ssrc).
- {{domxref("RTCRemoteInboundRtpStreamStats.roundTripTime", "roundTripTime")}} {{optional_inline}}
  - : A number that indicates the estimated round trip time (RTT) for this SSRC, in seconds.
    This property will not exist until valid RTT data has been received.
- {{domxref("RTCRemoteInboundRtpStreamStats.roundTripTimeMeasurements", "roundTripTimeMeasurements")}} {{optional_inline}}
  - : A positive integer indicating the total number of valid round trip time measurements received for this [synchronization source (SSRC)](/en-US/docs/Web/API/RTCRemoteInboundRtpStreamStats/ssrc).
- {{domxref("RTCRemoteInboundRtpStreamStats.totalRoundTripTime", "totalRoundTripTime")}} {{optional_inline}}
  - : A number indicating the cumulative sum of all round trip time measurements since the beginning of the session, in seconds.
    The average round trip time can be computed by dividing `totalRoundTripTime` by [`roundTripTimeMeasurements`](/en-US/docs/Web/API/RTCRemoteInboundRtpStreamStats/roundTripTimeMeasurements).

### Received RTP stream statistics

<!-- RTCReceivedRtpStreamStats -->

- {{domxref("RTCRemoteInboundRtpStreamStats.jitter", "jitter")}} {{optional_inline}}
  - : A number indicating the {{glossary("jitter", "packet jitter")}} for this synchronization source, measured in seconds.
- {{domxref("RTCRemoteInboundRtpStreamStats.packetsLost", "packetsLost")}} {{optional_inline}}
  - : An integer indicating the total number of RTP packets lost for this SSRC, as measured at the remote endpoint.
    This value can be negative if duplicate packets were received.
- {{domxref("RTCRemoteInboundRtpStreamStats.packetsReceived", "packetsReceived")}} {{optional_inline}} {{experimental_inline}}
  - : A positive integer indicating the total number of RTP packets received for this SSRC, including retransmissions.

### Common RTP stream statistics

<!-- RTCRtpStreamStats -->

- {{domxref("RTCRemoteInboundRtpStreamStats.codecId", "codecId")}} {{optional_inline}}
  - : A string that uniquely identifies the object that was inspected to produce the {{domxref("RTCCodecStats")}} object associated with this {{Glossary("RTP")}} stream.
- {{domxref("RTCRemoteInboundRtpStreamStats.kind", "kind")}}
  - : A string indicating whether the {{domxref("MediaStreamTrack")}} associated with the stream is an audio or a video track.
- {{domxref("RTCRemoteInboundRtpStreamStats.ssrc", "ssrc")}}
  - : A positive integer that identifies the SSRC of the RTP packets in this stream.
- {{domxref("RTCRemoteInboundRtpStreamStats.transportId", "transportId")}} {{optional_inline}}
  - : A string that uniquely identifies the object which was inspected to produce the {{domxref("RTCTransportStats")}} object associated with this RTP stream.

### Common instance properties

The following properties are common to all WebRTC statistics objects.

<!-- RTCStats -->

- {{domxref("RTCRemoteInboundRtpStreamStats.id", "id")}}
  - : A string that uniquely identifies the object that is being monitored to produce this set of statistics.
- {{domxref("RTCRemoteInboundRtpStreamStats.timestamp", "timestamp")}}
  - : A {{domxref("DOMHighResTimeStamp")}} object indicating the time at which the sample was taken for this statistics object.
- {{domxref("RTCRemoteInboundRtpStreamStats.type", "type")}}
  - : A string with the value `"inbound-rtp"`, indicating the type of statistics that the object contains.

## Examples

Given a variable `peerConnection` that is an instance of an {{domxref("RTCPeerConnection")}}, the code below uses `await` to wait for the statistics report, and then iterates it using `RTCStatsReport.forEach()`.
It then filters the dictionaries for just those reports that have the type of `remote-inbound-rtp` and logs the result.

```js
const stats = await myPeerConnection.getStats();

stats.forEach((report) => {
  if (report.type === "remote-inbound-rtp") {
    console.log("Remote Inbound RTP Stream Stats:");
    console.log(`id: ${report.id}`);
    console.log(`timestamp: ${report.timestamp}`);
    console.log(`transportId: ${report.transportId}`);
    console.log(`ssrc: ${report.ssrc}`);
    console.log(`kind: ${report.kind}`);
    console.log(`codecId: ${report.codecId}`);
    console.log(`packetsReceived: ${report.packetsReceived}`);
    console.log(`packetsLost: ${report.packetsLost}`);
    console.log(`jitter: ${report.jitter}`);
    console.log(`totalRoundTripTime: ${report.totalRoundTripTime}`);
    console.log(
      `roundTripTimeMeasurements: ${report.roundTripTimeMeasurements}`,
    );
    console.log(`roundTripTime: ${report.roundTripTime}`);
    console.log(`localId: ${report.localId}`);
    console.log(`fractionLost: ${report.fractionLost}`);
  }
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCStatsReport")}}
# RTCRemoteInboundRtpStreamStats: jitter property

{{APIRef("WebRTC")}}

The **`jitter`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary returns the {{glossary("Jitter", "packet jitter")}} for the [synchronization source (SSRC)](/en-US/docs/Web/API/RTCRemoteInboundRtpStreamStats/ssrc) as measured by the remote endpoint.

High packet jitter values indicate that packet arrival rates vary significantly, which may degrade video, audio, and other real-time communications over WebRTC.

## Value

Packet jitter, in seconds.

The value is calculated using the "interarrival jitter" algorithm described in {{RFC("3550", "", "6.4.1")}}.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCRemoteInboundRtpStreamStats.ssrc")}}
- {{domxref("RTCInboundRtpStreamStats.jitter")}}
# RTCRemoteInboundRtpStreamStats: kind property

{{APIRef("WebRTC")}}

The **`kind`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary is a string indicating whether the described {{Glossary("RTP")}} stream contains audio or video media.

This string will always be the same as the {{domxref("MediaStreamTrack.kind", "kind")}} of the {{domxref("MediaStreamTrack")}} object carried by the stream.
It will also match the media type of the codec associated with this statistics objects (i.e., the MIME type of the associated codec's {{domxref("RTCCodecStats.mimeType")}} property).

## Value

The kind is always one of:

- `"audio"`
  - : The stream contains audio media.
- `"video"`
  - : The stream contains video media.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteInboundRtpStreamStats: localId property

{{APIRef("WebRTC")}}

The {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary's **`localId`** property is a string that can be used to identify the {{domxref("RTCOutboundRtpStreamStats")}} object whose {{domxref("RTCOutboundRtpStreamStats.remoteId", "remoteId")}} matches this value.

Together, these two objects provide statistics about the inbound and outbound sides of the same [synchronization source (SSRC)](/en-US/docs/Web/API/RTCRemoteInboundRtpStreamStats/ssrc).

## Value

A string which can be compared to the value of an {{domxref("RTCOutboundRtpStreamStats")}} object's {{domxref("RTCOutboundRtpStreamStats.remoteId", "remoteId")}} property to see if the two represent statistics for each of the two sides of the same set of data sent by the local peer.

## Usage notes

You can think of the local and remote views of the same RTP stream as pairs, each of which has a reference back to the other one.
Thus, if an {{domxref("RTCStatsReport")}} includes an `remote-inbound-rtp` statistics object (of type `RTCRemoteInboundRtpStreamStats`), it should also have a corresponding `outbound-rtp` object.

Both of these provide information about the same batch of packets being sent from the local device to the remote peer.
The difference is that `outbound-rtp` offers statistics about the outgoing data from the local peer's perspective, while `remote-inbound-rtp` provides statistics about the same data from the perspective of the remote peer, as it is received.

## Examples

See the example in {{domxref("RTCRemoteOutboundRtpStreamStats.localId")}}.
This shows how to correlate statistics about data sent from the remote peer (from the perspective of the remote peer) with the incoming data from the perspective of the local peer.

The code to correlate send data from the perspective of the local peer and received data from the perspective of the remote peer would be almost the same, and can be inferred from that example.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteInboundRtpStreamStats: packetsLost property

{{APIRef("WebRTC")}}

The **`packetsLost`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary returns the total number of {{Glossary("RTP")}} packets lost from the [synchronization source (SSRC)](/en-US/docs/Web/API/RTCRemoteInboundRtpStreamStats/ssrc), as reported by the remote endpoint, since the beginning of reception.

## Value

An integer value indicating the number of lost RTP packets.

This value can be negative.
It is determined by subtracting the number of packets received from the number of packets that are expected.
The number of packets that are expected is calculated in a way that assumes that all packets only need to be sent once (based on sequence numbers), while the number of packets received also includes any packets that had to be resent (and hence may be bigger).
For more information see the "cumulative number of packets lost" section in {{RFC("3550", "", "6.4.1")}}.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCRemoteInboundRtpStreamStats.ssrc")}}
- {{domxref("RTCInboundRtpStreamStats.packetsLost")}}
# RTCRemoteInboundRtpStreamStats: packetsReceived property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`packetsReceived`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary returns the total number of {{Glossary("RTP")}} packets received from the [synchronization source (SSRC)](/en-US/docs/Web/API/RTCRemoteInboundRtpStreamStats/ssrc) of this stream by the remote endpoint, including retransmissions.

## Value

A positive integer value indicating the total number of received RTP packets at the remote endpoint.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCRemoteInboundRtpStreamStats.ssrc")}}
- {{domxref("RTCInboundRtpStreamStats.packetsReceived")}}
# RTCRemoteInboundRtpStreamStats: roundTripTime property

{{APIRef("WebRTC")}}

The **`roundTripTime`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary indicates the estimated round trip time (RTT) for this [synchronization source (SSRC)](/en-US/docs/Web/API/RTCRemoteInboundRtpStreamStats/ssrc), in seconds.

The round trip time is calculated based on the RTCP timestamps in the RTCP Sender Report (SR), and requires a report with a Delay Since Last SR (DLSR) block that has a value other than 0.
The property does not exist until such a report has been received.

Note that the _average_ RTT for the session can be computed by dividing {{domxref("RTCRemoteInboundRtpStreamStats.totalRoundTripTime","totalRoundTripTime")}} by {{domxref("RTCRemoteInboundRtpStreamStats.roundTripTimeMeasurements","roundTripTimeMeasurements")}}.

## Value

A number indicating the current estimated round trip time, in seconds.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{rfc("3550","SR: Sender Report RTCP Packet", "6.4.1")}}
# RTCRemoteInboundRtpStreamStats: roundTripTimeMeasurements property

{{APIRef("WebRTC")}}

The **`roundTripTimeMeasurements`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary contains a positive integer value that represents the total number valid round trip time measurements received for this [synchronizing source](/en-US/docs/Web/API/RTCRemoteInboundRtpStreamStats/ssrc).

The count can be used as a measure of the availability and reliability of round-trip-time measurement data.

## Value

A positive number indicating the number of valid round trip time measurements.

This is the count of _RTCP Receiver Reports (RR)_ received for this [synchronizing source](/en-US/docs/Web/API/RTCRemoteInboundRtpStreamStats/ssrc) that contain a non-zero value for the "delay since last SR (DLSR)" field.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{rfc("3550","RR: Receiver Report RTCP Packet", "6.4.2")}}
# RTCRemoteInboundRtpStreamStats: ssrc property

{{APIRef("WebRTC")}}

The **`ssrc`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary contains a positive integer value that identifies the synchronization source (SSRC) of this stream of {{Glossary("RTP")}} packets.

A source might be something like a microphone, or a mixer application that combines multiple sources.
All packets from the same source share the same time source and sequence space, and so can be ordered relative to each other.
Note that two streams with the same `ssrc` value refer to the same source.

## Value

A positive 32-bit integer uniquely identifying the SSRC of the RTP packets whose statistics are covered by this {{domxref("RTCRemoteInboundRtpStreamStats")}} object.

The manner in which SSRC values are generated is not mandated by the specification, although it does make recommendations.
You should not make any assumptions based on the value of `ssrc` other than that any two objects with the same `ssrc` value refer to the same source.
See {{RFC("3550", "", "8")}} for additional information about `ssrc`.

> [!NOTE]
> The specification includes an example that generates values for `ssrc` using MD5.
> While not part of the standard, exactly, it is a good mechanism that may be used by some browsers; others may use other methods, such as random number generators.
> _Do not_ rely upon these values meaning anything other than "these objects are associated with the same source."

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCRtpReceiver.getSynchronizationSources()")}}
- {{domxref("RTCEncodedAudioFrame.getMetadata()")}}
# RTCRemoteInboundRtpStreamStats: timestamp property

{{APIRef("WebRTC")}}

The **`timestamp`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary is a {{domxref("DOMHighResTimeStamp")}} object specifying the time at which the data in the object was sampled.

For this object the timestamp is the time at which the _RTCP Receiver Report (RR)_ was received at the local end of the communication (the RR report is defined in {{rfc("3550","", "6.4.2")}}).

## Value

A {{domxref("DOMHighResTimeStamp")}} value indicating the time at which the activity described by the statistics in this object was recorded, in milliseconds elapsed since the beginning of January 1, 1970, UTC.

The value should be accurate to within a few milliseconds but may not be entirely precise, either because of hardware or operating system limitations or because of [fingerprinting](/en-US/docs/Glossary/Fingerprinting) protection in the form of reduced clock precision or accuracy.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteInboundRtpStreamStats: totalRoundTripTime property

{{APIRef("WebRTC")}}

The **`totalRoundTripTime`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary indicates the cumulative number sum of all round trip time (RTT) measurements since the beginning of the session, in seconds.

The individual round trip time is calculated based on the RTCP timestamps in the RTCP Receiver Report (RR), hence requires a DLSR value other than 0.
The average RTT can be computed by dividing `totalRoundTripTime` by {{domxref("RTCRemoteInboundRtpStreamStats.roundTripTimeMeasurements","roundTripTimeMeasurements")}}.

## Value

A number indicating the total round trip time for the session, in seconds.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{rfc("3550","RR: Receiver Report RTCP Packet", "6.4.2")}}
# RTCRemoteInboundRtpStreamStats: transportId property

{{APIRef("WebRTC")}}

The **`transportId`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary is a string that uniquely identifies the associated {{domxref("RTCTransportStats")}} statistics object for this RTP stream's underlying transport.

`RTCRemoteInboundRtpStreamStats` and `RTCTransportStats` objects are correlated by iterating the {{domxref("RTCStatsReport")}} to find the statistics objects where `RTCRemoteInboundRtpStreamStats.transportId` is equal to {{domxref("RTCTransportStats.id")}}.

## Value

A string that contains the {{domxref("RTCTransportStats.id","id")}} of the object that was inspected to produce the {{domxref("RTCTransportStats")}} object associated with this RTP stream.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteInboundRtpStreamStats: type property

{{APIRef("WebRTC")}}

The **`type`** property of the {{domxref("RTCRemoteInboundRtpStreamStats")}} dictionary is a string with the value `"remote-inbound-rtp"`.

Different statistics are obtained by iterating the {{domxref("RTCStatsReport")}} object returned by a call to {{domxref("RTCPeerConnection.getStats()")}}.
The type indicates the set of statistics available through the object in a particular iteration step.
A value of `"inbound-rtp"` indicates that the statistics available in the current step are those defined in {{domxref("RTCRemoteInboundRtpStreamStats")}}.

## Value

A string with the value `"inbound-rtp"`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteOutboundRtpStreamStats: codecId property

{{APIRef("WebRTC")}}

The **`codecId`** property of the {{domxref("RTCRemoteOutboundRtpStreamStats")}} dictionary is a string that uniquely identifies the object that was inspected to produce the data in the {{domxref("RTCCodecStats")}} for the {{Glossary("RTP")}} stream.

`RTCRemoteOutboundRtpStreamStats` and `RTCCodecStats` objects are correlated by iterating the {{domxref("RTCStatsReport")}} to find the statistics objects where `RTCRemoteOutboundRtpStreamStats.codecId` is equal to {{domxref("RTCCodecStats.id")}}.

## Value

A string that contains the {{domxref("RTCCodecStats.id","id")}} of the object that was inspected to produce the {{domxref("RTCCodecStats")}} object associated with this RTP stream.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteOutboundRtpStreamStats: id property

{{APIRef("WebRTC")}}

The **`id`** property of the {{domxref("RTCRemoteOutboundRtpStreamStats")}} dictionary is a string that uniquely identifies the object for which this object provides statistics.

Using the `id`, you can correlate this statistics object with others, in order to monitor statistics over time for a given WebRTC object, such as an {{domxref("RTCPeerConnection")}}, or an {{domxref("RTCDataChannel")}}.

## Value

A string that uniquely identifies the object for which this `RTCRemoteOutboundRtpStreamStats` object provides statistics.

The format of the ID string is not defined by the specification, so you cannot reliably make any assumptions about the contents of the string, or assume that the format of the string will remain unchanged for a given object type.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteOutboundRtpStreamStats

{{APIRef("WebRTC")}}

The **`RTCRemoteOutboundRtpStreamStats`** dictionary of the [WebRTC API](/en-US/docs/Web/API/WebRTC_API) is used to report statistics from a remote endpoint about its outbound RTP stream.
This will correspond to an inbound stream that is currently being received by the local {{domxref("RTCPeerConnection")}} object.

The statistics can be obtained by iterating the {{domxref("RTCStatsReport")}} returned by {{domxref("RTCPeerConnection.getStats()")}} until you find a report with the [`type`](/en-US/docs/Web/API/RTCRemoteOutboundRtpStreamStats/type) of `remote-outbound-rtp`.

## Instance properties

### Remote outbound specific statistics

- {{domxref("RTCRemoteOutboundRtpStreamStats.localId", "localId")}} {{optional_inline}}
  - : A string which is used to find the local {{domxref("RTCInboundRtpStreamStats")}} object that shares the same [synchronization source (SSRC)](/en-US/docs/Web/API/RTCRemoteOutboundRtpStreamStats/ssrc).
- {{domxref("RTCRemoteOutboundRtpStreamStats.remoteTimestamp", "remoteTimestamp")}} {{optional_inline}}
  - : A {{domxref("DOMHighResTimeStamp")}} specifying the timestamp (on the remote device) at which the statistics in the `RTCRemoteOutboundRtpStreamStats` object were sent by the remote endpoint. This is different from the {{domxref("RTCRemoteOutboundRtpStreamStats.timestamp", "timestamp")}}; it represents the time at which the object's statistics were received or generated by the local endpoint.
- `reportsSent` {{optional_inline}} {{experimental_inline}}
  - : A positive integer indicating the total number of {{glossary("RTCP")}} Sender Report (SR) blocks sent for this [synchronization source (SSRC)](/en-US/docs/Web/API/RTCRemoteOutboundRtpStreamStats/ssrc).
- {{domxref("RTCRemoteOutboundRtpStreamStats.roundTripTimeMeasurements", "roundTripTimeMeasurements")}} {{optional_inline}} {{experimental_inline}}
  - : A positive number that represents the total number of valid round trip time measurements received for this [synchronization source (SSRC)](/en-US/docs/Web/API/RTCRemoteOutboundRtpStreamStats/ssrc).
- {{domxref("RTCRemoteOutboundRtpStreamStats.totalRoundTripTime", "totalRoundTripTime")}} {{optional_inline}} {{experimental_inline}}
  - : A number indicating the cumulative sum of all round trip time measurements since the beginning of the session, in seconds.
    The average round trip time can be computed by dividing `totalRoundTripTime` by [`roundTripTimeMeasurements`](/en-US/docs/Web/API/RTCRemoteOutboundRtpStreamStats/roundTripTimeMeasurements).

### Sent RTP stream statistics

<!-- RTCSentRtpStreamStats -->

- `bytesSent` {{optional_inline}}
  - : A positive integer indicating the total number of bytes sent for this SSRC, including retransmissions. <!-- [RFC3550] section 6.4.1 -->
- `packetsSent` {{optional_inline}}
  - : A positive integer indicating the total number of RTP packets sent for this SSRC, including retransmissions. <!-- [RFC3550] section 6.4.1 -->

### Common RTP stream statistics

<!-- RTCRtpStreamStats -->

- {{domxref("RTCRemoteOutboundRtpStreamStats.codecId", "codecId")}} {{optional_inline}}
  - : A string that uniquely identifies the object that was inspected to produce the {{domxref("RTCCodecStats")}} report associated with this {{Glossary("RTP")}} stream.
- {{domxref("RTCRemoteOutboundRtpStreamStats.kind", "kind")}}
  - : A string indicating whether the {{domxref("MediaStreamTrack")}} associated with the stream is an audio or a video track.
- {{domxref("RTCRemoteOutboundRtpStreamStats.ssrc", "ssrc")}}
  - : A positive integer that identifies the synchronization source (SSRC) of the RTP packets in this stream.
- {{domxref("RTCRemoteOutboundRtpStreamStats.transportId", "transportId")}} {{optional_inline}}
  - : A string that uniquely identifies the object that was inspected to produce the {{domxref("RTCTransportStats")}} report associated with this RTP stream.

### Common instance properties

The following properties are common to all WebRTC statistics objects.

<!-- RTCStats -->

- {{domxref("RTCRemoteOutboundRtpStreamStats.id", "id")}}
  - : A string that uniquely identifies the object that is being monitored to produce this set of statistics.
- {{domxref("RTCRemoteOutboundRtpStreamStats.timestamp", "timestamp")}}
  - : A {{domxref("DOMHighResTimeStamp")}} object indicating the time at which the sample was taken for this statistics object.
- {{domxref("RTCRemoteOutboundRtpStreamStats.type", "type")}}
  - : A string with the value `"remote-outbound-rtp"`, indicating the type of statistics that the object contains.

## Usage notes

The `RTCRemoteOutboundRtpStreamStats` object's {{domxref("RTCRemoteOutboundRtpStreamStats.remoteTimestamp", "remoteTimestamp")}} property provides statistics based on the received data's NTP timestamp taken from an {{Glossary("RTCP")}} Sender Report (SR) block.
Be aware that the remote clock may not be synchronized with the local clock (either in current time or speed at which time elapses).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteOutboundRtpStreamStats: kind property

{{APIRef("WebRTC")}}

The **`kind`** property of the {{domxref("RTCRemoteOutboundRtpStreamStats")}} dictionary is a string indicating whether the described {{Glossary("RTP")}} stream contains audio or video media.

This string will always be the same as the {{domxref("MediaStreamTrack.kind", "kind")}} of the {{domxref("MediaStreamTrack")}} object carried by the stream.
It will also match the statistics object's {{domxref("RTCCodecStats.codec")}} property's media type.

## Value

The kinds is always one of:

- `"audio"`
  - : The stream contains audio media.
- `"video"`
  - : The stream contains video media.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteOutboundRtpStreamStats: localId property

{{APIRef("WebRTC")}}

The {{domxref("RTCRemoteOutboundRtpStreamStats")}} dictionary's **`localId`** property is a string which can be used to identify the {{domxref("RTCInboundRtpStreamStats")}} object whose {{domxref("RTCInboundRtpStreamStats.remoteId", "remoteId")}} matches this value.

Together, these two objects provide statistics about the inbound and outbound sides of the same synchronization source (SSRC).

## Value

A string which can be compared to the value of an {{domxref("RTCInboundRtpStreamStats")}} object's {{domxref("RTCInboundRtpStreamStats.remoteId", "remoteId")}} property to see if the two represent statistics for each of the two sides of the same set of data received by the local peer.

## Usage notes

You can think of the local and remote views of the same RTP stream as pairs, each of which has a reference back to the other one.
Thus, if an {{domxref("RTCStatsReport")}} includes an `remote-outbound-rtp` statistics object (of type `RTCRemoteOutboundRtpStreamStats`), it should also have a corresponding `inbound-rtp` object.
Both of these provide information about the same batch of packets being transmitted from the remote peer to the local device.

The difference is that `remote-outbound-rtp` describes statistics about data sent by the remote peer from the perspective of the remote peer, while `inbound-rtp` offers statistics about the incoming data from the local peer's perspective.

## Examples

In this example, we have a pair of functions: the first, `networkTestStart()`, captures an initial report, and the second, `networkTestStop()`, captures a second report.
The second function uses the two reports to output some information about the network conditions.

### networkTestStart()

This function calls the {{domxref("RTCPeerConnection")}} method {{domxref("RTCPeerConnection.getStats", "getStats()")}} to request an {{domxref("RTCStatsReport")}} and store it in the variable `startReport`.

```js
let startReport;

async function networkTestStart(pc) {
  if (pc) {
    startReport = await pc.getStats();
  }
}
```

Given an {{domxref("RTCPeerConnection")}}, `pc`, this calls its {{domxref("RTCPeerConnection.getStats", "getStats()")}} method to obtain a statistics report object, which it stores in `startReport` for use once the end-of-test data has been collected by `networkTestStop()`.

### networkTestStop()

The `networkTestStop()` function obtains a second report, `endReport`, then computes and outputs the results.

#### Finding paired statistics

Each statistics record of {{domxref("RTCRemoteOutboundRtpStreamStats.type", "type")}} `remote-outbound-rtp` (describing a remote peer's statistics about sending data to the local peer) has a corresponding record of type `inbound-rtp` which describes the local peer's perspective on the same data being moved between the two peers.
Let's create a utility function to help us look up the value of a key in the paired statistics object.

The `findReportEntry()` function shown below examines an {{domxref("RTCStatsReport")}}, returning the {{domxref("RTCStatsReport")}}-based statistics record which contains the specified `key` — _and_ for which the key has the specified `value`.
If no match is found or the statistics report has no record corresponding to the statistics category indicated by `key`.

```js
function findReportEntry(report, key, value) {
  for (const stats of report.values()) {
    if (stats[key] === value) {
      return stats;
    }
  }
  return null;
}
```

Since the `RTCStatsReport` is a JavaScript [`Map`](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map), we can iterate over the map's [`values()`](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values) to examine each of the `RTCStats`-based statistics records in the report until we find one that has the `key` property with the specified `value`.
When a match is found, the statistics object is returned.

If no match is found, the function returns `null`.

#### The main networkTestStop() function

Now let's look at the `networkTestStop()` function itself. It takes as input the {{domxref("RTCPeerConnection")}} being tested, calls `getStats()` to get a new `RTCStatsReport` with current statistics, then computes the results it's looking for, outputting those results as appropriate to the user by appending appropriate HTML to the contents of the {{HTMLElement("div")}} element whose class is `stats-box`.

```js
async function networkTestStop(pc) {
  if (pc) {
    const statsBox = document.querySelector(".stats-box");
    const endReport = await pc.getStats();

    for (const endRemoteOutbound of endReport.values()) {
      if (endRemoteOutbound.type === "remote-outbound-rtp") {
        const startRemoteOutbound = startReport.get(endRemoteOutbound.id);

        if (startRemoteOutbound) {
          const startInboundStats = findReportEntry(
            startReport,
            "remoteId",
            startRemoteOutbound.id,
          );
          const endInboundStats = findReportEntry(
            endReport,
            "remoteId",
            endRemoteOutbound.id,
          );
          // Elapsed time in seconds
          const elapsedTime =
            (endRemoteOutbound.timestamp - startRemoteOutbound.timestamp) /
            1000;
          const packetsSent =
            endRemoteOutbound.packetsSent - startRemoteOutbound.packetsSent;
          const bytesSent =
            endRemoteOutbound.bytesSent - startRemoteOutbound.bytesSent;
          const framesDecoded =
            endInboundStats.framesDecoded - startInboundStats.framesDecoded;
          const frameRate = framesDecoded / elapsedTime;

          let timeString = "";
          if (!isNaN(elapsedTime)) {
            timeString = ` representing ${elapsedTime}s`;
          }

          let frameString = "";
          if (!isNaN(framesDecoded)) {
            frameString = `Decoded ${framesDecoded} frames for a frame rate of ${frameRate.toFixed(
              2,
            )} FPS.<br>`;
          }

          const logEntry =
            `<div class="stats-entry"><h2>Report ID: ${endRemoteOutbound.id}</h2>` +
            `Remote peer sent ${packetsSent} packets ${timeString}.<br>` +
            `${frameString}` +
            `Data size: ${bytesSent} bytes.</div>`;
          statsBox.innerHTML += logEntry;
        } else {
          statsBox.innerHTML += `<div class="stats-error">Unable to find initial statistics for ID ${endRemoteOutbound.id}.</div>`;
        }
      }

      statsBox.scrollTo(0, statsBox.scrollHeight);
    }
  }
}
```

Here's what's going on in the `networkTestStop()` function: after calling the {{domxref("RTCPeerConnection")}} method {{domxref("RTCPeerConnection.getStats", "getStats()")}} to get the latest statistics report for the connection and storing it in `endReport`.
This is an {{domxref("RTCStatsReport")}} object, which maps strings to objects of the corresponding {{domxref("RTCStatsReport")}}-based type.

Now we can begin to process the results, starting with the ending statistics found in `endReport`.
In this case, we're looking for statistics records whose `type` is `remote-outbound-rtp`, so we iterate over the entries in the statistics report until we find an entry of that type.
This object is, specifically, of type {{domxref("RTCRemoteOutboundRtpStreamStats")}}, and it provides statistics giving details about the state of things _from the perspective of the remote peer_.
This statistics record is stored in `endRemoteOutbound`.

Once the ending `remote-outbound-rtp` record is found, we use its {{domxref("RTCRemoteOutboundRtpStreamStats.id", "id")}} property to get its ID.
With that in hand, we can look up the `remote-outbound-rtp` record in the starting statistics record (`startReport`), which we store into `startRemoteOutbound`.

Now we obtain the `inbound-rtp` statistics that correspond to these two `remote-outbound-rtp` records by finding the `remoteId` property within them whose value is the ID of the `remote-outbound-rtp` record.
We use the `findReportEntry()` function described in the previous section for that, storing the located `inbound-rtp` records in `startInboundStats` and `endInboundStats`.

Now we have all the raw statistics needed to calculate the information we want to display, so we do so:

- We calculate the amount of time—`elapsedTime`—that elapsed between the two reports being sent by subtracting the {{domxref("RTCRemoteOutboundRtpStreamStats.timestamp", "timestamp")}} `startReport` from that of `endReport`.
  We then divide by 1000 to convert the result from milliseconds to seconds.
- We compute the number of packets sent during this interval—`packetsSent`—by subtracting the two reports' values for the {{domxref("RTCSentRtpStreamStats.packetsSent", "packetsSent")}} property.
- Similarly, the number of bytes sent during this interval—`bytesSent`—is calculated by subtracting the starting statistics object's {{domxref("RTCSentRtpStreamStats.bytesSent", "bytesSent")}} property from that of the ending statistics.
- The number of frames decoded during this interval—`framesDecoded`—is determined by subtracting `startRecord`'s {{domxref("RTCInboundRtpStreamStats.framesDecoded", "framesDecoded")}} from `endRecord.framesDecoded`.
- Finally, the frame rate over the elapsed time span is calculated by dividing `framesDecoded` by `elapsedTime`.

The remainder of the `networkTestStop()` function constructs the HTML used to display the output of the collected and computed results to the user, then append it to the element `statsBox`, which we're using to show the status updates to the user.

The output log, given the styles used by the example, looks like this:

![A screenshot of the example showing logged statistics taken from paired remote-outbound-rtp and inbound-rtp statistics records](rtc-log-screenshot.png)

In the screenshot, we see a heading followed by the scrollable {{HTMLElement("div")}} we refer to as `statsBox`.
The box contains a number of log entries, the last handful of which are visible.
Each one represents approximately one second of time (since that's much time we're waiting between calling `networkTestStart()` and `networkTestStop()`).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteOutboundRtpStreamStats: remoteTimestamp property

{{APIRef("WebRTC")}}

The {{domxref("RTCRemoteOutboundRtpStreamStats")}} property **`remoteTimestamp`** indicates the timestamp on the remote peer at which these statistics were sent.
This differs from `timestamp`, which indicates the time at which the statistics were generated or received locally.

## Value

A {{domxref("DOMHighResTimeStamp")}} value indicating the timestamp on the remote peer at which it sent these statistics.
This is different from the value `timestamp`, which gives the time at which the statistics were generated or received by the local peer.

If this property is present, it comes from the {{Glossary("RTCP")}} Sender Report (SR) block, which reflects the clock on the remote peer at the time the message was sent.
Keep in mind that this means the clock may not be synchronized with the local clock, and that both the current time and the pace at which the clock runs may differ to some extent.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteOutboundRtpStreamStats: roundTripTimeMeasurements property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`roundTripTimeMeasurements`** property of the {{domxref("RTCRemoteOutboundRtpStreamStats")}} dictionary is a positive integer value that represents the total number valid round of trip time measurements received for this [synchronizing source (SSRC)](/en-US/docs/Web/API/RTCRemoteOutboundRtpStreamStats/ssrc).

The count can be used as a measure of the availability and reliability of round trip time measurement data.

## Value

A positive number indicating the number of valid round trip time measurements.

This is the number of _RTCP Sender Reports (SR)_ received for this SSRC that contain a "delay since last RR (DLRR)" field from which a valid round trip time can be derived (according to {{rfc("3611","DLRR Report Block", "4.5")}}).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteOutboundRtpStreamStats: ssrc property

{{APIRef("WebRTC")}}

The **`ssrc`** property of the {{domxref("RTCRemoteOutboundRtpStreamStats")}} dictionary contains a positive integer value that identifies the synchronization source (SSRC) of this stream of {{Glossary("RTP")}} packets.

A source might be something like a microphone, or a mixer application that combines multiple sources.
All packets from the same source share the same time source and sequence space, and so can be ordered relative to each other.
Note that two streams with the same `ssrc` value refer to the same source.

## Value

A positive 32-bit integer uniquely identifying the SSRC of the RTP packets whose statistics are covered by this {{domxref("RTCRemoteOutboundRtpStreamStats")}} object.

The manner in which SSRC values are generated is not mandated by the specification, although it does make recommendations.
You should not make any assumptions based on the value of `ssrc` other than that any two objects with the same `ssrc` value refer to the same source.
See {{RFC("3550", "", "8")}} for additional information about `ssrc`.

> [!NOTE]
> The specification includes an example that generates values for `ssrc` using MD5.
> While not part of the standard, exactly, it is a good mechanism that may be used by some browsers; others may use other methods, such as random number generators.
> _Do not_ rely upon these values meaning anything other than "these objects are associated with the same source."

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCRtpReceiver.getSynchronizationSources()")}}
- {{domxref("RTCEncodedAudioFrame.getMetadata()")}}
# RTCRemoteOutboundRtpStreamStats: timestamp property

{{APIRef("WebRTC")}}

The **`timestamp`** property of the {{domxref("RTCRemoteOutboundRtpStreamStats")}} dictionary is a {{domxref("DOMHighResTimeStamp")}} object specifying the time at which the data in the object was sampled.

## Value

A {{domxref("DOMHighResTimeStamp")}} value indicating the time at which the activity described by the statistics in this object was recorded, in milliseconds elapsed since the beginning of January 1, 1970, UTC.

The value should be accurate to within a few milliseconds but may not be entirely precise, either because of hardware or operating system limitations or because of [fingerprinting](/en-US/docs/Glossary/Fingerprinting) protection in the form of reduced clock precision or accuracy.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteOutboundRtpStreamStats: totalRoundTripTime property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`totalRoundTripTime`** property of the {{domxref("RTCRemoteOutboundRtpStreamStats")}} dictionary indicates the sum of all round trip time (RTT) measurements since the beginning of the session, in seconds.

The individual round trip time is calculated based on RTCP timestamps in the DLRR report block of RTCP Sender Reports (SR).
The average RTT can be computed by dividing `totalRoundTripTime` by {{domxref("RTCRemoteOutboundRtpStreamStats.roundTripTimeMeasurements","roundTripTimeMeasurements")}}.

## Value

A number indicating the total round trip time for the session, in seconds.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{rfc("3611","DLRR Report Block", "4.5")}}
# RTCRemoteOutboundRtpStreamStats: transportId property

{{APIRef("WebRTC")}}

The **`transportId`** property of the {{domxref("RTCRemoteOutboundRtpStreamStats")}} dictionary is a string that uniquely identifies the associated {{domxref("RTCTransportStats")}} statistics object for this RTP stream's underlying transport.

`RTCRemoteOutboundRtpStreamStats` and `RTCTransportStats` objects are correlated by iterating the {{domxref("RTCStatsReport")}} to find the statistics objects where `RTCRemoteOutboundRtpStreamStats.transportId` is equal to {{domxref("RTCTransportStats.id")}}.

## Value

A string that contains the {{domxref("RTCTransportStats.id","id")}} of the object that was inspected to produce the {{domxref("RTCTransportStats")}} object associated with this RTP stream.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRemoteOutboundRtpStreamStats: type property

{{APIRef("WebRTC")}}

The **`type`** property of the {{domxref("RTCRemoteOutboundRtpStreamStats")}} dictionary is a string with the value `"remote-outbound-rtp"`.

Different statistics are obtained by iterating the {{domxref("RTCStatsReport")}} object returned by a call to {{domxref("RTCPeerConnection.getStats()")}}.
The type indicates the set of statistics available through the object in a particular iteration step.
A value of `"remote-outbound-rtp"` indicates that the statistics available in the current step are those defined in {{domxref("RTCRemoteOutboundRtpStreamStats")}}.

## Value

A string with the value `"remote-outbound-rtp"`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRtpReceiver: getCapabilities() static method

{{APIRef("WebRTC")}}

The _static method_ **`RTCRtpReceiver.getCapabilities()`** returns an object describing the codec and header extension capabilities supported by {{domxref("RTCRtpReceiver")}} objects on the current device.

You can, similarly, obtain the capabilities of {{domxref("RTCRtpSender")}} objects by calling the static function {{domxref("RTCRtpSender.getCapabilities_static", "RTCRtpSender.getCapabilities()")}}.

## Syntax

```js-nolint
RTCRtpReceiver.getCapabilities(kind)
```

### Parameters

- `kind`
  - : A string indicating the type of media for which the browser's receiver capabilities are requested.
    The supported media kinds are: `audio` and `video`.

### Return value

A new object that indicates what capabilities the browser has for receiving the specified media kind over an {{domxref("RTCPeerConnection")}}.
If the browser doesn't have any support for the given media `kind`, the returned value is `null`.

The returned object has the following properties:

- `codecs`
  - : An array of objects, each describing the basic capabilities of a single [media codec](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs) supported by the {{domxref("RTCRtpReceiver")}}.

    > [!NOTE]
    > The array contains special entries that represent the underlying components of the transport — these may be ignored if you're only interested in the actual codecs used for the media itself.
    > These are described below in the section [The codecs array](#the_codecs_array).

    Each codec object has the following properties:
    - `channels` {{optional_inline}}
      - : A positive integer value indicating the maximum number of channels supported by the codec; for example, a codec that supports only mono sound would have a value of 1; stereo codecs would have a 2, etc.
    - `clockRate`
      - : A positive integer specifying the codec's clock rate in Hertz (Hz).
        The IANA maintains a [list of codecs and their parameters](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-1), including their clock rates.
    - `mimeType`
      - : A string indicating the codec's MIME media type and subtype.
        The MIME type strings used by RTP differ from those used elsewhere.
        See {{RFC(3555, "", 4)}} for the complete IANA registry of these types.
        Also see [Codecs used by WebRTC](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs) for details about potential codecs that might be referenced here.
    - `sdpFmtpLine` {{optional_inline}}
      - : A string giving the format specific parameters field from the `a=fmtp` line in the SDP which corresponds to the codec, if such a line exists.
        If there is no parameters field, this property is left out.

- `headerExtensions`
  - : An array of objects, each providing the URI of a [header extension](https://datatracker.ietf.org/doc/html/rfc3550#section-5.3.1) supported for the current `kind` of media.
    Each object has the following property:
    - `uri`
      - : A string, specifying the URI of a header extension.
        The URI is formatted as described in {{RFC(5285)}}.

## Description

As a static function, this is always called using the form:

```js
capabilities = RTCRtpReceiver.getCapabilities("audio");
```

The returned set of capabilities is the most optimistic possible list.
It is entirely possible that certain combinations of options may fail to work when you actually try to use them.

Calling `RTCRtpReceiver.getCapabilities()` doesn't prime the browser in any way to handle media. Nothing is loaded, fetched, or otherwise prepared.
It's a means of determining what might be usable before starting to try to access media.

Because the set of capabilities available tend to be stable for a length of time (people don't install and uninstall codecs and the like very often), the media capabilities can in whole or in part provide a cross-origin method for identifying a user.
For that reason, in privacy-sensitive contexts, the browser may choose to obscure the capabilities; this might be done, for example, by leaving out rarely-used codec configurations.

### The codecs array

The `codecs` array is an array of objects that describes a single codec and its basic capabilities.
The browser will only report distinct capability combinations separately.
If two sets of capabilities can be described as one, they will be.
That means that, for instance, if there are two entries for the H.264 codec (as identified by the [`mimeType`](#mimetype) being "video/H264"), there are other values in the capabilities objects indicating how they're different in some way.

There are three special entries that should always be present, representing underlying components of the transport. Those components are:

- RED (REDundant Audio Data)
  - : The media type of an RED entry may vary due to there being several versions of it, but it will end with `red`, such as `video/red` or `video/fwdred`.
    The base RED standard can be found in {{RFC(2198)}}. There may be multiple entries for RED if different forms are supported; each will have a unique media type in that case.
- FEC (Forward Error Correction)
  - : An FEC component handles error correction data; its media type may also vary due to there being advanced versions of the standard available, but it will always end with `fec`.
    One possible value is `video/ulpfec` (a generic error connection model).
    There may also be multiple FEC entries if more than one form is supported.
- RTX (Retransmission)
  - : This component is responsible for retransmission of data; its media type should be `video/rtx`.
    There will only be one entry for RTX, and it will not have an [`sdpFmtpLine`](#sdpfmtpline) property.

These entries should be ignored if only codecs related to the media are of interest.

## Examples

### Feature support

You can use [`Object.hasOwn()`](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn) to check that `RTCRtpReceiver.getCapabilities()` is supported:

```html hidden
<p id="log"></p>
```

```js hidden
const log = document.querySelector("#log");
```

```js
log.textContent = `RTCRtpReceiver.getCapabilities() supported: ${Object.hasOwn(
  RTCRtpReceiver,
  "getCapabilities",
)}`;
```

{{ EmbedLiveSample('Feature support', '100%', '30px') }}

### Checking support for a particular codec

The function below returns a Boolean indicating whether or not the device supports receiving H.264 video on a WebRTC connection.

> [!NOTE]
> Since `RTCRtpReceiver.getCapabilities()` actually only indicates > _probable_ support, attempting to receive H.264 video might still fail even after getting a positive response from this function.

```js
function canReceiveH264() {
  let capabilities = RTCRtpReceiver.getCapabilities("video");

  capabilities.codecs.forEach((codec) => {
    if (codec.mimeType === "video/H264") {
      return true;
    }
  });
  return false;
}
```

### Getting all capabilities

This code example shows how we might get all supported codecs and headers.
The HTML defines a selection list for the two kinds of capabilities, and a log area.

```html
<select id="kind">
  <option value="audio">audio</option>
  <option value="video">video</option>
</select>
<textarea rows="40" cols="100" id="log"></textarea>
```

The JavaScript defines a function to log the capabilities for a particular "kind".
This is called initially with the value `audio`.
A listener updates the value when the selection list `kind` is changed.

```js
const log = document.querySelector("#log");
const kindSelector = document.querySelector("#kind");

logMediaCapabilities("audio");

kindSelector.addEventListener("click", () => {
  log.textContent = "";
  logMediaCapabilities(kindSelector.value);
});

function logMediaCapabilities(kind) {
  if (!Object.hasOwn(RTCRtpReceiver, "getCapabilities")) {
    log.textContent = "RTCRtpReceiver.getCapabilities() not supported";
    return;
  }
  const capabilities = RTCRtpReceiver.getCapabilities(`${kind}`);
  log.textContent += "Headers\n";
  capabilities.headerExtensions.forEach((header) => {
    log.textContent += ` uri: ${header.uri}\n`;
  });

  log.textContent += "\nCodecs\n";
  capabilities.codecs.forEach((codec) => {
    log.textContent += ` mime type: ${codec.mimeType}\n`;
    log.textContent += `   channels: ${codec.channels}\n`; // max channels - e.g. 2 is stereo
    log.textContent += `   clockRate: ${codec.clockRate}\n`; // clock rate in Hz
    log.textContent += `   sdpFmtpLine: ${codec.sdpFmtpLine}\n`; // mime media type and subtype
  });
}
```

#### Result

{{ EmbedLiveSample('Getting all capabilities', '100%', '500px') }}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRtpReceiver: getContributingSources() method

{{APIRef("WebRTC API")}}

The **`getContributingSources()`** method of the {{domxref("RTCRtpReceiver")}} interface returns an array of objects, each corresponding to one CSRC (contributing source) identifier received by the current `RTCRtpReceiver` in the last ten seconds.

## Syntax

```js-nolint
getContributingSources()
```

### Parameters

None.

### Return value

An array of objects, each describing one of the contributing sources that provided data to the incoming stream in the past ten seconds.
These objects contain the following properties:

- `audioLevel` {{optional_inline}}
  - : A floating-point value between 0.0 and 1.0 specifying the audio level contained in the last RTP packet played from the contributing source.

    The value is on a linear scale and is defined in units of dBov, or decibels (overload).
    This is the amplitude relative to the point at which clipping of the audio begins to occur.
    A value of 1.0 represents 0 dBov (maximum volume), a value of 0.0 represents silence, and a value of 0.5 represents approximately 6 dB SPL (decibels of sound pressure level) change in the sound pressure level from 0 dBov.

    If this property is not present then no volume level was provided by the source.

- `rtpTimestamp` {{optional_inline}}
  - : The RTP timestamp (an integer {{domxref("DOMHighResTimeStamp")}}) of the media.
    This source-generated timestamp indicates the time at which the media in this packet, scheduled for play out at the time indicated by `timestamp`, was initially sampled or generated.
    It may be useful for sequencing and synchronization purposes.

- `source` {{optional_inline}}
  - : A positive integer value specifying the CSRC identifier of the contributing source.
    This uniquely identifies the source of the particular stream RTP packets.

- `timestamp` {{optional_inline}}
  - : A {{domxref("DOMHighResTimeStamp")}} indicating the most recent time at which a frame originating from this source was delivered to the receiver's {{domxref("MediaStreamTrack")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRtpReceiver: getParameters() method

{{APIRef("WebRTC API")}}

The **`getParameters()`** method of the {{domxref("RTCRtpReceiver")}} interface returns an object describing the current configuration for how the receiver's {{domxref("RTCRtpReceiver.track", "track")}} is decoded.

## Syntax

```js-nolint
getParameters()
```

### Parameters

None.

### Return value

An object indicating the current configuration of the receiver.

<!-- Spec defines as RTCRtpReceiveParameters, which is just a RTCRtpParameters -->

- `codecs`
  - : An array of objects describing the [media codecs](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs) that the receiver is ready to use.
    This is the subset of codecs that the receiver has indicated it prefers and that the remote endpoint has indicated it is prepared to send.
    This parameter cannot be changed once initially set.

    Each codec object in the array may have the following properties: <!-- RTCRtpCodecParameters -->
    - `channels` {{optional_inline}}
      - : A positive integer indicating the number of channels supported by the codec.
        For example, for audio codecs a value of 1 specifies monaural sound, while 2 indicates stereo.

    - `clockRate`
      - : A positive integer specifying the codec's clock rate in Hertz (Hz).
        The clock rate is the rate at which the codec's RTP timestamp advances.
        Most codecs have specific values or ranges of values they permit.
        The IANA maintains a [list of codecs and their parameters](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-1), including their clock rates.

    - `mimeType`
      - : A string indicating the codec's MIME media type and subtype, specified as a string of the form `"type/subtype"`.
        The MIME type strings used by RTP differ from those used elsewhere.
        IANA maintains a [registry of valid MIME types](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-2).
        Also see [Codecs used by WebRTC](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs) for details about potential codecs that might be referenced here.

    - `payloadType`
      - : The [RTP payload type](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-1) used to identify this codec.

    - `sdpFmtpLine` {{optional_inline}}
      - : A string giving the format specific parameters field from the `a=fmtp` line in the {{Glossary("SDP")}} which corresponds to the codec {{Glossary("SDP")}} from the remote peer, if the field is present.
        If there is no parameters field, this property is left out.
        See [section 5.8 of the IETF specification for JSEP](https://datatracker.ietf.org/doc/html/draft-ietf-rtcweb-jsep-24#section-5.8) for more information.

- `headerExtensions`
  - : An array of zero or more RTP header extensions, each identifying an extension supported by the sender or receiver.
    Header extensions are described in {{RFC(3550, "", "5.3.1")}}. This parameter cannot be changed once initially set.
- `rtcp`
  - : An {{domxref("RTCRtcpParameters")}} object providing the configuration parameters used for {{Glossary("RTCP")}} on the sender or receiver.
    This parameter cannot be changed once initially set.

## Examples

This example obtains the canonical name (CNAME) being used for {{Glossary("RTCP")}} on an {{domxref("RTCRtpReceiver")}}.

```js
function getRtcpCNAME(receiver) {
  let parameters = receiver.getParameters();

  return parameters.rtcp.cname;
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRtpReceiver: getStats() method

{{APIRef("WebRTC")}}

The {{domxref("RTCRtpReceiver")}} method **`getStats()`** asynchronously requests an {{domxref("RTCStatsReport")}} object which provides statistics about incoming traffic on the owning {{domxref("RTCPeerConnection")}}, returning a {{jsxref("Promise")}} whose fulfillment handler will be called once the results are available.

## Syntax

```js-nolint
getStats()
```

### Parameters

None.

### Return value

A JavaScript {{jsxref("Promise")}} which is fulfilled once the statistics are available.
The promise's fulfillment handler receives as a parameter a {{domxref("RTCStatsReport")}} object containing the collected statistics.

The returned statistics include those from all streams which are coming in through the `RTCRtpReceiver`, as well as any of their dependencies.

These might include, for example, statistics with [types](/en-US/docs/Web/API/RTCStatsReport#the_statistic_types): [`inbound-rtp`](/en-US/docs/Web/API/RTCInboundRtpStreamStats), [`candidate-pair`](/en-US/docs/Web/API/RTCIceCandidatePairStats), [`local-candidate`](/en-US/docs/Web/API/RTCIceCandidateStats), [`remote-candidate`](/en-US/docs/Web/API/RTCIceCandidateStats).

## Examples

This simple example obtains the statistics for an `RTCRtpReceiver` and updates an element's {{domxref("HTMLElement/innerText", "innerText")}} to display the number of packets lost.

```js
receiver.getStats().then((stats) => {
  document.getElementById("lost-packets").innerText = stats.packetsLost;
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCStatsReport")}}
- {{domxref("RTCRtpSender.getStats()")}}
- {{domxref("RTCPeerConnection.getStats()")}}
# RTCRtpReceiver: getSynchronizationSources() method

{{APIRef("WebRTC API")}}

The **`getSynchronizationSources()`** method of the {{domxref("RTCRtpReceiver")}} interface returns an array of objects, each corresponding to one SSRC (synchronization source) identifier received by the current `RTCRtpReceiver` in the last ten seconds.

## Syntax

```js-nolint
getSynchronizationSources()
```

### Parameters

None.

### Return value

An array of objects, each describing one of the synchronization sources that provided data to the incoming stream in the past ten seconds.
These objects contain the following properties:

- `audioLevel`
  - : A floating-point value between 0.0 and 1.0 specifying the audio level contained in the last RTP packet played from the synchronization source.

    The value is on a linear scale and is defined in units of dBov, or decibels (overload).
    This is the amplitude relative to the point at which clipping of the audio begins to occur.
    A value of 1.0 represents 0 dBov (maximum volume), a value of 0.0 represents silence, and a value of 0.5 represents approximately 6 dB SPL (decibels of sound pressure level) change in the sound pressure level from 0 dBov.

    This value is required and always present.

- `rtpTimestamp` {{optional_inline}}
  - : The RTP timestamp (an integer {{domxref("DOMHighResTimeStamp")}}) of the media.
    This source-generated timestamp indicates the time at which the media in this packet, scheduled for play out at the time indicated by `timestamp`, was initially sampled or generated.
    It may be useful for sequencing and synchronization purposes.

- `source` {{optional_inline}}
  - : A positive integer value specifying the SSRC identifier of the synchronization source.
    This uniquely identifies the source of the particular stream RTP packets.

- `timestamp` {{optional_inline}}
  - : A {{domxref("DOMHighResTimeStamp")}} indicating the most recent time at which a frame originating from this source was delivered to the receiver's {{domxref("MediaStreamTrack")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRtpReceiver

{{APIRef("WebRTC")}}

The **`RTCRtpReceiver`** interface of the [WebRTC API](/en-US/docs/Web/API/WebRTC_API) manages the reception and decoding of data for a {{domxref("MediaStreamTrack")}} on an {{domxref("RTCPeerConnection")}}.

## Instance properties

- {{domxref("RTCRtpReceiver.jitterBufferTarget")}}
  - : A {{domxref("DOMHighResTimeStamp")}} that indicates an application's preferred hold time for media in the jitter buffer, allowing it influence the tradeoff between playout delay and the risk of running out of audio or video frames due to network jitter.
- {{domxref("RTCRtpReceiver.track")}} {{ReadOnlyInline}}
  - : Returns the {{domxref("MediaStreamTrack")}} associated with the current `RTCRtpReceiver` instance.
- {{domxref("RTCRtpReceiver.transport")}} {{ReadOnlyInline}}
  - : Returns the {{domxref("RTCDtlsTransport")}} instance over which the media for the receiver's track is received.
- {{domxref("RTCRtpReceiver.transform")}}
  - : An {{domxref("RTCRtpScriptTransform")}} is used to insert a transform stream ({{domxref("TransformStream")}}) running in a worker thread into the receiver pipeline, allowing stream transforms to be applied to incoming encoded video and audio frames.

### Obsolete properties

- `rtcpTransport` {{deprecated_inline}}
  - : This property has been removed; the RTP and RTCP transports have been combined into a single transport. Use the {{domxref("RTCRtpReceiver.transport", "transport")}} property instead.

## Static methods

- {{domxref("RTCRtpReceiver.getCapabilities_static", "RTCRtpReceiver.getCapabilities()")}}
  - : Returns the most optimistic view of the capabilities of the system for receiving media of the given kind.

## Instance methods

- {{domxref("RTCRtpReceiver.getContributingSources()")}}
  - : Returns an array that contains an object for each unique CSRC (contributing source) identifier received by the current `RTCRtpReceiver` in the last ten seconds.
- {{domxref("RTCRtpReceiver.getParameters()")}}
  - : Returns an object that contains information about how the RTC data is to be decoded.
- {{domxref("RTCRtpReceiver.getStats()")}}
  - : Returns a {{jsxref("Promise")}} whose fulfillment handler receives a {{domxref("RTCStatsReport")}} which contains statistics about the incoming streams and their dependencies.
- {{domxref("RTCRtpReceiver.getSynchronizationSources()")}}
  - : Returns an array that contains an object for each unique SSRC (synchronization source) identifier received by the current `RTCRtpReceiver` in the last ten seconds.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCStatsReport")}}
- {{domxref("RTCRtpSender")}}
- {{domxref("RTCPeerConnection.getStats()")}}
# RTCRtpReceiver: jitterBufferTarget property

{{APIRef("WebRTC API")}}

The **`jitterBufferTarget`** property of the {{domxref("RTCRtpReceiver")}} interface is a {{domxref("DOMHighResTimeStamp")}} that indicates the application's preferred duration, in milliseconds, for which the {{glossary("jitter","jitter buffer")}} should hold media before playing it out.

The application can use it to influence the tradeoff between playout delay and the risk of running out of audio or video frames due to network jitter.

## Value

A {{domxref("DOMHighResTimeStamp")}} that indicates the current jitter buffer target hold time, in milliseconds.

The value can be set to a positive value of no greater than 4000 milliseconds.

## Exceptions

- {{jsxref("RangeError")}}
  - : Thrown if the target is set to a negative value or a value that is greater than 4000 milliseconds.

## Description

The value of the attribute influences the amount of buffering done by the user agent, which in turn affects retransmissions and packet loss recovery.

Note that the attribute "influences" the jitter buffer target of the user agent, but does not directly set it.
The actual user agent jitter buffer target will vary between maximum and minimum allowed values that reflects a target range that the user agent can provide based on network conditions and memory constraints, and can change at any time.
The value returned by `jitterBufferTarget` is not affected by the actual target of the user agent.

The average jitter buffer delay can be calculated by dividing the {{domxref("RTCInboundRtpStreamStats.jitterBufferTargetDelay")}} by the {{domxref("RTCInboundRtpStreamStats.jitterBufferEmittedCount")}} .
In order to observe the effects of modifying the jitter buffer target you can track the change in the value of this average over time.
You can also compare to the {{domxref("RTCInboundRtpStreamStats.jitterBufferTargetDelay", "jitterBufferMinimumDelay")}} (or its average) in order to factor out the intrinsic network factors that affect the delay.

If `RTCRtpReceiver` audio and video tracks are synchronized, then the larger of the two receivers `jitterBufferTarget` should be used for both receivers.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRtpReceiver: track property

{{APIRef("WebRTC API")}}

The **`track`** read-only property of the
{{domxref("RTCRtpReceiver")}} interface returns the {{domxref("MediaStreamTrack")}}
associated with the current {{domxref("RTCRtpReceiver")}} instance.

## Value

A {{domxref("MediaStreamTrack")}} instance.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRtpReceiver: transform property

{{APIRef("WebRTC")}}

The **`transform`** property of the {{domxref("RTCRtpReceiver")}} object is used to insert a transform stream ({{domxref("TransformStream")}}) running in a worker thread into the receiver pipeline.
This allows stream transforms to be applied to encoded video and audio frames as they arrive from the packetizer (before they are played/rendered).

The transform that is to be added is defined using an {{domxref("RTCRtpScriptTransform")}} and its associated {{domxref("Worker")}}.
If the transform is set in the peer connection [`track` event](/en-US/docs/Web/API/RTCPeerConnection/track_event) handler, the transform stream will receive the first full incoming frame for the track.

### Value

A {{domxref("RTCRtpScriptTransform")}}<!-- or {{domxref("SFrameTransform")}} -->, or `null` if the receiver has no associated transform stream.

## Example

Note that this is part of a larger example in the guide topic [Using WebRTC Encoded Transforms](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms).

## Adding a transform for incoming frames

This example shows how you add a WebRTC encoded transform to modify an incoming stream.
The code assumes that there is an {{domxref("RTCPeerConnection")}} called `peerConnection` that is already connected to a remote peer.

To add a transform stream into the pipeline for incoming frames we need to construct an {{domxref("RTCRtpScriptTransform")}} and assign it to the receiver's `transform` property.
We can do this in the [`track` event](/en-US/docs/Web/API/RTCPeerConnection/track_event) handler as shown.
This event is fired on the peer connection whenever the remote end sends a track.
The `event.receiver` property is an {{domxref("RTCRtpReceiver")}}.

```js
const worker = new Worker("worker.js");
peerConnection.ontrack = (event) => {
  event.receiver.transform = new RTCRtpScriptTransform(worker, {
    someOption: "receiverTransform",
  });
};
```

Because the transform is constructed immediately after creation of the {{domxref("RTCRtpReceiver")}}, it will receive the first incoming frame.
The object passed as the second parameter in the {{domxref("RTCRtpScriptTransform")}} constructor is sent to the worker thread, and can be used by worker code to provide a different transform for the incoming frames than is used for outgoing frames.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Using WebRTC Encoded Transforms](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms)
- {{domxref("RTCRtpSender.transform")}}
# RTCRtpReceiver: transport property

{{APIRef("WebRTC")}}

The read-only **`transport`** property of an
{{domxref("RTCRtpReceiver")}} object provides the {{domxref("RTCDtlsTransport")}} object
used to interact with the underlying transport over which the receiver is exchanging
Real-time Transport Control Protocol ({{Glossary("RTCP")}}) packets.

This transport is responsible for receiving the data for the media on the receiver's
{{domxref("RTCRtpReceiver.track", "track")}}.

## Value

An {{domxref("RTCDtlsTransport")}} object representing the underlying transport being
used by the receiver to exchange packets with the remote peer, or `null` if
the receiver isn't yet connected to a transport.

## Description

When the `RTCRtpReceiver` is first created, the value of
`transport` is `null`. This is replaced with an
`RTCDtlsTransport` once the receiver's transport has been established.

Note that when bundling is in effect—that is, when the {{domxref("RTCPeerConnection")}}
was created with a configuration object whose `bundlePolicy` is `max-compat`
or `max-bundle`—multiple receivers may be sharing the same transport; in this
case, all of them are using the same connection to transmit and/or receive
{{Glossary("RTP")}} and {{Glossary("RTCP")}} packets.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRtpScriptTransform

{{APIRef("WebRTC")}}

The **`RTCRtpScriptTransform`** interface of the [WebRTC API](/en-US/docs/Web/API/WebRTC_API) is used to insert a [WebRTC Encoded Transform](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms) (a {{domxref("TransformStream")}} running in a worker thread) into the WebRTC sender and receiver pipelines.

## Constructor

- {{DOMxRef("RTCRtpScriptTransform.RTCRtpScriptTransform", "RTCRtpScriptTransform()")}}
  - : Creates a new instance of the `RTCRtpScriptTransform` object.

## Instance properties

None.

## Instance methods

None.

## Description

**`RTCRtpScriptTransform`** instances are constructed with a {{domxref("Worker")}}, in which the transform stream code will run, along with an (optional) `options` object and array of [transferrable object](/en-US/docs/Web/API/Web_Workers_API/Transferable_objects) that will be passed to the worker.
They are then added into incoming and outgoing RTC pipelines by assigning them to {{domxref("RTCRtpReceiver.transform")}} and {{domxref("RTCRtpSender.transform")}}, respectively.

On construction of this object, and whenever an encoded frame arrives, the {{domxref("DedicatedWorkerGlobalScope.rtctransform_event", "rtctransform")}} event is fired on the worker global object.
The event's `transformer` property is a {{DOMxRef("RTCRtpScriptTransformer")}}, the worker-side counterpart to the main-thread `RTCRtpScriptTransform`.
This has `readable` ({{domxref("ReadableStream")}}) and `writable` ({{domxref("WritableStream")}}) properties that have been shared from the main thread `RTCRtpScriptTransform` — where they are not public.
If the corresponding `RTCRtpScriptTransform` is used with an `RTCRtpReceiver`, then the `readable` queues incoming encoded audio or video frames from the packetizer.
If it is used with `RTCRtpSender` then `readable` contains frames coming from a codec.

The worker thread {{domxref("DedicatedWorkerGlobalScope.rtctransform_event", "rtctransform")}} event handler defines a [pipe chain](/en-US/docs/Web/API/Streams_API/Concepts#pipe_chains).
This pipes encoded frames from `event.transformer.readable`, through a {{DOMxRef("TransformStream")}} which defines the transformation function, through to `event.transformer.writable`.
The `event.transformer` also has the `options` object passed from the `RTCRtpScriptTransform` constructor (if defined) that can be used to determine the source of the event, and hence the specific {{DOMxRef("TransformStream")}} to add to the chain.

## Examples

Note that these examples show how `RTCRtpScriptTransform` is defined and used.
Worker thread transform code is covered as part of the more complete example in [Using WebRTC Encoded Transforms](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms).

### Adding a transform for outgoing frames

This example shows how you might stream video from a user's webcam over WebRTC, adding a WebRTC encoded transform to modify the outgoing streams.
The code assumes that there is an {{domxref("RTCPeerConnection")}} called `peerConnection` that is already connected to a remote peer.

First we gets a {{domxref("MediaStreamTrack")}}, using {{domxref("MediaDevices/getUserMedia", "getUserMedia()")}} to get a video {{domxref("MediaStream")}} from a media device, and then the {{domxref("MediaStream.getTracks()")}} method to get the first {{domxref("MediaStreamTrack")}} in the stream.

The track is added to the peer connection using {{domxref("RTCPeerConnection/addTrack()", "addTrack()")}} and sent.
The `addTrack()` method returns the {{domxref("RTCRtpSender")}} that is being used to send the track.

```js
// Get Video stream and MediaTrack
const stream = await navigator.mediaDevices.getUserMedia({ video: true });
const [track] = stream.getTracks();
const videoSender = peerConnection.addTrack(track, stream);
```

An `RTCRtpScriptTransform` is then constructed taking a worker script, which defines the transform, and an optional object that can be used to pass arbitrary messages to the worker (in this case we've used a `name` property with value "senderTransform" to tell the worker that this transform will be added to the outbound stream).
We then add the transform to the sender by assigning it to the {{domxref("RTCRtpSender.transform")}} property.

```js
// Create a worker containing a TransformStream
const worker = new Worker("worker.js");
videoSender.transform = new RTCRtpScriptTransform(worker, {
  name: "senderTransform",
});
```

Note that you can add the transform at any time.
However by adding it immediately after calling `addTrack()` the transform will get the first encoded frame that is sent.

### Adding a transform for incoming frames

This example shows how you add a WebRTC encoded transform to modify an incoming stream.
The code assumes that there is an {{domxref("RTCPeerConnection")}} called `peerConnection` that is already connected to a remote peer.

First we add an `RTCPeerConnection` [`track` event](/en-US/docs/Web/API/RTCPeerConnection/track_event) handler to catch the event when a new track is streamed.
Within the handler we construct an `RTCRtpScriptTransform` and add it to `event.receiver.transform` (`event.receiver` is a {{domxref("RTCRtpReceiver")}}).
As in the previous example, the constructor takes an object with `name` property: but here we use `receiverTransform` as the value to tell the worker that frames are incoming from the packetizer.

```js
peerConnection.ontrack = (event) => {
  const worker = new Worker("worker.js");
  event.receiver.transform = new RTCRtpScriptTransform(worker, {
    name: "receiverTransform",
  });
  received_video.srcObject = event.streams[0];
};
```

Note again that you can add the transform stream at any time.
However by adding it in the `track` event handler ensures that the transform stream will get the first encoded frame for the track.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Using WebRTC Encoded Transforms](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms)
- {{domxref("TransformStream")}}
- {{domxref("RTCRtpScriptTransformer")}}
# RTCRtpScriptTransform: RTCRtpScriptTransform() constructor

{{APIRef("WebRTC")}}

The **`RTCRtpScriptTransform()`** constructor creates a new {{domxref("RTCRtpScriptTransform")}} object.

Constructing the `RTCRtpScriptTransform` creates a counterpart {{domxref("RTCRtpScriptTransformer")}} in the specified worker, along with passed options (if any). Objects in the third parameter to the constructor are transferred.

The {{domxref("DedicatedWorkerGlobalScope.rtctransform_event", "rtctransform")}} event is then fired at the worker global object.
Worker code can use the `event.transformer` property to get the counterpart {{domxref("RTCRtpScriptTransformer")}}, and `event.transformer.options` is used to get the options.

Note that the options are primarily used to inform the worker whether the transformer is processing incoming or outgoing frames, so that it can apply an appropriate transform.

## Syntax

```js-nolint
new RTCRtpScriptTransform(worker)
new RTCRtpScriptTransform(worker, options)
new RTCRtpScriptTransform(worker, options, transfer)
```

### Parameters

- `worker`
  - : A {{domxref("Worker")}}, which will define code for one or more WebRTC transform streams.
- `options` {{optional_inline}}
  - : An arbitrary object that will be made available in the worker.
    This is most commonly used to inform the worker whether it injected into the WebRTC sender or receiver pipeline, and hence which transform should be applied.
    However it may also be used to send any other object, such as a {{domxref("MessagePort")}} for communicating dynamically with the transformer.
- `transfer` {{optional_inline}}
  - : An optional [array](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) of [transferable objects](/en-US/docs/Web/API/Web_Workers_API/Transferable_objects) that will be transferred to the worker.
    After transfer, these objects are unusable in the main thread.

### Exceptions

- `DataCloneError` {{domxref("DOMException")}}
  - : Thrown if an object in `transfer` cannot be transferred.

## Examples

The first example below shows construction of a {{domxref("RTCRtpScriptTransform")}} that is then assigned to a {{domxref("RTCRtpSender.transform")}}.
The constructor takes an optional object with the property `name` and `senderTransform`.
The worker can use this option to understand when it is transforming encoded frames from the encoder (rather than incoming frames from the packetizer).

```js
// Create a worker containing a TransformStream
const worker = new Worker("worker.js");
videoSender.transform = new RTCRtpScriptTransform(worker, {
  name: "senderTransform",
});
```

Any property name and value can be used in the options, as long as they can be serialized (and [transferred](/en-US/docs/Web/API/Web_Workers_API/Transferable_objects) if specified in the last constructor parameter).
The code below transfers the second port of a {{domxref("MessageChannel")}} to the worker, which we might do in order to dynamically update transform code with (say) a new encryption key.

```js
// Create a worker containing a TransformStream
const worker = new Worker("worker.js");
const channel = new MessageChannel();

const transform = new RTCRtpScriptTransform(
  worker,
  { purpose: "encrypt", port: channel.port2 },
  [channel.port2],
);
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Using WebRTC Encoded Transforms](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms)
- {{domxref("RTCRtpSender.transform")}}
- {{domxref("RTCRtpReceiver.transform")}}
# RTCRtpScriptTransformer: generateKeyFrame() method

{{APIRef("WebRTC")}}

The **`generateKeyFrame()`** method of the {{domxref("RTCRtpScriptTransformer")}} interface causes a video encoder to generate a key frame.

## Syntax

```js-nolint
generateKeyFrame()
generateKeyFrame(rid)
```

### Parameters

- `rid` {{optional_inline}}
  - : A string containing the "restriction identifier" ("RID") of the stream/encoder that must generate the new key frame.

    The value must have between 1 and 255 characters (inclusive), and contain only the alphanumeric characters, underscore, and hyphen (`A-Z`, `a-z`, `0-9`, `-`, `_`).
    RIDs are case sensitive and must be unique for the peer communication channel.
    <!-- RFC8851 allows '-' and '_' and unlimited length. RFC 8852 disagrees (https://www.rfc-editor.org/errata/eid7132) -->

    The first encoder that matches the specified `rid` is used.
    If no encoder matches the `rid` then the first encoder is used, and `rid` is set to the encoder's restrictions.

### Return value

A {{jsxref("Promise")}} that fulfills with the timestamp of the frame, or rejects with an exception value.

### Exceptions

- `InvalidStateError`
  - : The encoder is not processing video frames, or is `undefined`.
- `TypeError`
  - : The provided `rid` but does not conform to the grammar requirements.
- `NotFoundError`
  - : There are no video encoders. This might be raised if the corresponding `RTCRtpSender` is not active or its track is ended.

## Description

This method can be called by a transformer that is processing outgoing encoded video frames to force a new complete (key) frame to be sent.
It might be needed by a [WebRTC Encoded Transform](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms) that encrypts frames, to ensure that if a new encryption key is added, a key frame encrypted with that key is sent as soon as possible.

The sender can specify a RID (also referred to as a "restriction identifier" or "RTP stream ID") to control what codec generates the new key frame.
A stream might contain (simulcast) multiple versions of the same source, each with different properties such as resolution and frame rate.
The RID is used to indicate a specific RTP stream, and hence the encoder that needs to generate a new frame.
Note that the available RID values are set when the transceiver used by the connection is created.
The RID values being used can be queried by calling {{domxref("RTCRtpSender.getParameters()")}} and inspecting the [`encodings`](/en-US/docs/Web/API/RTCRtpSender/getParameters#encodings) property of the returned value.

The promise returned by the method will resolve just before enqueuing the corresponding key frame in a `RTCRtpScriptTransformer` readable.

> [!NOTE]
> Sending multiple streams (RID) at a time is called "simulcast".
> This feature provides a [middlebox](https://en.wikipedia.org/wiki/Middlebox) with the same stream in multiple levels of video quality, allowing it to manage bandwidth by selectively transmitting appropriate levels to participants and switch resolution rapidly on the fly (i.e., switching to forward low-quality video for everyone except the active speaker).
> The recipient only ever gets one stream, which is why the comparable receiver method {{domxref("RTCRtpScriptTransformer.sendKeyFrameRequest()")}} does not require that an RID is specified.

## Examples

### Sending a key frame

The example below shows how the main thread might pass an encryption key to a sender transform, and trigger the codec to generate a key frame.

Note that the main thread doesn't have direct access to the {{domxref("RTCRtpScriptTransformer")}} object, so it needs to pass the key and RID to the worker.
Here we do that with a `MessageChannel`, transferring the second port to the transformer code running in the worker.
The code assumes there is already a peer connection, and `videoSender` is an {{domxref("RTCRtpSender")}}.

```js
const worker = new Worker("worker.js");
const channel = new MessageChannel();

videoSender.transform = new RTCRtpScriptTransform(
  worker,
  { name: "senderTransform", port: channel.port2 },
  [channel.port2],
);

// Post RID and new key to the sender
channel.port1.start();
channel.port1.postMessage({
  rid: "1",
  key: "93ae0927a4f8e527f1gce6d10bc6ab6c",
});
```

The {{domxref("DedicatedWorkerGlobalScope/rtctransform_event", "rtctransform")}} event handler in the worker gets the port and uses it to listen for `message` events.
If an event is received it gets the `rid` and `key`, and then calls `generateKeyFrame()`.

```js
event.transformer.options.port.onmessage = (event) => {
  const { rid, key } = event.data;
  // key is used by the transformer to encrypt frames (not shown)

  // Get codec to generate a new key frame using the rid
  // Here 'rcEvent' is the rtctransform event.
  rcEvent.transformer.generateKeyFrame(rid);
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Using WebRTC Encoded Transforms](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms)
# RTCRtpScriptTransformer

{{APIRef("WebRTC")}}

The **`RTCRtpScriptTransformer`** interface of the [WebRTC API](/en-US/docs/Web/API/WebRTC_API) provides a worker-side [Stream API](/en-US/docs/Web/API/Streams_API) interface that a [WebRTC Encoded Transform](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms) can use to modify encoded media frames in the incoming and outgoing WebRTC pipelines.

> [!NOTE]
> This feature is available in [_Dedicated_ Web Workers](/en-US/docs/Web/API/Web_Workers_API#worker_types).

## Instance properties

- {{domxref("RTCRtpScriptTransformer.readable")}} {{ReadOnlyInline}}
  - : A {{domxref("ReadableStream")}} on which encoded frames from the WebRTC sender or receiver pipelines may be enqueued.
- {{domxref("RTCRtpScriptTransformer.writable")}} {{ReadOnlyInline}}
  - : A {{domxref("WritableStream")}} that encoded frames should be piped to.
- {{domxref("RTCRtpScriptTransformer.options")}} {{ReadOnlyInline}}
  - : Options passed from the [`RTCRtpScriptTransform` constructor](/en-US/docs/Web/API/RTCRtpScriptTransform/RTCRtpScriptTransform), which are used to configure transform code based on whether incoming or outgoing frames are being processed.

## Instance methods

- {{domxref("RTCRtpScriptTransformer.generateKeyFrame()")}}
  - : Requests a video encoder generate a key frame. May be called by a transformer in the sender pipeline when processing outgoing frames.
- {{domxref("RTCRtpScriptTransformer.sendKeyFrameRequest()")}}
  - : Requests the sender send a key frame. May be called by a transformer in the receiver pipeline when processing incoming encoded video frames.

## Description

A `RTCRtpScriptTransformer` instance is created as part of construction of an associated {{DOMxRef("RTCRtpScriptTransform")}}, which specifies the worker in which the transformer is created and options that will be passed to it.

The transformer is made available to a worker through the {{domxref("DedicatedWorkerGlobalScope.rtctransform_event", "rtctransform")}} event `transformer` property.
This event is fired on construction of the associated {{DOMxRef("RTCRtpScriptTransform")}} and when an encoded frame is enqueued on the {{domxref("RTCRtpScriptTransformer.readable")}} from a codec (outgoing) or from the packetizer (incoming).

The transformer exposes a {{domxref("RTCRtpScriptTransformer.readable","readable")}} and {{domxref("RTCRtpScriptTransformer.writable","writable")}} stream into the worker, along with an {{domxref("RTCRtpScriptTransformer.options", "options")}} object provided to the {{DOMxRef("RTCRtpScriptTransform")}} on construction.
When the associated `RTCRtpScriptTransform` is assigned to a {{DOMxRef("RTCRtpSender")}} or {{DOMxRef("RTCRtpReceiver")}}, encoded media frames from the WebRTC sender or receiver pipelines are enqueued on the `readable` stream.

A WebRTC Encoded Transform must read encoded frames from `transformer.readable`, modify them as needed, and write them to `transformer.writable` in the same order, and without any duplication.
The {{domxref("RTCRtpScriptTransformer.options","transformer.options")}} allow an appropriate transform function to be used, based on whether the encoded media frames are incoming or outgoing.
The transform is usually implemented by piping frames from the `readable` through one or more {{DOMxRef("TransformStream")}} instances to the `writable`, transforming them as needed.

The interface also provides methods for a sender to generate get a video encoder to generate a new keyframe, or for a receiver to request a new key frame from the sender's encoder (video encoders commonly send a key frame containing the full information needed to construct an image, and subsequently send delta frames containing just the information that has changed since the previous frame).

These methods are required in cases where a recipient would be unable to decode incoming frames until they receive a new key frame.
For example, a new recipient joining a conference call will not be able see video until they have received a new key frame, since delta frames can only be decoded if you have the last key frame and all subsequent delta frames.
Similarly, if frames are encrypted for a recipient, they will only be able to decode frames once they have received their first encrypted key frame.

## Examples

This example shows the code for a WebRTC Encoded Transform running in a worker.

The code uses `addEventListener()` to register a handler function for the {{domxref("DedicatedWorkerGlobalScope.rtctransform_event", "rtctransform")}} event, which makes the **`RTCRtpScriptTransformer`** available as `event.transformer`.

The handler creates a {{DOMxRef("TransformStream")}} and pipes frames from the `event.transformer.readable` through it to `event.transformer.writable`.
The transform stream `transform()` implementation is called for each encoded frame queued on the stream: it can read the data from the frame and in this case negates the bytes and then enqueues the modifiable frame on the stream.

```js
addEventListener("rtctransform", (event) => {
  const transform = new TransformStream({
    start() {}, // Called on startup.
    flush() {}, // Called when the stream is about to be closed.
    async transform(encodedFrame, controller) {
      // Reconstruct the original frame.
      const view = new DataView(encodedFrame.data);

      // Construct a new buffer
      const newData = new ArrayBuffer(encodedFrame.data.byteLength);
      const newView = new DataView(newData);

      // Negate all bits in the incoming frame
      for (let i = 0; i < encodedFrame.data.byteLength; ++i) {
        newView.setInt8(i, ~view.getInt8(i));
      }

      encodedFrame.data = newData;
      controller.enqueue(encodedFrame);
    },
  });
  event.transformer.readable
    .pipeThrough(transform)
    .pipeTo(event.transformer.writable);
});
```

The only special things to note about the {{DOMxRef("TransformStream")}} above are that it queues encoded media frames ({{domxref("RTCEncodedVideoFrame")}} or {{domxref("RTCEncodedAudioFrame")}}) rather than arbitrary "chunks", and that `writableStrategy` and `readableStrategy` properties are not defined (because the queuing strategy is entirely managed by the user agent).

A transform can run in either the incoming or outgoing WebRTC pipelines.
This doesn't matter in the code above, because the same algorithm might be used in the sender to negate the frames, and in the receiver to revert them.
If the sender and receiver pipelines need to apply a different transform algorithm then information about the current pipeline must be passed from the main thread.
This is done by setting an `options` argument in the corresponding [`RTCRtpScriptTransform` constructor](/en-US/docs/Web/API/RTCRtpScriptTransform/RTCRtpScriptTransform#options), which is then made available to the worker in {{domxref("RTCRtpScriptTransformer.options")}}.

Below we use the `transformer.options` to choose either a sender transform or a receiver transform.
Note that the properties of the object are arbitrary (provided the values can be serialized) and it is also possible to transfer a {{domxref("MessageChannel")}} and use it to [communicate with a transform at runtime](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms#runtime_communication_with_the_transform) in order to, for example, share encryption keys.

```js
// Code to instantiate transform and attach them to sender/receiver pipelines.
onrtctransform = (event) => {
  let transform;
  if (event.transformer.options.name === "senderTransform")
    transform = createSenderTransform();
  // returns a TransformStream (not shown)
  else if (event.transformer.options.name === "receiverTransform")
    transform = createReceiverTransform();
  // returns a TransformStream (not shown)
  else return;
  event.transformer.readable
    .pipeThrough(transform)
    .pipeTo(event.transformer.writable);
};
```

Note that the above code is part of more complete examples provided in [Using WebRTC Encoded Transforms](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Using WebRTC Encoded Transforms](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms)
- {{domxref("TransformStream")}}
# RTCRtpScriptTransformer: options property

{{APIRef("WebRTC")}}

The **`options`** read-only property of the {{domxref("RTCRtpScriptTransformer")}} interface returns the object that was (optionally) passed as the second argument [during construction](/en-US/docs/Web/API/RTCRtpScriptTransform/RTCRtpScriptTransform) of the corresponding {{domxref("RTCRtpScriptTransform")}}.

## Value

An object.

## Description

The simplest use of options is for the main thread to indicate whether the corresponding {{domxref("RTCRtpScriptTransform")}} is to be added to the WebRTC sender or receiver pipeline. This is important if the same worker is used for processing both incoming and outgoing encoded frames, as it allows code to determine what transform should be applied to the frames.

Options can also be used to send/transfer the second port of a [message channel](/en-US/docs/Web/API/Channel_Messaging_API) to the worker-side transform.
This channel can then be used to send dynamic information to a transform stream, such as when encryption keys are changed or added.
Note that you might also send messages to the transform using {{domxref("Worker.postMessage()")}}, but you would then have to appropriately redirect the messages if the worker is used in different contexts (while a message port option provides a direct channel for a specific transform).

## Examples

### How to indicate the current WebRTC pipeline

{{domxref("RTCRtpScriptTransform")}} is constructed with a particular {{domxref("Worker")}} and options, and then inserted into either the WebRTC outgoing or incoming pipeline by assigning it to {{domxref("RTCRtpSender.transform")}} or {{domxref("RTCRtpReceiver.transform")}}, respectively.
If the same worker is used in the transforms for the incoming and outgoing pipeline, then you need to supply options in the constructor to indicate whether encoded frames to be transformed are incoming or outgoing.

The example below shows how this might be done for a `RTCRtpScriptTransform` added to the sender pipeline after adding a track to the peer connection ({{domxref("RTCPeerConnection")}}), and then adding another transform to the receiver pipeline when a track is received.

```js
// videoSender is an RTCRtpSender.
const videoSender = peerConnection.addTrack(track, mediaStream);
videoSender.transform = new RTCRtpScriptTransform(worker, {
  name: "senderTransform",
});
```

```js
peerConnection.ontrack = (event) => {
  // event.receiver is an RTCRtpReceiver
  event.receiver.transform = new RTCRtpScriptTransform(worker, {
    someOption: "receiverTransform",
  });
};
```

In each case above we supply an object with a different value for the option object's `name` property, which indicates the pipeline that the transform was added to.
Note that the names and values of properties in `options` is arbitrary: what matters is that the main thread and worker thread both know what properties and values are used.

The following code how the passed options are used in the worker.
First we implement a handler for the {{domxref("DedicatedWorkerGlobalScope.rtctransform_event", "rtctransform")}} event, which is fired at the global worker object on construction of the corresponding {{domxref("RTCRtpScriptTransform")}}, and when new frames are enqueued for processing.
`event.transformer` is a {{domxref("RTCRtpScriptTransformer")}} that has a `readable`, `writable`, and `options` property.

```js
addEventListener("rtctransform", (event) => {
  let transform;
  // Select a transform based on passed options
  if (event.transformer.options.name === "senderTransform")
    transform = createSenderTransform(); // A TransformStream
  else if (event.transformer.options.name === "receiverTransform")
    transform = createReceiverTransform(); // A TransformStream
  else return;

  // Pipe frames from the readable to writeable through TransformStream
  event.transformer.readable
    .pipeThrough(transform)
    .pipeTo(event.transformer.writable);
});
```

The code creates a different {{domxref("TransformStream")}} to process outgoing and incoming frames, using `createSenderTransform()` or `createReceiverTransform()`, based on the passed options (it then pipes frames from the `readable`, through the selected `TransformStream`, to the `writable`).

### Passing a message port to a transform

This example shows how to create a [message channel](/en-US/docs/Web/API/Channel_Messaging_API) and transfer one of its ports to the WebRTC encoded transform running in the worker. This main thread can then send and transfer objects and messages to the transformer running in the worker after construction, and vice versa.

The code below first creates a {{domxref("MessageChannel")}} and then constructs a `RTCRtpScriptTransform` passing the {{domxref("MessageChannel.port2","port2")}} value as an property in the options argument.
The port is also included in the array passed as the third constructor argument, so that it is transferred into the worker context.

```js
const channel = new MessageChannel();

const transform = new RTCRtpScriptTransform(
  worker,
  { purpose: "encrypter", port: channel.port2 },
  [channel.port2],
);
```

The worker can then get the port from the `rtctransform` event fired at the global worker object.

```js
let messagePort;
addEventListener("rtctransform", (event) => {
  messagePort = event.transformer.options.port;
  // … other transformer code
});
```

Code in each end of the channel can send and transfer objects to the other end using {{domxref("MessagePort.postMessage()")}}, and listen for incoming messages using its {{domxref("MessagePort/message_event", "message")}} event.

For example, assuming we had an encryption key in a {{jsxref("Uint8Array")}} typed array named `encryptionKey`, we could transfer it from the main thread to the worker as shown:

```js
const encryptionKeyBuffer = encryptionKey.buffer;
channel.port1.postMessage(encryptionKeyBuffer, [encryptionKeyBuffer]);
```

The worker would listen for the `message` event to get the key:

```js
messagePort.addEventListener("message", (event) => {
  const encryptionKeyBuffer = event.data;
  // … Use the encryptionKeyBuffer for encryption or any other purpose
});
```

See [message channel](/en-US/docs/Web/API/Channel_Messaging_API) for more information and examples.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Using WebRTC Encoded Transforms](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms)
# RTCRtpScriptTransformer: readable property

{{APIRef("WebRTC")}}

The **`readable`** read-only property of the {{domxref("RTCRtpScriptTransformer")}} interface returns a {{domxref("ReadableStream")}} instance is a source for encoded media frames.

When the corresponding {{domxref("RTCRtpScriptTransform")}} is inserted into the WebRTC sender and receiver pipelines, this stream may be enqueued with outgoing or incoming encoded media frames ({{domxref("RTCEncodedVideoFrame")}} or {{domxref("RTCEncodedAudioFrame")}}).
A WebRTC encoded transform can read the frames, modify them as needed, and then send them back into the WebRTC pipeline by writing them to {{domxref("RTCRtpScriptTransformer.writable")}}.
A common way to perform this operation is to pipe the frames through a {{domxref("TransformStream")}}.

## Value

A {{domxref("ReadableStream")}}.

## Examples

The following example shows how `readable` is piped through a {{domxref("TransformStream")}} to {{domxref("RTCRtpScriptTransformer.writable")}}.

```js
addEventListener("rtctransform", (event) => {
  let transform;
  // Select a transform based on passed options
  if (event.transformer.options.name === "senderTransform")
    transform = createSenderTransform(); // A TransformStream
  else if (event.transformer.options.name === "receiverTransform")
    transform = createReceiverTransform(); // A TransformStream
  else return;

  // Pipe frames from the readable to writeable through TransformStream
  event.transformer.readable
    .pipeThrough(transform)
    .pipeTo(event.transformer.writable);
});
```

The code implements a handler for the {{domxref("DedicatedWorkerGlobalScope.rtctransform_event", "rtctransform")}} event, which is fired at the global worker object on construction of the corresponding {{domxref("RTCRtpScriptTransform")}}, and when new frames are enqueued for processing.
`event.transformer` is the {{domxref("RTCRtpScriptTransformer")}} that has a `readable` and `writable` property.

An different {{domxref("TransformStream")}} is created to process outgoing and incoming frames, using `createSenderTransform()` or `createReceiverTransform()`, respectively (implementations not shown).
The event handler chooses the correct transform stream to use based on options passed through from the [`RTCRtpScriptTransform` constructor](/en-US/docs/Web/API/RTCRtpScriptTransform/RTCRtpScriptTransform) and assigns it to `transform`.

The code calls {{domxref("ReadableStream.pipeThrough()")}} on the `readable` to pipe encoded frames through the selected `TransformStream`, and then {{domxref("ReadableStream.pipeTo()")}} to pipe them to the {{domxref("RTCRtpScriptTransformer.writable")}}.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Using WebRTC Encoded Transforms](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms)
# RTCRtpScriptTransformer: sendKeyFrameRequest() method

{{APIRef("WebRTC")}}

The **`sendKeyFrameRequest()`** method of the {{domxref("RTCRtpScriptTransformer")}} interface may be called by a [WebRTC Encoded Transform](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms) that is processing incoming encoded video frames, in order to request a key frame from the sender.

The method may only be called when receiving _video_ (not audio) frames and if, for whatever reason, a recipient will not be able to decode the video without a new key frame.
Note that the user agent can decide that the request for a key frame is not necessary, in which case the returned promise will fulfill even though the request was not actually sent.

> [!NOTE]
> It might be called, for example, if a new user joins a WebRTC conference, in order to reduce the time before they receive a key frame and can hence start displaying video.
> For more information see [Triggering a key frame](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms#triggering_a_key_frame) in Using WebRTC Encoded Transforms.

## Syntax

```js-nolint
sendKeyFrameRequest()
```

### Parameters

None.

### Return value

A {{jsxref("Promise")}} that fulfills with `undefined` once the request is sent, or the user agent decides that it does not need to.

### Exceptions

- `InvalidStateError`
  - : The de-packetizer is not processing video packets, or is `undefined`.

## Examples

The example below shows how the main thread of a WebRTC application that is receiving encoded video might pass a decryption key to a receiver transform, and request the sender emit a key frame.

Note that the main thread doesn't have direct access to the {{domxref("RTCRtpScriptTransformer")}} object, so it needs to pass the key to the worker.
Here we do that with a `MessageChannel`, transferring the second port to the transformer code running in the worker.
The code assumes there is already a peer connection, and `videoReceiver` is an {{domxref("RTCRtpReceiver")}}.

```js
const worker = new Worker("worker.js");
const channel = new MessageChannel();

videoReceiver.transform = new RTCRtpScriptTransform(
  worker,
  { name: "receiverTransform", port: channel.port2 },
  [channel.port2],
);

// Post new key to the receiver
channel.port1.start();
channel.port1.postMessage({
  key: "93ae0927a4f8e527f1gce6d10bc6ab6c",
});
```

The {{domxref("DedicatedWorkerGlobalScope/rtctransform_event", "rtctransform")}} event handler in the worker gets the port as `event.transformer.options.port`.
The code snippet below shows how that is used to listen for `message` events on the channel.
If an event is received the handler gets the `key`, and then calls `sendKeyFrameRequest()` on the transformer.

```js
event.transformer.options.port.onmessage = (event) => {
  const { key } = event.data;
  // key is used by the transformer to decrypt frames (not shown)

  // Request sender to emit a key frame.
  // Here 'rcEvent' is the rtctransform event.
  rcEvent.transformer.sendKeyFrameRequest();
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Using WebRTC Encoded Transforms](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms)
- {{DOMxRef("RTCRtpScriptTransformer")}}
# RTCRtpScriptTransformer: writable property

{{APIRef("WebRTC")}}

The **`writable`** read-only property of the {{domxref("RTCRtpScriptTransformer")}} interface returns a {{domxref("WritableStream")}} instance that can be used as a sink for encoded media frames enqueued on the corresponding {{domxref("RTCRtpScriptTransformer.readable")}}.

When the corresponding {{domxref("RTCRtpScriptTransform")}} is inserted into the WebRTC sender and receiver pipelines, encoded media frames ({{domxref("RTCEncodedVideoFrame")}} or {{domxref("RTCEncodedAudioFrame")}}) may be enqueued on the {{domxref("RTCRtpScriptTransformer.readable")}}.
A WebRTC encoded transform can read the frames from `readable`, modify them as needed, and then send them back into the WebRTC pipeline by sending them to this `writable`.
A common way to perform this operation is to pipe the frames through a {{domxref("TransformStream")}}.

## Value

A {{domxref("WritableStream")}}.

## Examples

The following example shows how {{domxref("RTCRtpScriptTransformer.readable")}} is piped through a {{domxref("TransformStream")}} to `RTCRtpScriptTransformer.writable`.

```js
addEventListener("rtctransform", (event) => {
  let transform;
  // Select a transform based on passed options
  if (event.transformer.options.name === "senderTransform")
    transform = createSenderTransform(); // A TransformStream
  else if (event.transformer.options.name === "receiverTransform")
    transform = createReceiverTransform(); // A TransformStream
  else return;

  // Pipe frames from the readable to writeable through TransformStream
  event.transformer.readable
    .pipeThrough(transform)
    .pipeTo(event.transformer.writable);
});
```

The code implements a handler for the {{domxref("DedicatedWorkerGlobalScope.rtctransform_event", "rtctransform")}} event, which is fired at the global worker object on construction of the corresponding {{domxref("RTCRtpScriptTransform")}}, and when new frames are enqueued for processing.
`event.transformer` is the {{domxref("RTCRtpScriptTransformer")}} that has the `writable` and `readable` properties.

An different {{domxref("TransformStream")}} is created to process outgoing and incoming frames, using `createSenderTransform()` or `createReceiverTransform()`, respectively (implementations not shown).
The event handler chooses the correct transform stream to use based on options passed through from the [`RTCRtpScriptTransform` constructor](/en-US/docs/Web/API/RTCRtpScriptTransform/RTCRtpScriptTransform) and assigns it to `transform`.

The code calls {{domxref("ReadableStream.pipeThrough()")}} on the `readable` to pipe encoded frames through the selected `TransformStream`, and then {{domxref("ReadableStream.pipeTo()")}} to pipe them to the `RTCRtpScriptTransformer.writable`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRtpSender: dtmf property

{{APIRef("WebRTC")}}

The read-only **`dtmf`** property on the
**{{domxref("RTCRtpSender")}}** interface returns a
{{domxref("RTCDTMFSender")}} object which can be used to send {{Glossary("DTMF")}} tones
over the {{domxref("RTCPeerConnection")}}. See [Using DTMF](/en-US/docs/Web/API/WebRTC_API/Using_DTMF) for details on how to
make use of the returned `RTCDTMFSender` object.

## Value

An {{domxref("RTCDTMFSender")}} which can be used to send DTMF over the RTP session, or
`null` if the track being carried by the RTP session or the
{{domxref("RTCPeerConnection")}} as a whole doesn't support DTMF.

> [!NOTE]
> Only audio tracks can support DTMF, and typically only one audio track per
> `RTCPeerConnection` will have an associated {{domxref("RTCDTMFSender")}}

## Example

tbd

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- [Using DTMF with WebRTC](/en-US/docs/Web/API/WebRTC_API/Using_DTMF)
- {{domxref("RTCPeerConnection")}}
- {{domxref("RTCDTMFSender")}}
- {{domxref("RTCRtpSender")}}
# RTCRtpSender: getCapabilities() static method

{{APIRef("WebRTC")}}

The _static method_ **`RTCRtpSender.getCapabilities()`** returns an object describing the codec and header extension capabilities supported by the {{domxref("RTCRtpSender")}}.

You can, similarly, obtain the capabilities of {{domxref("RTCRtpReceiver")}} objects on the device by calling the static function {{domxref("RTCRtpReceiver.getCapabilities_static", "RTCRtpReceiver.getCapabilities()")}}.

## Syntax

```js-nolint
RTCRtpSender.getCapabilities(kind)
```

### Parameters

- `kind`
  - : A string indicating the type of media for which the browser's send capabilities are requested.
    The supported media kinds are: `audio` and `video`.

### Return value

A new object that indicates what capabilities the browser has for sending the specified media kind over an {{domxref("RTCPeerConnection")}}.
If the browser doesn't have any support for the given media `kind`, the returned value is `null`.

The returned object has the following properties:

- `codecs`
  - : An array of objects, each describing the basic capabilities of a single [media codec](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs) supported by the {{domxref("RTCRtpSender")}}.

    > [!NOTE]
    > The array contains special entries that represent the underlying components of the transport — these may be ignored if you're only interested in the actual codecs used for the media itself.
    > These are described below in the section [The codecs array](#the_codecs_array).

    Each codec object has the following properties:
    - `channels` {{optional_inline}}
      - : A positive integer value indicating the maximum number of channels supported by the codec; for example, a codec that supports only mono sound would have a value of 1; stereo codecs would have a 2, etc.
    - `clockRate`
      - : A positive integer specifying the codec's clock rate in Hertz (Hz).
        The IANA maintains a [list of codecs and their parameters](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-1), including their clock rates.
    - `mimeType`
      - : A string indicating the codec's MIME media type and subtype.
        The MIME type strings used by RTP differ from those used elsewhere.
        See {{RFC(3555, "", 4)}} for the complete IANA registry of these types.
        Also see [Codecs used by WebRTC](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs) for details about potential codecs that might be referenced here.
    - `sdpFmtpLine` {{optional_inline}}
      - : A string giving the format specific parameters field from the `a=fmtp` line in the SDP which corresponds to the codec, if such a line exists.
        If there is no parameters field, this property is left out.

- `headerExtensions`
  - : An array of objects, each providing the URI of a [header extension](https://datatracker.ietf.org/doc/html/rfc3550#section-5.3.1) supported for the current `kind` of media.
    Each object has the following property:
    - `uri`
      - : A string, specifying the URI of a header extension.
        The URI is formatted as described in {{RFC(5285)}}.

## Description

As a static function, this is always called using the form:

```js
capabilities = RTCRtpSender.getCapabilities("audio");
```

The returned set of capabilities is the most optimistic possible list.
It is entirely possible that certain combinations of options may fail to work when you actually try to use them.

Calling `RTCRtpSender.getCapabilities()` doesn't prime the browser in any way to handle media.
Nothing is loaded, fetched, or otherwise prepared.
It's a means of determining what might be usable before starting to try to access media.

Because the set of capabilities available tend to be stable for a length of time (people don't install and uninstall codecs and the like very often), the media capabilities can in whole or in part provide a cross-origin method for identifying a user.
For that reason, in privacy-sensitive contexts, the browser may choose to obscure the capabilities; this might be done, for example, by leaving out rarely-used codec configurations.

### The codecs array

The `codecs` array is an array of objects that describes a single codec and its basic capabilities.
The browser will only report distinct capability combinations separately.
If two sets of capabilities can be described as one, they will be.
That means that, for instance, if there are two entries for the H.264 codec (as identified by the [`mimeType`](#mimetype) being "video/H264"), there are other values in the capabilities objects indicating how they're different in some way.

There are three special entries that should always be present, representing underlying components of the transport. Those components are:

- RED (REDundant Audio Data)
  - : The media type of an RED entry may vary due to there being several versions of it, but it will end with `red`, such as `video/red` or `video/fwdred`.
    The base RED standard can be found in {{RFC(2198)}}. There may be multiple entries for RED if different forms are supported; each will have a unique media type in that case.
- FEC (Forward Error Correction)
  - : An FEC component handles error correction data; its media type may also vary due to there being advanced versions of the standard available, but it will always end with `fec`.
    One possible value is `video/ulpfec` (a generic error connection model).
    There may also be multiple FEC entries if more than one form is supported.
- RTX (Retransmission)
  - : This component is responsible for retransmission of data; its media type should be `video/rtx`.
    There will only be one entry for RTX, and it will not have an [`sdpFmtpLine`](#sdpfmtpline) property.

These entries should be ignored if only codecs related to the media are of interest.

## Examples

### Feature support

You can use [`Object.hasOwn()`](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn) to check that `RTCRtpSender.getCapabilities()` is supported:

```html hidden
<p id="log"></p>
```

```js hidden
const log = document.querySelector("#log");
```

```js
log.textContent = `RTCRtpSender.getCapabilities() supported: ${Object.hasOwn(
  RTCRtpSender,
  "getCapabilities",
)}`;
```

{{ EmbedLiveSample('Feature support', '100%', '30px') }}

### Checking support for a particular codec

The function below returns a `true` or `false` indicating whether or not the device supports sending H.264 video on an {{domxref("RTCRtpSender")}}.

> [!NOTE]
> Since `RTCRtpSender.getCapabilities()` actually only indicates _probable_ support.
> So below H.264 support might still fail even after getting a positive response from this function.

```js
function canSendH264() {
  let capabilities = RTCRtpSender.getCapabilities("video");

  capabilities.codecs.forEach((codec) => {
    if (codec.mimeType === "video/H264") {
      return true;
    }
  });
  return false;
}
```

### Getting all capabilities

This code example shows how we might get all supported codecs and headers.
The HTML defines a selection list for the two kinds of capabilities, and a log area.

```html
<select id="kind">
  <option value="audio">audio</option>
  <option value="video">video</option>
</select>
<textarea rows="40" cols="100" id="log"></textarea>
```

The JavaScript defines a function to log the capabilities for a particular "kind".
This is called initially with the value `audio`.
A listener updates the value when the selection list `kind` is changed.

```js
const log = document.querySelector("#log");
const kindSelector = document.querySelector("#kind");

logMediaCapabilities("audio");

kindSelector.addEventListener("click", () => {
  log.textContent = "";
  logMediaCapabilities(kindSelector.value);
});

function logMediaCapabilities(kind) {
  const capabilities = RTCRtpSender.getCapabilities(`${kind}`);
  log.textContent += "Headers\n";
  capabilities.headerExtensions.forEach((header) => {
    log.textContent += ` uri: ${header.uri}\n`;
  });

  log.textContent += "\nCodecs\n";
  capabilities.codecs.forEach((codec) => {
    log.textContent += ` mime type: ${codec.mimeType}\n`;
    log.textContent += `   channels: ${codec.channels}\n`; // max channels - e.g. 2 is stereo
    log.textContent += `   clockRate: ${codec.clockRate}\n`; // clock rate in Hz
    log.textContent += `   sdpFmtpLine: ${codec.sdpFmtpLine}\n`; // mime media type and subtype
  });
}
```

#### Result

{{ EmbedLiveSample('Getting all capabilities', '100%', '500px') }}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRtpSender: getParameters() method

{{APIRef("WebRTC")}}

The **`getParameters()`** method of the {{domxref("RTCRtpSender")}} interface returns an object describing the current configuration for how the sender's {{domxref("RTCRtpSender.track", "track")}} will be encoded and transmitted to a remote {{domxref("RTCRtpReceiver")}}.

## Syntax

```js-nolint
getParameters()
```

### Parameters

None.

### Return value

An object indicating the current configuration of the sender. <!-- RTCRtpSendParameters, derived from RTCRtpParameters -->

<!-- spec defines following in RTCRtpSendParameters -->

- `encodings`
  - : An array of objects, each specifying the parameters and settings for a single codec that could be used to encode the track's media.
    The properties of the objects include:
    - `active`
      - : `true` (the default) if the encoding is being sent, `false` if it is not being sent or used.

    - `codec` {{optional_inline}}
      - : Selects the [media codec](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs) that is used for this encoding's RTP stream.
        If not set, the user agent may select any codec negotiated for sending.
        <!-- RTCRtpCodec -->
        - `channels` {{optional_inline}}
          - : A positive integer indicating the number of channels supported by the codec.
            For example, for audio codecs a value of 1 specifies monaural sound, while 2 indicates stereo.

        - `clockRate`
          - : A positive integer specifying the codec's clock rate in Hertz (Hz).
            The clock rate is the rate at which the codec's RTP timestamp advances.
            Most codecs have specific values or ranges of values they permit.
            The IANA maintains a [list of codecs and their parameters](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-1), including their clock rates.

        - `mimeType`
          - : A string indicating the codec's MIME media type and subtype, specified as a string of the form `"type/subtype"`.
            The MIME type strings used by RTP differ from those used elsewhere.
            IANA maintains a [registry of valid MIME types](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-2).
            Also see [Codecs used by WebRTC](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs) for details about potential codecs that might be referenced here.

        - `sdpFmtpLine` {{optional_inline}}
          - : A string giving the format specific parameters provided by the local description.

    - `dtx` {{Deprecated_Inline}} {{Non-standard_Inline}}
      - : Only used for an {{domxref("RTCRtpSender")}} whose {{domxref("MediaStreamTrack.kind", "kind")}} is `audio`, this property indicates whether or not discontinuous transmission is being used (a feature by which a phone is turned off or the microphone muted automatically in the absence of voice activity).
        The value is taken either `enabled` or `disabled`.

    - `maxBitrate`
      - : A positive integer indicating the maximum number of bits per second that the user agent is allowed to grant to tracks encoded with this encoding.
        Other parameters may further constrain the bit rate, such as the value of `maxFramerate`, or the bandwidth available for the transport or physical network.

        The value is computed using the standard Transport Independent Application Specific Maximum (TIAS) bandwidth as defined by {{RFC(3890, "", "6.2.2")}}; this is the maximum bandwidth needed without considering protocol overheads from IP, TCP or UDP, and so forth.

        Note that the bitrate can be achieved in a number of ways, depending on the media and encoding.
        For example, for video a low bit rate might be achieved by dropping frames (a bitrate of zero might allow just one frame to be sent), while for audio the track might have to stop playing if the bitrate is too low for it to be sent.

    - `maxFramerate`
      - : A value specifying the maximum number of frames per second to allow for this encoding.
    - `priority`
      - : A string indicating the priority of the {{domxref("RTCRtpSender")}}, which may determine how the user agent allocates bandwidth between senders.
        Allowed values are `very-low`, `low` (default), `medium`, `high`.
    - `rid`
      - : A string which, if set, specifies an _RTP stream ID_ (_RID_) to be sent using the RID header extension.
        This parameter cannot be modified using {{domxref("RTCRtpSender.setParameters", "setParameters()")}}.
        Its value can only be set when the transceiver is first created.
    - `scaleResolutionDownBy`
      - : Only used for senders whose track's {{domxref("MediaStreamTrack.kind", "kind")}} is `video`, this is a floating-point value specifying a factor by which to scale down the video during encoding.
        The default value, 1.0, means that the video will be encoded at its original size.
        A value of 2.0 scales the video frames down by a factor of 2 in each dimension, resulting in a video 1/4 the size of the original.
        The value must not be less than 1.0 (attempting to scale the video to a larger size will throw a {{jsxref("RangeError")}}).

- `transactionId`
  - : A string containing a unique ID.
    This value is used to ensure that {{domxref("RTCRtpSender.setParameters", "setParameters()")}} can only be called to modify the parameters returned by a specific previous call to `getParameters()`.
    This parameter cannot be changed by the caller.
    <!-- spec defines following in RTCRtpParameters -->
- `codecs`
  - : An array of objects describing the [media codecs](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs) that the sender has set as enabled, and is prepared to use.
    This parameter cannot be changed once initially set.

    Each codec object in the array may have the following properties: <!-- RTCRtpCodecParameters -->
    - `channels` {{optional_inline}}
      - : A positive integer indicating the number of channels supported by the codec.
        For example, for audio codecs a value of 1 specifies monaural sound, while 2 indicates stereo.

    - `clockRate`
      - : A positive integer specifying the codec's clock rate in Hertz (Hz).
        The clock rate is the rate at which the codec's RTP timestamp advances.
        Most codecs have specific values or ranges of values they permit.
        The IANA maintains a [list of codecs and their parameters](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-1), including their clock rates.

    - `mimeType`
      - : A string indicating the codec's MIME media type and subtype, specified as a string of the form `"type/subtype"`.
        The MIME type strings used by RTP differ from those used elsewhere.
        IANA maintains a [registry of valid MIME types](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-2).
        Also see [Codecs used by WebRTC](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs) for details about potential codecs that might be referenced here.

    - `payloadType`
      - : The [RTP payload type](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-1) used to identify this codec.

    - `sdpFmtpLine` {{optional_inline}}
      - : A string giving the format specific parameters provided by the local description.

- `headerExtensions`
  - : An array of zero or more RTP header extensions, each identifying an extension supported by the sender or receiver. Header extensions are described in {{RFC(3550, "", "5.3.1")}}.
    This parameter cannot be changed once initially set.
- `rtcp`
  - : An object providing the configuration parameters used for {{Glossary("RTCP")}} on the sender.
    This parameter cannot be changed.

    The object may have the following properties: <!-- RTCRtcpParameters -->
    - `cname`
      - : A read-only string giving the canonical name (CNAME) used by RTCP (e.g., in SDES messages).
    - `reducedSize`
      - : A read-only boolean that is `True` if reduced size RTCP is configured ({{rfc("5506")}}), and `False` if compound RTCP is specified ({{rfc("3550")}}).

- `degradationPreference` {{deprecated_inline}} {{optional_inline}} <!-- removed from spec. May have been or be in chrome -->
  - : Specifies the preferred way the WebRTC layer should handle optimizing bandwidth against quality in constrained-bandwidth situations.
    The possible values are `maintain-framerate`, `maintain-resolution`, or `balanced`.
    The default value is `balanced`.

## Examples

This example gets the sender's current transaction ID; the transaction ID uniquely identifies the current set of parameters, to ensure that calls to {{domxref("RTCRtpSender.setParameters", "setParameters()")}} are always handled in the correct order, avoiding inadvertently overwriting parameters with older parameters.

```js
function getSenderTransactionID(sender) {
  let parameters = sender.getParameters();

  return parameters.transactionId;
}
```

In the same way, this code gets the canonical name (CNAME) being used for {{Glossary("RTCP")}} on an {{domxref("RTCRtpSender")}}.

```js
function getRtpCNAME(sender) {
  let parameters = sender.getParameters();

  return parameters.rtcp.cname;
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCRtpSender.setParameters()")}}
- {{domxref("RTCRtpReceiver.getParameters()")}}
# RTCRtpSender: getStats() method

{{APIRef("WebRTC")}}

The {{domxref("RTCRtpSender")}} method **`getStats()`** asynchronously requests an {{domxref("RTCStatsReport")}} object which provides statistics about outgoing traffic on the {{domxref("RTCPeerConnection")}} which owns the sender, returning a {{jsxref("Promise")}} which is fulfilled when the results are available.

## Syntax

```js-nolint
getStats()
```

### Parameters

None.

### Return value

A JavaScript {{jsxref("Promise")}} which is fulfilled once the statistics are available.
The promise's fulfillment handler receives as a parameter a {{domxref("RTCStatsReport")}} object containing the collected statistics.

The returned `RTCStatsReport` accumulates the statistics for all of the streams being sent using the `RTCRtpSender`, as well as the statistics for any dependencies those streams have.

These might include, for example, statistics with [types](/en-US/docs/Web/API/RTCStatsReport#the_statistic_types): [`outbound-rtp`](/en-US/docs/Web/API/RTCOutboundRtpStreamStats), [`candidate-pair`](/en-US/docs/Web/API/RTCIceCandidatePairStats), [`local-candidate`](/en-US/docs/Web/API/RTCIceCandidateStats), [`remote-candidate`](/en-US/docs/Web/API/RTCIceCandidateStats).

## Examples

This simple example obtains the statistics for an `RTCRtpSender` and updates an element's {{domxref("HTMLElement/innerText", "innerText")}} to display the current round trip time for requests on the sender.

```js
sender.getStats().then((stats) => {
  document.getElementById("currentRTT").innerText = stats.roundTripTime;
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCStatsReport")}}
- {{domxref("RTCRtpReceiver.getStats()")}}
- {{domxref("RTCPeerConnection.getStats()")}}
# RTCRtpSender

{{APIRef("WebRTC")}}

The **`RTCRtpSender`** interface provides the ability to control and obtain details about how a particular {{domxref("MediaStreamTrack")}} is encoded and sent to a remote peer.

With it, you can configure the encoding used for the corresponding track, get information about the device's media capabilities, and so forth. You can also obtain access to an {{domxref("RTCDTMFSender")}} which can be used to send {{Glossary("DTMF")}} codes (to simulate the user pressing buttons on a telephone's dial pad) to the remote peer.

## Instance properties

- {{domxref("RTCRtpSender.dtmf")}} {{ReadOnlyInline}}
  - : An {{domxref("RTCDTMFSender")}} which can be used to send {{Glossary("DTMF")}} tones using `telephone-event` payloads on the {{Glossary("RTP")}} session represented by the `RTCRtpSender` object. If `null`, the track and/or the connection doesn't support DTMF. Only audio tracks can support DTMF.
- {{domxref("RTCRtpSender.track")}} {{ReadOnlyInline}}
  - : The {{domxref("MediaStreamTrack")}} which is being handled by the `RTCRtpSender`. If `track` is `null`, the `RTCRtpSender` doesn't transmit anything.
- {{domxref("RTCRtpSender.transport")}} {{ReadOnlyInline}}
  - : The {{domxref("RTCDtlsTransport")}} over which the sender is exchanging the RTP and RTCP packets used to manage transmission of media and control data. This value is `null` until the transport is established. When bundling is in use, more than transceiver may be sharing the same transport object.
- {{domxref("RTCRtpSender.transform")}}
  - : An {{domxref("RTCRtpScriptTransform")}}<!-- or {{domxref("SFrameTransform")}} --> is used to insert a transform stream ({{domxref("TransformStream")}}) running in a worker thread into the sender pipeline, allowing stream transforms to be applied to encoded video and audio frames after they are output by a codec, and before they are sent.

### Obsolete properties

- `rtcpTransport` {{deprecated_inline}}
  - : This property has been removed; the RTP and RTCP transports have been combined into a single transport. Use the {{domxref("RTCRtpSender.transport", "transport")}} property instead.

## Static methods

- {{domxref("RTCRtpSender.getCapabilities_static", "RTCRtpSender.getCapabilities()")}}
  - : Returns an object describing the system's capabilities for sending a specified kind of media data.

## Instance methods

- {{domxref("RTCRtpSender.getParameters()")}}
  - : Returns an object describing the current configuration for the encoding and transmission of media on the `track`.
- {{domxref("RTCRtpSender.getStats()")}}
  - : Returns a {{jsxref("Promise")}} which is fulfilled with a {{domxref("RTCStatsReport")}} which provides statistics data for all outbound streams being sent using this `RTCRtpSender`.
- {{domxref("RTCRtpSender.setParameters()")}}
  - : Applies changes to parameters which configure how the `track` is encoded and transmitted to the remote peer.
- {{domxref("RTCRtpSender.setStreams()")}}
  - : Sets the {{domxref("MediaStream", "stream(s)", "", 1)}} associated with the {{domxref("RTCRtpSender.track", "track")}} being transmitted by this sender.
- {{domxref("RTCRtpSender.replaceTrack()")}}
  - : Attempts to replace the track currently being sent by the `RTCRtpSender` with another track, without performing renegotiation. This method can be used, for example, to toggle between the front- and rear-facing cameras on a device.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- WebRTC API
- {{domxref("RTCPeerConnection.addTrack()")}}
- {{domxref("RTCPeerConnection.getSenders()")}}
- {{domxref("RTCRtpReceiver")}}
# RTCRtpSender: replaceTrack() method

{{APIRef("WebRTC")}}

The {{domxref("RTCRtpSender")}} method
**`replaceTrack()`** replaces the track currently being used
as the sender's source with a new {{domxref("MediaStreamTrack")}}.

The new
track must be of the same media kind (audio, video, etc.) and switching the track should
not require negotiation.

Among the use cases for `replaceTrack()` is the common need to switch
between the rear- and front-facing cameras on a phone. With `replaceTrack()`,
you can have a track object for each camera and switch between the two as needed. See
the example [switching video cameras](#switching_video_cameras) below.

## Syntax

```js-nolint
replaceTrack(newTrack)
```

### Parameters

- `newTrack` {{optional_inline}}
  - : A {{domxref("MediaStreamTrack")}} specifying the track with which to replace the
    `RTCRtpSender`'s current source track. The new track's
    {{domxref("MediaStreamTrack.kind", "kind")}} must be the same as the current track's,
    or the replace track request will fail.

### Return value

A {{jsxref("Promise")}} which is fulfilled once the track has been successfully
replaced. The promise is rejected if the track cannot be replaced for any reason; this
is commonly because the change would require renegotiation of the codec, which is not
allowed (see [Things that require negotiation](#things_that_require_negotiation)).

If `newTrack` was omitted or was `null`,
`replaceTrack()` stops the sender. No negotiation is required in this case.

When the promise is fulfilled, the fulfillment handler receives a value of
`undefined`.

### Exceptions

If the returned promise is rejected, one of the following exceptions is provided to the
rejection handler:

- `InvalidModificationError` {{domxref("DOMException")}}
  - : Returned if replacing the `RTCRtpSender`'s current track with the new one
    would require negotiation.
- `InvalidStateError` {{domxref("DOMException")}}
  - : Returned if the track on which this method was called is stopped rather than running.
- {{jsxref("TypeError")}}
  - : Returned if the new track's `kind` doesn't match the original track.

## Usage notes

### Things that require negotiation

Most track replacements can be done without renegotiation. In fact, even changes that seem huge
can be done without requiring negotiation. However, some changes may require
negotiation and thus fail `replaceTrack()`:

- The new track has a resolution which is outside the bounds of the dimensions negotiated with the peer;
  however, most browser end points allow resolution changes.
- The new track's frame rate is high enough to cause the codec's block rate to be
  exceeded.
- The new track is a video track and its raw or pre-encoded state differs from that of
  the original track.
- The new track is an audio track with a different number of channels from the
  original.
- Media sources that have built-in encoders — such as hardware encoders — may not be
  able to provide the negotiated codec. Software sources may not implement the
  negotiated codec.

## Examples

### Switching video cameras

```js
const localConnection = new RTCPeerConnection();
const remoteConnection = new RTCPeerConnection();
// Configuring these to use the WebRTC API can be explored at
// https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample
const connections = [localConnection, remoteConnection];
function setCamera(selectedCamera) {
  navigator.mediaDevices
    .getUserMedia({
      video: {
        deviceId: {
          exact: selectedCamera,
        },
      },
    })
    .then((stream) => {
      const [videoTrack] = stream.getVideoTracks();
      connections.forEach((pc) => {
        const sender = pc
          .getSenders()
          .find((s) => s.track.kind === videoTrack.kind);
        console.log("Found sender:", sender);
        sender.replaceTrack(videoTrack);
      });
    })
    .catch((err) => {
      console.error(`Error happened: ${err}`);
    });
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
# RTCRtpSender: setParameters() method

{{APIRef("WebRTC API")}}

The **`setParameters()`** method of the {{domxref("RTCRtpSender")}} interface applies changes the configuration of sender's {{domxref("RTCRtpSender.track", "track")}}, which is the {{domxref("MediaStreamTrack")}} for which the `RTCRtpSender` is responsible.

In other words, `setParameters()` updates the configuration of the {{Glossary("RTP")}} transmission as well as the encoding configuration for a specific outgoing media track on the [WebRTC](/en-US/docs/Web/API/WebRTC_API) connection.

## Syntax

```js-nolint
setParameters(parameters)
```

### Parameters

- `parameters`
  - : A parameters object previously obtained by calling the same sender's {{domxref("RTCRtpSender.getParameters", "getParameters()")}} method, with the desired changes to the sender's configuration parameters.
    These parameters include potential codecs that could be use for encoding the sender's {{domxref("RTCRtpSender.track", "track")}}.
    The available parameters are:
    - `encodings`
      - : An array of objects, each specifying the parameters for a single codec that could be used to encode the track's media.
        The properties of the objects include:
        - `active`
          - : Setting this value `true` (the default) causes this encoding to be sent, while `false` stops it from being sent and used (but does not cause the SSRC to be removed).

        - `codec` {{optional_inline}}
          - : Selects the [media codec](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs) that is used for this encoding's RTP stream.
            If not set, the user agent may select any codec negotiated for sending.
            <!-- RTCRtpCodec -->
            - `channels` {{optional_inline}}
              - : A positive integer indicating the number of channels supported by the codec.
                For example, for audio codecs a value of 1 specifies monaural sound, while 2 indicates stereo.

            - `clockRate`
              - : A positive integer specifying the codec's clock rate in Hertz (Hz).
                The clock rate is the rate at which the codec's RTP timestamp advances.
                Most codecs have specific values or ranges of values they permit.
                The IANA maintains a [list of codecs and their parameters](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-1), including their clock rates.

            - `mimeType`
              - : A string indicating the codec's MIME media type and subtype, specified as a string of the form `"type/subtype"`.
                The MIME type strings used by RTP differ from those used elsewhere.
                IANA maintains a [registry of valid MIME types](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-2).
                Also see [Codecs used by WebRTC](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs) for details about potential codecs that might be referenced here.

            - `sdpFmtpLine` {{optional_inline}}
              - : A string giving the format specific parameters provided by the local description.

        - `dtx` {{Deprecated_Inline}} {{Non-standard_Inline}}
          - : Only used for an {{domxref("RTCRtpSender")}} whose {{domxref("MediaStreamTrack.kind", "kind")}} is `audio`, this property indicates whether or not to use discontinuous transmission (a feature by which a phone is turned off or the microphone muted automatically in the absence of voice activity).
            The value is taken either `enabled` or `disabled`.

        - `maxBitrate`
          - : A positive integer indicating the maximum number of bits per second that the user agent is allowed to grant to tracks encoded with this encoding.
            Other parameters may further constrain the bit rate, such as the value of `maxFramerate`, or the bandwidth available for the transport or physical network.

            The value is computed using the standard Transport Independent Application Specific Maximum (TIAS) bandwidth as defined by {{RFC(3890, "", "6.2.2")}}; this is the maximum bandwidth needed without considering protocol overheads from IP, TCP or UDP, and so forth.

            Note that the bitrate can be achieved in a number of ways, depending on the media and encoding.
            For example, for video a low bit rate might be achieved by dropping frames (a bitrate of zero might allow just one frame to be sent), while for audio the track might have to stop playing if the bitrate is too low for it to be sent.

        - `maxFramerate`
          - : A value specifying the maximum number of frames per second to allow for this encoding.
        - `priority`
          - : A string indicating the priority of the {{domxref("RTCRtpSender")}}, which may determine how the user agent allocates bandwidth between senders.
            Allowed values are `very-low`, `low` (default), `medium`, `high`.
        - `rid`
          - : A string which, if set, specifies an _RTP stream ID_ (_RID_) to be sent using the RID header extension.
            This parameter cannot be modified using `setParameters()`.
            Its value can only be set when the transceiver is first created.

        - `scaleResolutionDownBy`
          - : Only used for senders whose track's {{domxref("MediaStreamTrack.kind", "kind")}} is `video`, this is a floating-point value specifying a factor by which to scale down the video during encoding.
            The default value, 1.0, means that the video will be encoded at its original size.
            A value of 2.0 scales the video frames down by a factor of 2 in each dimension, resulting in a video 1/4 the size of the original.
            The value must not be less than 1.0 (attempting to scale the video to a larger size will throw a {{jsxref("RangeError")}}).

    - `transactionId`
      - : A string containing a unique ID.
        This ID is set in the previous {{domxref("RTCRtpSender.getParameters", "getParameters()")}} call, and ensures that the parameters originated from a previous call to {{domxref("RTCRtpSender.getParameters", "getParameters()")}}.
        <!-- spec defines following in RTCRtpParameters -->
    - `codecs`
      - : An array of objects describing the [media codecs](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs) from which the sender will choose.
        This parameter cannot be changed once initially set.

        Each codec object in the array may have the following properties: <!-- RTCRtpCodecParameters -->
        - `channels` {{optional_inline}}
          - : A positive integer indicating the number of channels supported by the codec.
            For example, for audio codecs a value of 1 specifies monaural sound, while 2 indicates stereo.

        - `clockRate`
          - : A positive integer specifying the codec's clock rate in Hertz (Hz).
            The clock rate is the rate at which the codec's RTP timestamp advances.
            Most codecs have specific values or ranges of values they permit.
            The IANA maintains a [list of codecs and their parameters](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-1), including their clock rates.

        - `mimeType`
          - : A string indicating the codec's MIME media type and subtype, specified as a string of the form `"type/subtype"`.
            The MIME type strings used by RTP differ from those used elsewhere.
            IANA maintains a [registry of valid MIME types](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-2).
            Also see [Codecs used by WebRTC](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs) for details about potential codecs that might be referenced here.

        - `payloadType`
          - : The [RTP payload type](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-1) used to identify this codec.

        - `sdpFmtpLine` {{optional_inline}}
          - : A string giving the format specific parameters provided by the local description.

    - `headerExtensions`
      - : An array of zero or more RTP header extensions, each identifying an extension supported by the sender.
        Header extensions are described in {{RFC(3550, "", "5.3.1")}}.
        This parameter cannot be changed.
    - `rtcp`
      - : An object providing the configuration parameters used for {{Glossary("RTCP")}} on the sender.
        This parameter cannot be changed.

        The object may have the following properties: <!-- RTCRtcpParameters -->
        - `cname`
          - : A read-only string giving the canonical name (CNAME) used by RTCP (e.g., in SDES messages).
        - `reducedSize`
          - : A read-only boolean that is `True` if reduced size RTCP is configured ({{rfc("5506")}}), and `False` if compound RTCP is specified ({{rfc("3550")}}).

    - `degradationPreference` {{deprecated_inline}}
      - : Specifies the preferred way the WebRTC layer should handle optimizing bandwidth against quality in constrained-bandwidth situations.
        The possible values are `maintain-framerate`, `maintain-resolution`, or `balanced`.
        The default value is `balanced`.

### Return value

A {{jsxref("Promise")}} that resolves when the {{domxref("RTCRtpSender.track")}} property is updated with the given parameters.

### Exceptions

If an error occurs, the returned promise is rejected with the appropriate exception from the list below.

- `InvalidModificationError` {{domxref("DOMException")}}
  - : Returned if one of the following problems is detected:
    - The number of encodings specified in the `parameters` object's `encodings` property does not match the number of encodings currently listed for the `RTCRtpSender`.
      You cannot change the number of encoding options after the sender has been created.
    - The order of the specified `encodings` has changed from the current list's order.
    - An attempt has been made to alter a property that cannot be changed after the sender is first created.
- `InvalidStateError` {{domxref("DOMException")}}
  - : Returned if the transceiver, of which the `RTCRtpSender` is a part, is not running or has no parameters to set.
- `OperationError` {{domxref("DOMException")}}
  - : Returned if an error occurs that does not match the ones specified here.
- {{jsxref("RangeError")}}
  - : Returned if the value specified for `scaleResolutionDownBy` option is less than 1.0 — which would result in scaling up rather than down, which is not allowed; or if one or more of the specified `encodings` [`maxFramerate`](#maxframerate) values is less than 0.0.

In addition, if a WebRTC error occurs while configuring or accessing the media, an {{domxref("RTCError")}} is thrown with its {{domxref("RTCError.errorDetail", "errorDetail")}} set to `hardware-encoder-error`.

## Description

It's important to keep in mind that you can't create the `parameters` object yourself and expect it to work.
Instead, you _must_ first call {{domxref("RTCRtpSender.getParameters", "getParameters()")}}, modify the received parameters object, then pass that object into `setParameters()`.
WebRTC uses the parameters object's `transactionId` property to ensure that when you set parameters, your changes are based on the most recent parameters rather than an out of date configuration.

## Examples

One use case for `setParameters()` is to try to reduce network bandwidth used in constrained environments by altering the resolution and/or bit rate of the media being transmitted by the {{domxref("RTCRtpSender")}}.

Currently, some browsers have limitations on their implementations that may cause issues.
For that reason, two examples are given here.
The first shows how to use `setParameters()` when all browsers fully support the parameters being used, while the second example demonstrates workarounds to help solve limitations in browsers with incomplete support for the [`maxBitrate`](#maxbitrate) and [`scaleResolutionDownBy`](#scaleresolutiondownby) parameters.

### By the specification

Once all browsers implement the spec fully, this implementation of `setVideoParams()` will do the job. This demonstrates how everything _should_ work.
You should probably use the second example, below, for now.
But this is a clearer demonstration of the basic concept of first fetching the parameters, then altering them, then setting them.

```js
async function setVideoParams(sender, height, bitrate) {
  const scaleRatio = sender.track.getSettings().height / height;
  const params = sender.getParameters();

  params.encodings[0].scaleResolutionDownBy = Math.max(scaleRatio, 1);
  params.encodings[0].maxBitrate = bitrate;
  await sender.setParameters(params);
}
```

In calling this function, you specify a sender, as well as the height you wish to scale the sender's video to, as well as a maximum bitrate to permit the sender to transmit.
A scaling factor for the size of the video, `scaleRatio`, is computed.
Then the sender's current parameters are fetched using {{domxref("RTCRtpSender.getParameters", "getParameters()")}}.

The parameters are then altered by changing the first `encodings` object's [`scaleResolutionDownBy`](#scaleresolutiondownby) and [`maxBitrate`](#maxbitrate) to the calculated scaling factor and the specified maximum `bitrate`.

The changed parameters are then saved by calling the sender's `setParameters()` method.

### Currently compatible implementation

As mentioned above, the previous example shows how things are meant to work.
Unfortunately, there are implementation issues preventing this in many browsers right now.
For that reason, if you want to be compatible with iPhone and other devices running Safari, and with Firefox, use code more like this:

```js
async function setVideoParams(sender, height, bitrate) {
  const scaleRatio = sender.track.getSettings().height / height;
  const params = sender.getParameters();

  // If encodings is null, create it
  params.encodings ??= [{}];
  params.encodings[0].scaleResolutionDownBy = Math.max(scaleRatio, 1);
  params.encodings[0].maxBitrate = bitrate;
  await sender.setParameters(params);

  // If the newly changed value of scaleResolutionDownBy is 1,
  // use applyConstraints() to be sure the height is constrained,
  // since scaleResolutionDownBy may not be implemented

  if (sender.getParameters().encodings[0].scaleResolutionDownBy === 1) {
    await sender.track.applyConstraints({ height });
  }
}
```

The differences here:

- If `encodings` is `null`, we create it, in order to ensure that we can then set the parameters successfully without crashing.
- If, after setting the parameters, the value of `scaleResolutionDownBy` is still 1, we call the sender's track's {{domxref("MediaStreamTrack.applyConstraints", "applyConstraints()")}} method to constrain the track's height to `height`.
  This compensates for an unimplemented `scaleResolutionDownBy` (as is the case in Safari as of this writing).

This code will cleanly fall back and work the normal way if the browser fully implements the used features.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- [Codecs used by WebRTC](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs)
- [Web media technologies](/en-US/docs/Web/Media)
# RTCRtpSender: setStreams() method

{{APIRef("WebRTC")}}

The {{domxref("RTCRtpSender")}} method **`setStreams()`** associates the sender's {{domxref("RTCRtpSender.track", "track")}} with the specified {{domxref("MediaStream")}} objects.

## Syntax

```js-nolint
setStreams()
setStreams(mediaStream1)
setStreams(mediaStream1, mediaStream2)
setStreams(mediaStream1, mediaStream2, /* …, */ mediaStreamN)
```

### Parameters

- `mediaStreamN` {{optional_inline}}
  - : An arbitrary number of {{domxref("MediaStream")}} objects specified as arguments, that identify the streams to which the `RTCRtpSender`'s {{domxref("RTCRtpSender.track", "track")}} belongs.
    If this parameter isn't specified, no new streams will be associated with the track.

### Return value

None ({{jsxref("undefined")}}).

### Exceptions

- `InvalidStateError` {{domxref("DOMException")}}
  - : Thrown if the sender's connection is closed.

## Description

`setStreams()` is purely additive. It doesn't remove the track from any streams; it adds it to new ones.
If you specify streams to which the track already belongs, that stream is unaffected.

Once the track has been added to all of the streams, renegotiation of the connection will be triggered by the {{domxref("RTCPeerConnection.negotiationneeded_event", "negotiationneeded")}} event being dispatched to the {{domxref("RTCPeerConnection")}} to which the sender belongs.

## Examples

This example adds all of an {{domxref("RTCPeerConnection")}}'s tracks to the specified stream.

```js
function addTracksToStream(stream) {
  let senders = pc.getSenders();

  senders.forEach((sender) => {
    if (sender.track && sender.transport.state === connected) {
      sender.setStreams(stream);
    }
  });
}
```

After calling the {{domxref("RTCPeerConnection")}} method {{domxref("RTCPeerConnection.getSenders", "getSenders()")}} to get the list of the connection's senders, the `addTracksToStream()` function iterates over the list.
For each sender, if the sender's track is non-null and its transport's state is `connected`, we call `setStreams()` to add the track to the `stream` specified.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRtpSender: track property

{{APIRef("WebRTC")}}

The **`track`** read-only property of
the {{domxref("RTCRtpSender")}} interface returns the {{domxref("MediaStreamTrack")}}
which is being handled by the `RTCRtpSender`.

## Value

A {{domxref("MediaStreamTrack")}} object representing the media associated with the
`RTCRtpSender`. If no track is associated with the sender, this value is
`null`, in which case the sender transmits nothing.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRtpSender: transform property

{{APIRef("WebRTC")}}

The **`transform`** property of the {{domxref("RTCRtpSender")}} object is used to insert a transform stream ({{domxref("TransformStream")}}) running in a worker thread into the sender pipeline.
This allows stream transforms to be applied to encoded video and audio frames after they are output by a codec, and before they are sent.

The transform that is to be added is defined using an {{domxref("RTCRtpScriptTransform")}} and its associated {{domxref("Worker")}}.
If the transform is set synchronously immediately after creating the `RTCRtpSender` it will receive the first full frame generated by the sender's encoder.

### Value

A {{domxref("RTCRtpScriptTransform")}}<!-- or {{domxref("SFrameTransform")}} -->, or `null` if the sender has no associated transform stream.

## Example

This example shows how you might stream video from a user's webcam over WebRTC, adding a WebRTC encoded transform to modify the outgoing streams.
Note that this is part of a larger example in the guide topic [Using WebRTC Encoded Transforms](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms).

The code assumes that there is an {{domxref("RTCPeerConnection")}} called `peerConnection` that is already connected to a remote peer.
It first gets a {{domxref("MediaStreamTrack")}}, using {{domxref("MediaDevices/getUserMedia", "getUserMedia()")}} to get a video {{domxref("MediaStream")}} from a media device, and then the {{domxref("MediaStream.getTracks()")}} method to get the first {{domxref("MediaStreamTrack")}} in the stream.

The track is added to the peer connection using {{domxref("RTCPeerConnection/addTrack()", "addTrack()")}}.
This returns a new {{domxref("RTCRtpSender")}} that will be used to send it.

```js
const mediaStream = await navigator.mediaDevices.getUserMedia({ video: true });
const [track] = mediaStream.getTracks();
const videoSender = peerConnection.addTrack(track, mediaStream);
```

The code above sets up the connection and starts sending the track.
To add a transform stream into the pipeline we need to construct an {{domxref("RTCRtpScriptTransform")}} and assign it to the sender's `transform` property.
As the transform is constructed immediately after creation of the {{domxref("RTCRtpSender")}}, it will receive the first frame generated by the sender's encoder, before it is sent.

```js
const worker = new Worker("worker.js");
videoSender.transform = new RTCRtpScriptTransform(worker, {
  name: "senderTransform",
});
```

Note that you can add the transform at any time.
However by adding it immediately after calling `addTrack()` the transform will get the first encoded frame that is sent.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Using WebRTC Encoded Transforms](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms)
- {{domxref("RTCRtpReceiver.transform")}}
# RTCRtpSender: transport property

{{APIRef("WebRTC")}}

The read-only **`transport`** property of an
{{domxref("RTCRtpSender")}} object provides the {{domxref("RTCDtlsTransport")}} object
used to interact with the underlying transport over which the sender is exchanging
Real-time Transport Control Protocol ({{Glossary("RTCP")}}) packets.

This transport is responsible for receiving the data for the media on the sender's
{{domxref("RTCRtpReceiver.track", "track")}}.

## Value

An {{domxref("RTCDtlsTransport")}} object representing the underlying transport being
used by the sender to exchange packets with the remote peer, or `null` if the
sender isn't yet connected to a transport.

## Description

When the `RTCRtpSender` is first created, the value of
`transport` is `null`. This is replaced with an
`RTCDtlsTransport` once the sender's transport has been established.

Note that when bundling is in effect—that is, when the {{domxref("RTCPeerConnection")}}
was created with a configuration object whose `bundlePolicy` is `max-compat`
or `max-bundle`—multiple senders may be sharing the same transport; in this
case, all of them are using the same connection to transmit and/or receive
{{Glossary("RTP")}} and {{Glossary("RTCP")}} packets.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCRtpTransceiver: currentDirection property

{{APIRef("WebRTC")}}

The read-only {{domxref("RTCRtpTransceiver")}} property **`currentDirection`** is a string which indicates the current negotiated directionality of the transceiver.

The directionality indicates whether the transceiver will offer to send and/or receive {{Glossary("RTP")}} data, or whether it is inactive or stopped and won't send or receive data.

The transceiver's preferred directionality can be set and read using the {{domxref("RTCRtpTransceiver.direction", "direction")}} property.
Changing the `direction` triggers a renegotiation, which may eventually result in the `currentDirection` also changing.

## Value

The value is initially `null`, prior to negotiation using an offer/answer.

After negotiation the value is a string with one of the following values:

- `"sendrecv"`
  - : Transceiver offers to send and receive RTP data:
    - `RTCRtpSender`: Offers to send RTP data, and will do so if the remote peer accepts the connection and at least one of the sender's encodings is active.
    - `RTCRtpReceiver`: Offers to receive RTP data, and does so if the remote peer accepts.
- `"sendonly"`
  - : Transceiver offers to send but not receive RTP data:
    - `RTCRtpSender`: Offers to send RTP data, and will do so if the remote peer accepts the connection and at least one of the sender's encodings is active.
    - `RTCRtpReceiver`: Does _not_ offer to receive RTP data and will not do so.
- `"recvonly"`
  - : Transceiver offers to receive but not set RTP data:
    - `RTCRtpSender`: Does _not_ offer to send RTP data, and will not do so.
    - `RTCRtpReceiver`: Offers to receive RTP data, and will do so if the remote peer offers.
- `"inactive"`
  - : Transceiver is inactive:
    - `RTCRtpSender`: Does _not_ offer to send RTP data, and will not do so.
    - `RTCRtpReceiver`: Does _not_ offer to receive RTP data and will not do so.
- `"stopped"`
  - : This is the terminal state of the transceiver.
    The transceiver is stopped and will not send or receive RTP data or offer to do so.
    - `RTCRtpSender`: Does _not_ offer to send RTP data, and will not do so.
    - `RTCRtpReceiver`: Does _not_ offer to receive RTP data and will not do so.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCRtpTransceiver.direction")}}
# RTCRtpTransceiver: direction property

{{APIRef("WebRTC")}}

The {{domxref("RTCRtpTransceiver")}} property **`direction`** is a string that indicates the transceiver's _preferred_ directionality.

The directionality indicates whether the transceiver will offer to send and/or receive {{Glossary("RTP")}} data, or whether it is inactive or stopped (terminated).
When setting the transceiver's direction, the value is not applied immediately.
The _current_ direction is indicated by the {{domxref("RTCRtpTransceiver.currentDirection", "currentDirection")}} property.

## Value

A string with one of the following values:

- `"sendrecv"`
  - : Transceiver offers to send and receive RTP data:
    - `RTCRtpSender`: Offers to send RTP data, and will do so if the remote peer accepts the connection and at least one of the sender's encodings is active.
    - `RTCRtpReceiver`: Offers to receive RTP data, and does so if the remote peer accepts.
- `"sendonly"`
  - : Transceiver offers to send but not receive RTP data:
    - `RTCRtpSender`: Offers to send RTP data, and will do so if the remote peer accepts the connection and at least one of the sender's encodings is active.
    - `RTCRtpReceiver`: Does _not_ offer to receive RTP data and will not do so.
- `"recvonly"`
  - : Transceiver offers to receive but not set RTP data:
    - `RTCRtpSender`: Does _not_ offer to send RTP data, and will not do so.
    - `RTCRtpReceiver`: Offers to receive RTP data, and will do so if the remote peer offers.
- `"inactive"`
  - : Transceiver is inactive:
    - `RTCRtpSender`: Does _not_ offer to send RTP data, and will not do so.
    - `RTCRtpReceiver`: Does _not_ offer to receive RTP data and will not do so.
- `"stopped"`
  - : This is the terminal state of the transceiver.
    The transceiver is stopped and will not send or receive RTP data or offer to do so.
    Setting this value when the transceiver is not already stopped raises a `TypeError`.
    - `RTCRtpSender`: Does _not_ offer to send RTP data, and will not do so.
    - `RTCRtpReceiver`: Does _not_ offer to receive RTP data and will not do so.

### Exceptions

When setting the value of `direction`, the following exception can occur:

- `InvalidStateError` {{domxref("DOMException")}}
  - : The receiver's {{domxref("RTCPeerConnection")}} is closed or the {{domxref("RTCRtpReceiver")}} is stopped.
- `TypeError`
  - : The value is being set to `stopped` when the current value is anything other than `stopped`.

## Description

The **`direction`** property can be used to set or get the transceiver's _preferred_ directionality.

Updating the directionality does not take effect immediately.
If the new value of `direction` is different from the existing value, renegotiation of the connection is required, so a {{domxref("RTCPeerConnection.negotiationneeded_event", "negotiationneeded")}} event is sent to the {{domxref("RTCPeerConnection")}}.
A `direction` value (other than `stopped`) is then used by {{domxref("RTCPeerConnection.createOffer()")}} or {{domxref("RTCPeerConnection.createAnswer()")}} in order to generate the {{glossary("SDP")}} message created those methods.
For example, if the `direction` is specified as `"sendrecv"`, the corresponding SDP a-line indicates the directionality:

```plain
a=sendrecv
```

The new directionality takes effect once the negotiation process is completed and the new session description is successfully applied.

The transceiver's _current_ direction is indicated by the {{domxref("RTCRtpTransceiver.currentDirection", "currentDirection")}} property.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCRtpTransceiver.currentDirection")}}
# RTCRtpTransceiver

{{APIRef("WebRTC")}}

The WebRTC interface **`RTCRtpTransceiver`** describes a permanent pairing of an {{domxref("RTCRtpSender")}} and an {{domxref("RTCRtpReceiver")}}, along with some shared state.

Each {{Glossary("SDP")}} media section describes one bidirectional SRTP ("Secure Real Time Protocol") stream (excepting the media section for {{domxref("RTCDataChannel")}}, if present).
This pairing of send and receive SRTP streams is significant for some applications, so `RTCRtpTransceiver` is used to represent this pairing, along with other important state from the media section.
Each non-disabled SRTP media section is always represented by exactly one transceiver.

A transceiver is uniquely identified using its {{domxref("RTCRtpTransceiver.mid", "mid")}} property, which is the same as the media ID (`mid`) of its corresponding m-line. An `RTCRtpTransceiver` is **associated** with an m-line if its `mid` is non-null; otherwise it's considered disassociated.

## Instance properties

- {{domxref("RTCRtpTransceiver.currentDirection", "currentDirection")}} {{ReadOnlyInline}}
  - : A read-only string which indicates the transceiver's current negotiated directionality, or `null` if the transceiver has never participated in an exchange of offers and answers.
    To change the transceiver's directionality, set the value of the {{domxref("RTCRtpTransceiver.direction", "direction")}} property.
- {{domxref("RTCRtpTransceiver.direction", "direction")}}
  - : A string which is used to set the transceiver's desired direction.
- {{domxref("RTCRtpTransceiver.mid", "mid")}} {{ReadOnlyInline}}
  - : The media ID of the m-line associated with this transceiver. This association is established, when possible, whenever either a local or remote description is applied. This field is `null` if neither a local or remote description has been applied, or if its associated m-line is rejected by either a remote offer or any answer.
- {{domxref("RTCRtpTransceiver.receiver", "receiver")}} {{ReadOnlyInline}}
  - : The {{domxref("RTCRtpReceiver")}} object that handles receiving and decoding incoming media.
- {{domxref("RTCRtpTransceiver.sender", "sender")}} {{ReadOnlyInline}}
  - : The {{domxref("RTCRtpSender")}} object responsible for encoding and sending data to the remote peer.
- {{domxref("RTCRtpTransceiver.stopped", "stopped")}} {{Deprecated_Inline}}
  - : Indicates whether or not sending and receiving using the paired `RTCRtpSender` and `RTCRtpReceiver` has been permanently disabled, either due to SDP offer/answer, or due to a call to {{domxref("RTCRtpTransceiver.stop", "stop()")}}.

## Instance methods

- {{domxref("RTCRtpTransceiver.setCodecPreferences", "setCodecPreferences()")}}
  - : Configures the transceiver's preferred list of codecs, overriding {{Glossary("user agent")}} settings.
- {{domxref("RTCRtpTransceiver.stop", "stop()")}}
  - : Permanently stops the `RTCRtpTransceiver`.
    The associated sender stops sending data, and the associated receiver likewise stops receiving and decoding incoming data.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- [Introduction to the Real-time Transport Protocol (RTP)](/en-US/docs/Web/API/WebRTC_API/Intro_to_RTP)
- {{domxref("RTCPeerConnection.addTrack()")}} and {{domxref("RTCPeerConnection.addTransceiver()")}} both create transceivers
- {{domxref("RTCRtpReceiver")}} and {{domxref("RTCRtpSender")}}
# RTCRtpTransceiver: mid property

{{APIRef("WebRTC")}}

The read-only {{domxref("RTCRtpTransceiver")}} interface's
**`mid`** property specifies the negotiated media ID
(`mid`) which the local and remote peers have agreed upon to uniquely
identify the stream's pairing of sender and receiver.

## Value

A string which uniquely identifies the pairing of source and
destination of the transceiver's stream. Its value is taken from the media ID of the SDP
m-line. This value is `null` if negotiation has not completed.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Introduction to the Real-time Transport Protocol (RTP)](/en-US/docs/Web/API/WebRTC_API/Intro_to_RTP)
# RTCRtpTransceiver: receiver property

{{APIRef("WebRTC")}}

The read-only **`receiver`** property
of WebRTC's {{domxref("RTCRtpTransceiver")}} interface indicates the
{{domxref("RTCRtpReceiver")}} responsible for receiving and decoding incoming media
data for the transceiver's stream.

## Value

An {{domxref("RTCRtpReceiver")}} object which is responsible for receiving and decoding
incoming media data whose media ID is the same as the current value of
{{domxref("RTCRtpTransceiver.mid", "mid")}}.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Introduction to the Real-time Transport Protocol (RTP)](/en-US/docs/Web/API/WebRTC_API/Intro_to_RTP)
- {{domxref("RTCRtpReceiver")}}
# RTCRtpTransceiver: sender property

{{APIRef("WebRTC")}}

The read-only **`sender`** property
of WebRTC's {{domxref("RTCRtpTransceiver")}} interface indicates the
{{domxref("RTCRtpSender")}} responsible for encoding and sending outgoing media data
for the transceiver's stream.

## Value

An {{domxref("RTCRtpSender")}} object used to encode and send media whose media ID
matches the current value of {{domxref("RTCRtpTransceiver.mid", "mid")}}.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Introduction to the Real-time Transport Protocol (RTP)](/en-US/docs/Web/API/WebRTC_API/Intro_to_RTP)
- {{domxref("RTCRtpSender")}}
# RTCRtpTransceiver: setCodecPreferences() method

{{APIRef("WebRTC")}}

The **`setCodecPreferences()`** method of the {{domxref("RTCRtpTransceiver")}} interface is used to set the codecs that the transceiver allows for decoding _received_ data, in order of decreasing preference.

The preferences set using this method influence what codecs are negotiated with the remote peer for encoding the data that it sends, including those used for retransmission, redundancy, and forward error correction.
Codecs that are not included in the preferences list will not be part of the negotiation.
Note that the preferences used by this transceiver for _sending_ content depend on the preferences of the remote peer.

The recommended way to set codec preferences is to first get the array of codecs that are actually supported for decoding received data, then reorder them your in decreasing preference order.
This ensures that the array is ordered as required, does not contain any unsupported codecs, and also that it also contains codecs that are needed for retransmission, redundancy, and forward error correction.

The specified set of codecs will be used for all future connections that include this transceiver until this method is called again.

When preparing to open an {{domxref("RTCPeerConnection")}} the codecs should be set using `setCodecPreferences()` _before_ calling either {{domxref("RTCPeerConnection.createOffer()")}} or {{domxref("RTCPeerConnection.createAnswer", "createAnswer()")}}, as these initiate the negotiation (and will use codec parameters from the {{Glossary("user agent", "user agent's")}} default configuration by default).

The codecs can be changed when you have an ongoing communication, but you need to first call `setCodecPreferences()` and then kick off a new negotiation.
A WebRTC application will already have code for this in the [`negotiationneeded` event handler](/en-US/docs/Web/API/RTCPeerConnection/negotiationneeded_event).
Note however that at time of writing the event is not automatically fired when you call `setCodecPreferences()`, so you will have to call `onnegotiationneeded` yourself.

A guide to codecs supported by WebRTC—and each codec's positive and negative characteristics—can be found in [Codecs used by WebRTC](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs).

## Syntax

```js-nolint
setCodecPreferences(codecs)
```

### Parameters

- `codecs`
  - : An array of objects, each providing the parameters for one of the transceiver's supported [media codecs](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs), ordered by preference.
    If `codecs` is empty, the codec configurations are all returned to the user agent's defaults.

    > [!NOTE]
    > Any codecs not included in `codecs` will not be considered during the process of negotiating a connection.
    > This lets you prevent the use of codecs you don't wish to use.

    Each codec object in the array has the following properties:
    - `channels` {{optional_inline}}
      - : A positive integer indicating the number of channels supported by the codec.
        For example, for audio codecs a value of 1 specifies monaural sound, while 2 indicates stereo.

    - `clockRate`
      - : A positive integer specifying the codec's clock rate in Hertz (Hz).
        The clock rate is the rate at which the codec's RTP timestamp advances.
        Most codecs have specific values or ranges of values they permit.
        The IANA maintains a [list of codecs and their parameters](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-1), including their clock rates.

    - `mimeType`
      - : A string indicating the codec's MIME media type and subtype, specified as a string of the form `"type/subtype"`.
        The MIME type strings used by RTP differ from those used elsewhere.
        IANA maintains a [registry of valid MIME types](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-2).
        Also see [Codecs used by WebRTC](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs) for details about potential codecs that might be referenced here.

    - `sdpFmtpLine` {{optional_inline}}
      - : A string giving the format specific parameters field from the `a=fmtp` line in the {{Glossary("SDP")}} which corresponds to the codec, if the field is present.
        If there is no parameters field, this property is left out.

### Return value

None ({{jsxref("undefined")}}).

### Exceptions

- `InvalidAccessError` {{domxref("DOMException")}}
  - : The `codecs` list includes one or more codecs which are not supported by the {{domxref("RTCRtpReceiver")}} associated with the transceiver.
- `InvalidModificationError` {{domxref("DOMException")}}
  - : The `codecs` list only contains entries for RTX, RED, FEC or Comfort Noise, or is an empty set.
    The codecs must always contain a codec for the media.

## Examples

### Creating the array of preferred codecs

The recommended way to set codec preferences is to first get the array of codecs that are actually supported for decoding received data, then reorder the list in decreasing preference order.

It is important to start with the list of codecs that are supported (and not a hard coded list of your preferred codecs), because you if you include any that aren't supported by the associated {{domxref("RTCRtpReceiver")}} the browser will throw an `InvalidAccessError` exception when you call the `setCodecPreferences()` method.
In addition, the array has to include appropriate codecs for retransmission, redundancy, and forward error correction, and starting with the list of supported codecs ensures that these are present.

You can get the codecs supported for decoding data using the {{domxref("RTCRtpReceiver.getCapabilities_static", "RTCRtpReceiver.getCapabilities()")}} static method as shown:

```js
const availReceiveCodecs = transceiver.receiver.getCapabilities("video").codecs;
```

To reorder the codecs array to our preferred order, we can use the sorting function below to sort on MIME type (this comes from [setCodecPreferences is now in all browsers!](https://blog.mozilla.org/webrtc/cross-browser-support-for-choosing-webrtc-codecs/) on blog.mozilla.org (2024)).

```js
function sortByMimeTypes(codecs, preferredOrder) {
  return codecs.sort((a, b) => {
    const indexA = preferredOrder.indexOf(a.mimeType);
    const indexB = preferredOrder.indexOf(b.mimeType);
    const orderA = indexA >= 0 ? indexA : Number.MAX_VALUE;
    const orderB = indexB >= 0 ? indexB : Number.MAX_VALUE;
    return orderA - orderB;
  });
}
```

The method takes the list of supported codecs, and an array containing the preferred MIME types, in decreasing order, and returns the array sorted in place.
The code below shows how this is used, assuming that you have already set up a peer connection (`peerConnection`):

```js
// Get supported codecs the sort using preferred codecs
const supportedCodecs = RTCRtpReceiver.getCapabilities("video").codecs;
const preferredCodecs = ["video/H264", "video/VP8", "video/VP9"];
const sortedCodecs = sortByMimeTypes(supportedCodecs, preferredCodecs);

// Get transceiver for connection and set the preferences
const [transceiver] = peerConnection.getTransceivers();
transceiver.setCodecPreferences(sortedCodecs); // <---
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [setCodecPreferences is now in all browsers!](https://blog.mozilla.org/webrtc/cross-browser-support-for-choosing-webrtc-codecs/) on blog.mozilla.org (2024)
- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- [Codecs used by WebRTC](/en-US/docs/Web/Media/Guides/Formats/WebRTC_codecs)
- [Introduction to the Real-time Transport Protocol (RTP)](/en-US/docs/Web/API/WebRTC_API/Intro_to_RTP)
- [Web media technologies](/en-US/docs/Web/Media)
# RTCRtpTransceiver: stop() method

{{APIRef("WebRTC")}}

The **`stop()`** method in the {{domxref("RTCRtpTransceiver")}} interface permanently stops the transceiver by stopping both the associated {{domxref("RTCRtpSender")}} and
{{domxref("RTCRtpReceiver")}}.

## Syntax

```js-nolint
stop()
```

### Parameters

None.

### Return value

None ({{jsxref("undefined")}}).

### Exceptions

- `InvalidStateError` {{domxref("DOMException")}}
  - : Thrown if the `RTCPeerConnection`, of which the transceiver is a member, is closed.

## Description

When you call `stop()` on a transceiver, the sender immediately stops sending media and each of its RTP streams are closed using the {{Glossary("RTCP")}} `"BYE"` message.
The receiver then stops receiving media; the receiver's {{domxref("RTCRtpReceiver.track", "track")}} is stopped, and the transceiver's {{domxref("RTCRtpTransceiver.direction", "direction")}} is changed to `stopped`.
Renegotiation is triggered by sending a {{domxref("RTCPeerConnection.negotiationneeded_event", "negotiationneeded")}} event to the transceiver's {{domxref("RTCPeerConnection")}}, so that the connection can adapt to the change.

The method does nothing if the transceiver is already stopped.
You can check whether it has stopped by comparing {{domxref("RTCRtpTransceiver.currentDirection", "currentDirection")}} to `"stopped"`.

> [!NOTE]
> Earlier versions of the specification used the deprecated {{domxref("RTCRtpTransceiver.stopped", "stopped")}} {{deprecated_inline}} property to indicate if the transceiver has stopped.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- [Introduction to the Real-time Transport Protocol (RTP)](/en-US/docs/Web/API/WebRTC_API/Intro_to_RTP)
- {{domxref("MediaStreamTrack")}}
# RTCRtpTransceiver: stopped property

{{APIRef("WebRTC")}}{{deprecated_header}}

> [!NOTE]
> Instead of using this deprecated property, compare {{domxref("RTCRtpTransceiver.currentDirection", "currentDirection")}} to `"stopped"`.

The read-only **`stopped`** property on the {{domxref("RTCRtpTransceiver")}} interface indicates whether or not the transceiver's associated sender and receiver have both been stopped.

The transceiver is stopped if the {{domxref("RTCRtpTransceiver.stop", "stop()")}} method has been called or if a change to either the local or the remote description has caused the transceiver to be stopped for some reason.

## Value

A Boolean value which is `true` if the transceiver's
{{domxref("RTCRtpTransceiver.sender", "sender")}} will no longer send data, and its
{{domxref("RTCRtpTransceiver.receiver", "receiver")}} will no longer receive data. If
either or both are still at work, the result is `false`.

## Specifications

This feature is not part of any current specification. It is no longer on track to become a standard.

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- [Introduction to the Real-time Transport Protocol (RTP)](/en-US/docs/Web/API/WebRTC_API/Intro_to_RTP)
# RTCSctpTransport

{{APIRef("WebRTC")}}

The **`RTCSctpTransport`** interface provides information which describes a Stream Control Transmission Protocol (**{{Glossary("SCTP")}}**) transport. This provides information about limitations of the transport, but also provides a way to access the underlying Datagram Transport Layer Security (**{{Glossary("DTLS")}}**) transport over which SCTP packets for all of an {{DOMxRef("RTCPeerConnection")}}'s data channels are sent and received.

You don't create `RTCSctpTransport` objects yourself; instead, you get access to the `RTCSctpTransport` for a given `RTCPeerConnection` through its **{{DOMxRef("RTCPeerConnection.sctp", "sctp")}}** property.

Possibly the most useful property on this interface is its [`maxMessageSize`](/en-US/docs/Web/API/RTCSctpTransport/maxMessageSize) property, which you can use to determine the upper limit on the size of messages you can send over a data channel on the peer connection.

{{InheritanceDiagram}}

## Instance properties

_Also inherits properties from: {{DOMxRef("EventTarget")}}_.

- {{DOMxRef("RTCSctpTransport.maxChannels")}} {{ReadOnlyInline}}
  - : An integer value indicating the maximum number of [`RTCDataChannel`](/en-US/docs/Web/API/RTCDataChannel) objects that can be opened simultaneously.
- {{DOMxRef("RTCSctpTransport.maxMessageSize")}} {{ReadOnlyInline}}
  - : An integer value indicating the maximum size, in bytes, of a message which can be sent using the {{DOMxRef("RTCDataChannel.send()")}} method.
- {{DOMxRef("RTCSctpTransport.state")}} {{ReadOnlyInline}}
  - : A string enumerated value indicating the state of the SCTP transport.
- {{DOMxRef("RTCSctpTransport.transport")}} {{ReadOnlyInline}}
  - : An {{DOMxRef("RTCDtlsTransport")}} object representing the {{Glossary("DTLS")}} transport used for the transmission and receipt of data packets.

## Events

Listen to these events using {{domxref("EventTarget.addEventListener", "addEventListener()")}} or by assigning an event listener to the `oneventname` property of this interface.

- {{domxref("RTCSctpTransport.statechange_event", "statechange")}}
  - : Sent when the {{DOMxRef("RTCSctpTransport.state")}} changes.

## Instance methods

_This interface has no methods, but inherits methods from: {{DOMxRef("EventTarget")}}._

## Example

TBD

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
- {{DOMxRef("RTCPeerConnection")}}
- {{DOMxRef("RTCPeerConnection.sctp")}}
# RTCSctpTransport: maxChannels property

{{APIRef("WebRTC")}}

The **`maxChannels`** read-only property of the {{DOMxRef("RTCSctpTransport")}} interface indicates the maximum number of {{DOMxRef("RTCDataChannel")}} objects that can be opened simultaneously.

## Value

An integer value indicating the maximum number of {{DOMxRef("RTCDataChannel")}} objects that can be opened simultaneously, or `null` before the SCTP transport goes into the "connected" [state](/en-US/docs/Web/API/RTCSctpTransport/state).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCSctpTransport: maxMessageSize property

{{APIRef("WebRTC")}}

The **`maxMessageSize`** read-only property of the {{DOMxRef("RTCSctpTransport")}} interface indicates the maximum size of a message that can be sent using the {{DOMxRef("RTCDataChannel.send()")}} method.

## Value

An integer value giving the maximum size, in bytes, of a message which can be sent using the {{DOMxRef("RTCDataChannel.send()")}} method.

## Examples

This example shows how you might split up a string into small enough parts to send based on maximum message size.

```js
// Function splits strings to a specified size and returns array.
function splitStringToMax(str, maxLength) {
  const result = [];
  let i = 0;
  while (i < str.length) {
    result.push(str.substring(i, i + maxLength));
    i += maxLength;
  }
  return result;
}

const peerConnection = new RTCPeerConnection(options);
const channel = peerConnection.createDataChannel("chat");
channel.onopen = (event) => {
  const maximumMessageSize = peerConnection.sctp.maxMessageSize;
  const textToSend = "This is my possibly overly long string!";
  splitStringToMax(textToSend, maximumMessageSize).forEach((elem) => {
    channel.send(elem);
  });
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{DOMxRef("RTCSctpTransport")}}
- [Understanding message size limits](/en-US/docs/Web/API/WebRTC_API/Using_data_channels#understanding_message_size_limits) section of [Using WebRTC data channels](/en-US/docs/Web/API/WebRTC_API/Using_data_channels)
# RTCSctpTransport: state property

{{APIRef("WebRTC")}}

The **`state`** read-only property of the {{DOMxRef("RTCSctpTransport")}} interface provides information which describes a Stream Control Transmission Protocol ({{Glossary("SCTP")}}) transport state.

## Value

A string whose value is one of the following:

- `connecting`
  - : The initial state when the connection is being established.
- `connected`
  - : The connection is open for data transmission.
- `closed`
  - : The connection is closed and can no longer be used.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{DOMxRef("RTCSctpTransport")}}
# RTCSctpTransport: statechange event

{{APIRef("WebRTC")}}

A **`statechange`** event is sent to an {{domxref("RTCSctpTransport")}} to provide notification when the {{domxref("RTCSctpTransport.state")}} property has changed.

<!-- This event is not cancelable and does not bubble. -->

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("statechange", (event) => { })

onstatechange = (event) => { }
```

## Event type

A generic {{domxref("Event")}}.

## Examples

Given an {{domxref("RTCSctpTransport")}}, `transport`, and an `updateStatus()` function that presents connection state information to the user, this code sets up an event handler to let the user know when the transport is connected.

```js
pc.addEventListener("statechange", (event) => {
  switch (transport.state) {
    case "connected":
      updateStatus("Connection started");
      break;
  }
});
```

Using `onstatechange`, it looks like this:

```js
transport.onstatechange = (event) => {
  switch (transport.state) {
    case "connected":
      updateStatus("Connection started");
      break;
  }
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCSctpTransport.state")}}
# RTCSctpTransport: transport property

{{APIRef("WebRTC")}}

The **`transport`** read-only property of the {{DOMxRef("RTCSctpTransport")}} interface returns a {{DOMxRef("RTCDtlsTransport")}} object representing the {{Glossary("DTLS")}} transport used for the transmission and receipt of data packets.

## Value

A {{DOMxRef("RTCDtlsTransport")}} object representing the {{Glossary("DTLS")}} transport used for the transmission and receipt of data packets.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{DOMxRef("RTCSctpTransport")}}
# RTCSessionDescription

{{APIRef("WebRTC")}}

The **`RTCSessionDescription`** interface describes one end of a connection—or potential connection—and how it's configured. Each `RTCSessionDescription` consists of a description {{domxref("RTCSessionDescription.type", "type")}} indicating which part of the offer/answer negotiation process it describes and of the {{Glossary("SDP")}} descriptor of the session.

The process of negotiating a connection between two peers involves exchanging `RTCSessionDescription` objects back and forth, with each description suggesting one combination of connection configuration options that the sender of the description supports. Once the two peers agree upon a configuration for the connection, negotiation is complete.

## Constructor

- {{domxref("RTCSessionDescription.RTCSessionDescription", "RTCSessionDescription()")}} {{deprecated_inline}}
  - : Creates a new `RTCSessionDescription` by specifying the `type` and `sdp`. All methods that accept `RTCSessionDescription` objects also accept objects with the same properties, so you can use a plain object instead of creating an `RTCSessionDescription` instance.

## Instance properties

_The `RTCSessionDescription` interface doesn't inherit any properties._

- {{domxref("RTCSessionDescription.type")}} {{ReadOnlyInline}}
  - : An enum describing the session description's type.
- {{domxref("RTCSessionDescription.sdp")}} {{ReadOnlyInline}}
  - : A string containing the {{Glossary("SDP")}} describing the session.

## Instance methods

_The `RTCSessionDescription` doesn't inherit any methods._

- {{domxref("RTCSessionDescription.toJSON()")}}
  - : Returns a {{Glossary("JSON")}} description of the object. The values of both properties, {{domxref("RTCSessionDescription.type", "type")}} and {{domxref("RTCSessionDescription.sdp", "sdp")}}, are contained in the generated JSON.

## Example

```js
signalingChannel.onmessage = (evt) => {
  if (!pc) start(false);

  const message = JSON.parse(evt.data);
  if (message.type && message.sdp) {
    pc.setRemoteDescription(
      new RTCSessionDescription(message),
      () => {
        // if we received an offer, we need to answer
        if (pc.remoteDescription.type === "offer") {
          pc.createAnswer(localDescCreated, logError);
        }
      },
      logError,
    );
  } else {
    pc.addIceCandidate(
      new RTCIceCandidate(message.candidate),
      () => {},
      logError,
    );
  }
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCPeerConnection.setLocalDescription()")}} and {{domxref("RTCPeerConnection.setRemoteDescription()")}}
# RTCSessionDescription: RTCSessionDescription() constructor

{{APIRef("WebRTC")}}{{deprecated_header}}

The **`RTCSessionDescription()`** constructor creates a new
{{domxref("RTCSessionDescription")}} with its properties initialized as described in the
specified object.

> [!NOTE]
> This constructor has been deprecated because
> {{domxref("RTCPeerConnection.setLocalDescription()")}} and other methods which take
> SDP as input now directly accept an object containing the {{domxref("RTCSessionDescription.type", "type")}} and {{domxref("RTCSessionDescription.sdp", "sdp")}} properties, so you don't have to instantiate an
> `RTCSessionDescription` yourself.

## Syntax

```js-nolint
new RTCSessionDescription(options)
```

### Values

- `options`
  - : An object providing the default values for the session description. It should contain the following properties:
    - `type`
      - : **Required.** A string which is used to set the `type` property of the new `RTCSessionDescription` object. Must be one of the valid {{domxref("RTCSessionDescription.type")}} values.
    - `sdp` {{optional_inline}}
      - : A string containing a {{Glossary("SDP")}} message describing the session. This value is an empty string (`""`) by default and may not be `null`.

## Example

This example uses the constructor to convert an SDP offer into an
`RTCSessionDescription` object.

> [!NOTE]
> This is no longer necessary, however;
> {{domxref("RTCPeerConnection.setLocalDescription()")}} and other methods which take
> SDP as input now directly accept plain objects, so you don't have to instantiate an
> `RTCSessionDescription` yourself.

```js
navigator.getUserMedia({ video: true }, (stream) => {
  pc.onaddstream({ stream });
  // Adding a local stream won't trigger the onaddstream callback
  pc.addStream(stream);

  pc.createOffer((offer) => {
    pc.setLocalDescription(
      new RTCSessionDescription(offer),
      () => {
        // send the offer to a server to be forwarded to the friend you're calling.
      },
      error,
    );
  }, error);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCSessionDescription")}}
# RTCSessionDescription: sdp property

{{APIRef("WebRTC")}}

The property **`RTCSessionDescription.sdp`** is a read-only
string containing the {{Glossary("SDP")}} which describes the session.

## Value

The value is a string containing an SDP message like this one:

```plain
v=0
o=alice 2890844526 2890844526 IN IP4 host.anywhere.com
s=
c=IN IP4 host.anywhere.com
t=0 0
m=audio 49170 RTP/AVP 0
a=rtpmap:0 PCMU/8000
m=video 51372 RTP/AVP 31
a=rtpmap:31 H261/90000
m=video 53000 RTP/AVP 32
a=rtpmap:32 MPV/90000
```

## Example

```js
// The remote description has been set previously on pc, an RTCPeerConnection

alert(pc.remoteDescription.sdp);
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
- The standard for using SDP in an offer/answer protocol {{rfc("3264")}}.
# RTCSessionDescription: toJSON() method

{{APIRef("WebRTC")}}

The **`RTCSessionDescription.toJSON()`** method generates a
{{Glossary("JSON")}} description of the object. Both properties,
{{domxref("RTCSessionDescription.type", "type")}} and
{{domxref("RTCSessionDescription.sdp", "sdp")}}, are contained in the generated JSON.

## Syntax

```js-nolint
toJSON()
```

### Parameters

None.

### Return value

A {{jsxref("JSON")}} object containing the following properties:

- `type`
  - : One of the following: `"offer"`, `"answer"`, `"pranswer"` or `null`.
- `sdp`
  - : Either `null` or the {{Glossary("SDP")}} message string corresponding to {{domxref("RTCSessionDescription.sdp")}} property.

## Example

```js
// sd is a RTCSessionDescriptor

alert(JSON.stringify(sd)); // This call the toJSON() method behind the scene.
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
# RTCSessionDescription: type property

{{APIRef("WebRTC")}}

The property **`RTCSessionDescription.type`** is a read-only
string value which describes the description's type.

## Value

The possible values are:

- `"answer"`
  - : The SDP contained in the {{domxref("RTCSessionDescription.sdp", "sdp")}} property is the definitive choice in the exchange. In other words, this session description describes the agreed-upon configuration, and is being sent to finalize negotiation.
- `"offer"`
  - : The session description object describes the initial proposal in an offer/answer exchange. The session negotiation process begins with an offer being sent from the caller to the callee.
- `"pranswer"`
  - : The session description object describes a provisional answer; that is, a response to a previous offer that is not the final answer. It is usually employed by legacy hardware.
- `"rollback"`
  - : This special type with an empty session description is used to roll back to the previous stable state.

## Example

```js
// The remote description has been set previously on pc, a RTCPeerConnection

alert(pc.remoteDescription.type);
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC](/en-US/docs/Web/API/WebRTC_API)
# RTCStatsReport: entries() method

{{APIRef("WebRTC")}}

The **`entries()`** method of the {{domxref("RTCStatsReport")}} interface returns a new [iterator](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator) object that can be used to iterate through the key/value pairs for each element in the `RTCStatsReport` object, in insertion order.

The keys are unique `id` values for monitored statistics objects from which the statistics are derived, and the associated values are [statistics dictionary objects](/en-US/docs/Web/API/RTCStatsReport#the_statistic_types).

The method is otherwise the same as {{jsxref("Map.prototype.entries()")}}.

## Syntax

```js-nolint
entries()
```

### Parameters

None.

### Return value

A new [iterable iterator object](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator).

## Examples

This example shows how to iterate through a {{domxref("RTCStatsReport")}} using the iterator returned by `entries()`.

Given a variable `myPeerConnection`, which is an instance of `RTCPeerConnection`, the code calls [`getStats()`](/en-US/docs/Web/API/RTCRtpReceiver/getStats) with `await` to wait for the statistics report.
It then uses a [for...of](/en-US/docs/Web/JavaScript/Reference/Statements/for...of) loop, with the iterator returned by `entries()`, to iterate through the entries.
The properties of statistics objects with the `type` of `outbound-rtp` are logged to the console (other objects are discarded).

```js
const stats = await myPeerConnection.getStats();

for (const stat of stats.entries()) {
  if (stat.type !== "outbound-rtp") continue;
  Object.keys(stat).forEach((statName) => {
    console.log(`${statName}: ${report[statName]}`);
  });
}
```

## Specifications

{{Specifications}} <!-- https://webidl.spec.whatwg.org/#dfn-maplike -->

## Browser compatibility

{{Compat}}

## See also

- {{jsxref("Map.prototype.entries()")}}
- {{domxref("RTCStatsReport.values()")}}
- {{domxref("RTCStatsReport.keys()")}}
# RTCStatsReport: forEach() method

{{APIRef("WebRTC")}}

The **`forEach()`** method of the {{domxref("RTCStatsReport")}} interface executes a provided function once for each key/value pair in the `RTCStatsReport` object, in insertion order.

The keys are unique `id` values for the monitored statistics objects from which the statistics are derived, and the associated values are [statistics dictionary objects](/en-US/docs/Web/API/RTCStatsReport#the_statistic_types).

The method is otherwise the same as {{jsxref("Map.prototype.forEach()")}}.

## Syntax

```js-nolint
forEach(callbackFn)
forEach(callbackFn, thisArg)
```

### Parameters

- `callbackFn`
  - : A function to execute for each entry in the report.
    The function is called with the following arguments:
    - `report`
      - : Statistics report for each iteration.
        This can be any of the [statistics dictionary types](/en-US/docs/Web/API/RTCStatsReport#the_statistic_types).
    - `id`
      - : A unique string identifying the monitored object from which the statistics are derived.
    - `map`
      - : The report being iterated.

- `thisArg` {{optional_inline}}
  - : A value to use as `this` when executing `callbackFn`.

### Return value

{{jsxref("undefined")}}.

## Examples

Given a variable `myPeerConnection`, which is an instance of `RTCPeerConnection`, the code calls [`getStats()`](/en-US/docs/Web/API/RTCRtpReceiver/getStats) with `await` to wait for the statistics report.
It then iterates the report using `RTCStatsReport.forEach()`, and filters the dictionaries for just those reports that have the `type` of `inbound-rtp` and `kind` of `video`.
For matching dictionaries it logs the `framesPerSecond` property of the inbound video.

```js
const stats = await myPeerConnection.getStats();

stats.forEach((report) => {
  if (report.type === "inbound-rtp" && report.kind === "video") {
    // Log the frame rate
    console.log(report.framesPerSecond);
  }
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{jsxref("Map.prototype.forEach()")}}
# RTCStatsReport: get() method

{{APIRef("WebRTC")}}

The **`get()`** method of the {{domxref("RTCStatsReport")}} interface returns a specified element from an `RTCStatsReport`.

Elements in the `RTCStatsReport` are identified by unique `id` values, which represent the monitored statistics objects from which the statistics are derived.
The element returned will be an instance of one of the [statistics dictionary objects](/en-US/docs/Web/API/RTCStatsReport#the_statistic_types), and it will contain statistics for the object with the given `id`.
The fetched value is a reference to the statistics dictionary, and any change made to that object will effectively modify it inside the `RTCStatsReport` object.

The method is otherwise the same as {{jsxref("Map.prototype.get()")}}.

## Syntax

```js-nolint
get(id)
```

### Parameters

- `id`
  - : A string indicating the ID of the element to return from the `RTCStatsReport` object.
    IDs are unique strings that identify the monitored object from which the corresponding statistics are derived.

### Return value

The element associated with the specified `id` key, or {{jsxref("undefined")}} if the key can't be found in the `Map` object.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{jsxref("Map.prototype.get()")}}
# RTCStatsReport: has() method

{{APIRef("WebRTC")}}

The **`has()`** method of the {{domxref("RTCStatsReport")}} interface returns a boolean indicating whether a report contains a statistics dictionary with the specified id.

The method is otherwise the same as {{jsxref("Map.prototype.has()")}}.

## Syntax

```js-nolint
has(id)
```

### Parameters

- `id`
  - : A string containing the ID of a statistics object that might be present in this `RTCStatsReport`.

### Return value

`true` if an element with the specified `id` exists in the `RTCStatsReport` object; otherwise `false`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{jsxref("Map")}}
- {{jsxref("Map.prototype.set()")}}
- {{jsxref("Map.prototype.get()")}}
# RTCStatsReport

{{APIRef("WebRTC")}}

The **`RTCStatsReport`** interface of the [WebRTC API](/en-US/docs/Web/API/WebRTC_API) provides a statistics report for a {{domxref("RTCPeerConnection")}}, {{domxref("RTCRtpSender")}}, or {{domxref("RTCRtpReceiver")}}.

An `RTCStatsReport` instance is a read-only [`Map`-like object](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#map-like_browser_apis), in which each key is an identifier for an object for which statistics are being reported, and the corresponding value is a dictionary object providing the statistics.

## Instance properties

- {{domxref("RTCStatsReport.size")}}
  - : Returns the number of items in the `RTCStatsReport` object.

## Instance methods

- {{domxref("RTCStatsReport.entries()")}}
  - : Returns a new [Iterator](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator) object that contains a two-member array of `[id, statistic-dictionary]` for each element in the `RTCStatsReport` object, in insertion order.
- {{domxref("RTCStatsReport.forEach()")}}
  - : Calls `callbackFn` once for each key-value pair present in the `RTCStatsReport` object, in insertion order.
    If a `thisArg` parameter is provided to `forEach`, it will be used as the `this` value for each callback.
- {{domxref("RTCStatsReport.get()")}}
  - : Returns the statistics dictionary associated with the passed `id`, or `undefined` if there is none.
- {{domxref("RTCStatsReport.has()")}}
  - : Returns a boolean indicating whether the `RTCStatsReport` contains a statistics dictionary associated with the specified `id`.
- {{domxref("RTCStatsReport.keys()")}}
  - : Returns a new [Iterator](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator) object that contains the keys (IDs) for each element in the `RTCStatsReport` object, in insertion order.
- {{domxref("RTCStatsReport.values()")}}
  - : Returns a new [Iterator](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator) object that contains the values (statistics object) for each element in the `RTCStatsReport` object, in insertion order.
- [`RTCStatsReport[Symbol.iterator]()`](/en-US/docs/Web/API/RTCStatsReport/Symbol.iterator)
  - : Returns a new [Iterator](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator) object that contains a two-member array of `[id, statistic-dictionary]` for each element in the `RTCStatsReport` object, in insertion order.

## Description

A {{jsxref("Promise")}} that resolves to an `RTCStatsReport` is returned from the {{domxref("RTCRtpReceiver.getStats()")}}, {{domxref("RTCRtpSender.getStats()")}} and {{domxref("RTCPeerConnection.getStats()")}} methods.
Calling `getStats()` on an {{domxref("RTCPeerConnection")}} lets you specify whether you wish to obtain outbound statistics, inbound statistics, or statistics for the whole connection.
The {{domxref("RTCRtpReceiver")}} and {{domxref("RTCRtpSender")}} versions of `getStats()` only return inbound and outbound statistics, respectively.

The statistics report is a read-only [`Map`-like](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) object: an ordered dictionary, where the properties are `id` strings that uniquely identify the WebRTC object that was inspected to produce a particular set of statistics, and the value is a dictionary object containing those statistics.
A `RTCStatsReport` can be iterated and used the same ways as a read-only `Map`.

The report may contain many different categories of statistics, including inbound and outbound statistics for both the current and remote ends of the peer connection, information about codecs, certificates and media used, and so on.
Each category of statistic is provided in a different type of statistics dictionary object, which can be identified from its [`type`](#type) property.

### Common instance properties

All the dictionary types have the following properties:

- `id`
  - : A string that uniquely identifies the object was monitored to produce the set of statistics.
    This value persists across reports for (at least) the lifetime of the connection.
    Note however that for some statistics the ID may vary between browsers and for subsequent connections, even to the same peer.
- `timestamp`
  - : A high resolution timestamp object ({{domxref("DOMHighResTimeStamp")}}) object indicating the time at which the sample was taken.
    Many reported statistics are cumulative values; the timestamp allows rates and averages to be calculated between any two reports, at any desired reporting rate.
- `type`
  - : A string with a value that indicates the type of statistics that the object contains, such as `candidate-pair`, `inbound-rtp`, `certificate`, and so on.
    The [types of statistics and their corresponding objects](#the_statistic_types) are listed below.

Users typically iterate a `RTCStatsReport`, using a {{domxref("RTCStatsReport.forEach()", "forEach()")}} or [`for...of`](/en-US/docs/Web/JavaScript/Reference/Statements/for...of) loop, selecting the statistics of interest using the `type` property.
Once a particular statistic object has been identified using its `type`, the `id` property can subsequently be used with {{domxref("RTCStatsReport.get()", "get()")}} to obtain the same statistic report at a different time.

The timestamp can be used to calculate average values for statistics that accumulate over the lifetime of a connection.

### The statistic types

The statistics `type` values and their corresponding dictionaries are listed below.

| type                  | Dictionary                                                               | Description                                                                                                                                                                                                |
| --------------------- | ------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `candidate-pair`      | {{domxref("RTCIceCandidatePairStats")}}                                  | Statistics describing the change from one {{domxref("RTCIceTransport")}} to another, such as during an [ICE restart](/en-US/docs/Web/API/WebRTC_API/Session_lifetime#ice_restart).                         |
| `certificate`         | {{domxref("RTCCertificateStats")}}                                       | Statistics about a certificate being used by an {{domxref("RTCIceTransport")}}.                                                                                                                            |
| `codec`               | {{domxref("RTCCodecStats")}}                                             | Statistics about a specific codec being used by streams being sent or received by this connection.                                                                                                         |
| `data-channel`        | {{domxref("RTCDataChannelStats")}}                                       | Statistics related to one {{domxref("RTCDataChannel")}} on the connection.                                                                                                                                 |
| `inbound-rtp`         | {{domxref("RTCInboundRtpStreamStats")}}                                  | Statistics describing the state of one of the connection's inbound data streams.                                                                                                                           |
| `local-candidate`     | {{domxref("RTCIceCandidateStats")}}                                      | Statistics about a local ICE candidate associated with the connection's {{domxref("RTCIceTransport")}}s.                                                                                                   |
| `media-source`        | {{domxref("RTCAudioSourceStats")}} or {{domxref("RTCVideoSourceStats")}} | Statistics about the media produced by the {{domxref("MediaStreamTrack")}} attached to an RTP sender. The dictionary this key maps to depends on the track's {{domxref("MediaStreamTrack.kind", "kind")}}. |
| `outbound-rtp`        | {{domxref("RTCOutboundRtpStreamStats")}}                                 | Statistics describing the state of one of the outbound data streams on this connection.                                                                                                                    |
| `peer-connection`     | {{domxref("RTCPeerConnectionStats")}}                                    | Statistics describing the state of the {{domxref("RTCPeerConnection")}}.                                                                                                                                   |
| `remote-candidate`    | {{domxref("RTCIceCandidateStats")}}                                      | Statistics about a remote ICE candidate associated with the connection's {{domxref("RTCIceTransport")}}s.                                                                                                  |
| `remote-inbound-rtp`  | {{domxref("RTCRemoteInboundRtpStreamStats")}}                            | Statistics describing the state of the inbound data stream from the perspective of the remote peer.                                                                                                        |
| `remote-outbound-rtp` | {{domxref("RTCRemoteOutboundRtpStreamStats")}}                           | Statistics describing the state of the outbound data stream from the perspective of the remote peer.                                                                                                       |
| `transport`           | {{domxref("RTCTransportStats")}}                                         | Statistics about a transport used by the connection.                                                                                                                                                       |

## Examples

### Iterate report from an RTCPeerConnection using forEach loop

This example logs shows how you might log video-related statistics for the local {{domxref("RTCRtpReceiver")}} responsible for receiving streamed media.

Given a variable `myPeerConnection`, which is an instance of `RTCPeerConnection`, the code uses `await` to wait for the statistics report, and then iterates it using {{domxref("RTCStatsReport.forEach()")}}.
It then filters the dictionaries for just those reports that have the `type` of `inbound-rtp` and `kind` of `video`.

```js
const stats = await myPeerConnection.getStats();

stats.forEach((report) => {
  if (report.type === "inbound-rtp" && report.kind === "video") {
    // Log the frame rate
    console.log(report.framesPerSecond);
  }
});
```

### Iterate report from an RTCRtpSender using a for...of loop

This example shows how you might iterate the outbound statistics from an {{domxref("RTCRtpSender")}}.

The code follows a similar pattern to the previous example, but iterates using a `for...of`-loop on the {{domxref("RTCStatsReport.values()")}}, and filters on the `type` of `outbound-rtp`.
It assumes you already have an `RTCRtpSender` object named "sender".

```js
const stats = await sender.getStats();

for (const stat of stats.values()) {
  if (stat.type !== "outbound-rtp") continue;
  Object.keys(stat).forEach((statName) => {
    console.log(`${statName}: ${stat[statName]}`);
  });
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
- {{domxref("RTCPeerConnection")}}
- {{domxref("RTCPeerConnection.getStats()")}}, {{domxref("RTCRtpReceiver.getStats()")}}, and {{domxref("RTCRtpSender.getStats()")}}
# RTCStatsReport: keys() method

{{APIRef("WebRTC")}}

The **`keys()`** method of the {{domxref("RTCStatsReport")}} interface returns a new _[iterator](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator)_ object that can be used to iterate through the keys for each element in the `RTCStatsReport` object, in insertion order.

The keys in the `RTCStatsReport` are unique string `id` values, which represent the monitored statistics objects from which the statistics are derived.

The method is otherwise the same as {{jsxref("Map.prototype.keys()")}}.

## Syntax

```js-nolint
keys()
```

### Parameters

None.

### Return value

A new [iterable iterator object](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator).

## Examples

This example shows how to iterate through a {{domxref("RTCStatsReport")}} using the iterator returned by `keys()`.

Given a variable `myPeerConnection`, which is an instance of `RTCPeerConnection`, the code calls [`getStats()`](/en-US/docs/Web/API/RTCRtpReceiver/getStats) with `await` to wait for the statistics report.
It then uses a [for...of](/en-US/docs/Web/JavaScript/Reference/Statements/for...of) loop, with the iterator returned by `keys()`, to iterate through the IDs.
Each ID is used to get the corresponding statistics dictionary.
The properties of statistics objects with the `type` of `outbound-rtp` are logged to the console (other objects are discarded).

```js
const stats = await myPeerConnection.getStats();

for (const id of stats.keys()) {
  // Get dictionary associated with key (id)
  const stat = stats.get(id);
  if (stat.type !== "outbound-rtp") continue;
  Object.keys(stat).forEach((statName) => {
    console.log(`${statName}: ${report[statName]}`);
  });
}
```

Note that this examples is somewhat contrived.
You could more easily iterate with {{domxref("RTCStatsReport.entries()","entries()")}} or {{domxref("RTCStatsReport.values()","values()")}} and not have to map the ID to a value.
You can even iterate the {{domxref("RTCStatsReport")}} itself, as it has the [`[Symbol.iterator]()`](/en-US/docs/Web/API/RTCStatsReport/Symbol.iterator) method!

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{jsxref("Map.prototype.keys()")}}
- {{domxref("RTCStatsReport.values()")}}
- {{domxref("RTCStatsReport.entries()")}}
# RTCStatsReport: size property

{{APIRef("WebRTC")}}

The **`size`** read-only property of the {{domxref("RTCStatsReport")}} interface returns the number of items in the current report.

Note that each item consists of a key-value pair, where the keys are unique `id` values for monitored statistics objects from which the statistics are derived, and the associated values are [statistics dictionary objects](/en-US/docs/Web/API/RTCStatsReport#the_statistic_types).

This property is otherwise the same as {{jsxref("Map.prototype.size")}}.

## Value

An integer indicating the number of items in this report.
The value is zero if the report is empty.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{jsxref("Map")}}
# RTCStatsReport: [Symbol.iterator]() method

{{APIRef("WebRTC")}}

The **`[Symbol.iterator]()`** method of the {{domxref("RTCStatsReport")}} interface implements the [iterable protocol](/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) and allows statistics reports to be consumed by most syntaxes expecting iterables, such as the [spread syntax](/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) and {{jsxref("Statements/for...of", "for...of")}} loops.
It returns an [iterator object](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator) that yields the key-value pairs of the report in insertion order.

The initial value of this property is the same function object as the initial value of the {{domxref("RTCStatsReport.entries()")}} method.

The method is otherwise the same as [`Map.prototype[Symbol.iterator]()`](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/Symbol.iterator).

## Syntax

```js-nolint
RTCStatsReport[Symbol.iterator]()
```

### Parameters

None.

### Return value

The same return value as {{domxref("RTCStatsReport.entries()")}}.
This is a new [iterable iterator object](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator) that yields the key-value (`id`-"statistics dictionary") pairs of the report.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("RTCStatsReport.entries()")}}
- [`Map.prototype[Symbol.iterator]()`](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/Symbol.iterator)
# RTCStatsReport: values() method

{{APIRef("WebRTC")}}

The **`values()`** method of the {{domxref("RTCStatsReport")}} interface returns a new _[iterator](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator)_ object that can be used to iterate through the values for each element in the `RTCStatsReport` object, in insertion order.

The values are [statistics dictionary objects](/en-US/docs/Web/API/RTCStatsReport#the_statistic_types).

The method is otherwise the same as {{jsxref("Map.prototype.values()")}}.

## Syntax

```js-nolint
values()
```

### Parameters

None.

### Return value

A new [iterable iterator object](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator).

## Examples

This example shows how to iterate through a {{domxref("RTCStatsReport")}} using the iterator returned by `values()`.

Given a variable `myPeerConnection`, which is an instance of `RTCPeerConnection`, the code calls [`getStats()`](/en-US/docs/Web/API/RTCRtpReceiver/getStats) with `await` to wait for the statistics report.
It then uses a [for...of](/en-US/docs/Web/JavaScript/Reference/Statements/for...of) loop, with the iterator returned by `values()`, to iterate through the dictionary objects in the report.
The properties of statistics objects with the `type` of `outbound-rtp` are logged to the console (other objects are discarded).

```js
const stats = await myPeerConnection.getStats();

for (const stat of stats.values()) {
  if (stat.type !== "outbound-rtp") continue;
  Object.keys(stat).forEach((statName) => {
    console.log(`${statName}: ${report[statName]}`);
  });
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{jsxref("Map.prototype.values()")}}
- {{domxref("RTCStatsReport.keys()")}}
- {{domxref("RTCStatsReport.entries()")}}
# RTCTrackEvent

{{APIRef("WebRTC")}}

The [WebRTC API](/en-US/docs/Web/API/WebRTC_API) interface **`RTCTrackEvent`** represents the {{domxref("RTCPeerConnection.track_event", "track")}} event, which is sent when a new {{domxref("MediaStreamTrack")}} is added to an {{domxref("RTCRtpReceiver")}} which is part of the {{domxref("RTCPeerConnection")}}.

The target is the `RTCPeerConnection` object to which the track is being added.

This event is sent by the WebRTC layer to the website or application, so you will not typically need to instantiate an `RTCTrackEvent` yourself.

{{InheritanceDiagram}}

## Constructor

- {{domxref("RTCTrackEvent.RTCTrackEvent", "RTCTrackEvent()")}}
  - : Creates and returns a new `RTCTrackEvent` object. You will probably not need to create new track events yourself, since they're typically created by the WebRTC infrastructure and sent to the connection's {{domxref("RTCPeerConnection.track_event", "ontrack")}} event handler.

## Instance properties

_Since `RTCTrackEvent` is based on {{domxref("Event")}}, its properties are also available._

- {{domxref("RTCTrackEvent.receiver", "receiver")}} {{ReadOnlyInline}}
  - : The {{domxref("RTCRtpReceiver")}} used by the track that's been added to the `RTCPeerConnection`.
- {{domxref("RTCTrackEvent.streams", "streams")}} {{ReadOnlyInline}} {{optional_inline}}
  - : An array of {{domxref("MediaStream")}} objects, each representing one of the media streams to which the added {{domxref("RTCTrackEvent.track", "track")}} belongs. By default, the array is empty, indicating a streamless track.
- {{domxref("RTCTrackEvent.track", "track")}} {{ReadOnlyInline}}
  - : The {{domxref("MediaStreamTrack")}} which has been added to the connection.
- {{domxref("RTCTrackEvent.transceiver", "transceiver")}} {{ReadOnlyInline}}
  - : The {{domxref("RTCRtpTransceiver")}} being used by the new track.

## Track event types

There is only one type of track event.

### `track`

The {{domxref("RTCPeerConnection.track_event", "track")}} event is sent to the {{domxref("RTCPeerConnection")}} when a new track has been added to the connection. By the time the `track` event is delivered to the `RTCPeerConnection`'s {{domxref("RTCPeerConnection.track_event", "ontrack")}} handler, the new media has completed its negotiation for a specific {{domxref("RTCRtpReceiver")}} (which is specified by the event's {{domxref("RTCTrackEvent.receiver", "receiver")}} property).

In addition, the {{domxref("MediaStreamTrack")}} specified by the receiver's {{domxref("RTCRtpReceiver.track", "track")}} is the same one specified by the event's {{domxref("RTCTrackEvent.track", "track")}}, and the track has been added to any associated remote {{domxref("MediaStream")}} objects.

You can add a `track` event listener to be notified when the new track is available so that you can, for example, attach its media to a {{HTMLElement("video")}} element, using either {{domxref("EventTarget.addEventListener", "RTCPeerConnection.addEventListener()")}} or the `ontrack` event handler property.

> [!NOTE]
> It may be helpful to keep in mind that you receive the `track` event when a new inbound track has been added to your connection, and you call {{domxref("RTCPeerConnection.addTrack", "addTrack()")}} to add a track to the far end of the connection, thereby triggering a `track` event on the remote peer.

## Example

This simple example creates an event listener for the {{domxref("RTCPeerConnection.track_event", "track")}} event which sets the {{domxref("HTMLMediaElement.srcObject", "srcObject")}} of the {{HTMLElement("video")}} element with the ID `video-box` to the first stream in the list passed in the event's {{domxref("RTCTrackEvent.streams", "streams")}} array.

```js
peerConnection.addEventListener("track", (e) => {
  let videoElement = document.getElementById("video-box");
  videoElement.srcObject = e.streams[0];
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTrackEvent: receiver property

{{APIRef("WebRTC")}}

The read-only **`receiver`** property
of the {{domxref("RTCTrackEvent")}} interface indicates the
{{domxref("RTCRtpReceiver")}} which is used to receive data containing media for the
{{domxref("RTCTrackEvent.track", "track")}} to which the event refers.

## Value

The {{domxref("RTCRtpReceiver")}} which pairs the `receiver` with a
sender and other properties which establish a single bidirectional {{Glossary("RTP", "SRTP")}}
stream for use by the {{domxref("RTCTrackEvent.track", "track")}} associated with the
`RTCTrackEvent`.

> [!NOTE]
> The {{domxref("RTCTrackEvent.transceiver", "transceiver")}}
> includes its own {{domxref("RTCRtpTransceiver.receiver", "receiver")}} property, which
> will always be the same {{domxref("RTCRtpReceiver")}} as this one.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTrackEvent: RTCTrackEvent() constructor

{{APIRef("WebRTC")}}

The **`RTCTrackEvent()`** constructor creates and returns a new {{domxref("RTCTrackEvent")}} object,
configured to describe the track which has been added to the {{domxref("RTCPeerConnection")}}.

In general, you won't need to use this constructor, as `RTCTrackEvent`
objects are created by WebRTC and delivered to your `RTCPeerConnection`'s
{{domxref("RTCPeerConnection.track_event", "ontrack")}} event handler as appropriate.

## Syntax

```js-nolint
new RTCTrackEvent(type, options)
```

### Parameters

- `type`
  - : A string with the name of the event.
    It is case-sensitive and browsers always set it to `track`.
- `options`
  - : An object that, _in addition of the properties defined in {{domxref("Event/Event", "Event()")}}_, can have the following properties:
    - `receiver`
      - : The {{domxref("RTCRtpReceiver")}} which is being used to receive the track's media.
    - `streams` {{optional_inline}}
      - : An array of {{domxref("MediaStream")}} objects representing each of the streams that comprise the event's corresponding track.
        It defaults to an empty array.
    - `track`
      - : The {{domxref("MediaStreamTrack")}} the event is associated with.
    - `transceiver`
      - : The {{domxref("RTCRtpTransceiver")}} associated with the event.

### Return value

A new {{domxref("RTCTrackEvent")}} describing a track which has been added to the
`RTCPeerConnection`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTrackEvent: streams property

{{APIRef("WebRTC")}}

The [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
interface {{domxref("RTCTrackEvent")}}'s read-only
**`streams`** property specifies an array of
{{domxref("MediaStream")}} objects, one for each of the streams that comprise the
track being added to the {{domxref("RTCPeerConnection")}}.

## Value

An {{jsxref("Array")}} of {{domxref("MediaStream")}} objects, one for each stream that
make up the new track.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTrackEvent: track property

{{APIRef("WebRTC")}}

The [WebRTC API](/en-US/docs/Web/API/WebRTC_API)
interface {{domxref("RTCTrackEvent")}}'s read-only **`track`**
property specifies the {{domxref("MediaStreamTrack")}} that has been added to the
{{domxref("RTCPeerConnection")}}.

## Value

A {{domxref("MediaStreamTrack")}} indicating the track which has been added to the
{{domxref("RTCPeerConnection")}}.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTrackEvent: transceiver property

{{APIRef("WebRTC")}}

The WebRTC API interface {{domxref("RTCTrackEvent")}}'s
read-only **`transceiver`** property indicates the
{{domxref("RTCRtpTransceiver")}} affiliated with the event's
{{domxref("RTCTrackEvent.track", "track")}}.

The transceiver pairs the track's
{{domxref("RTCTrackEvent.receiver", "receiver")}} with an {{domxref("RTCRtpSender")}}.

## Value

The {{domxref("RTCRtpTransceiver")}} which pairs the `receiver` with a
sender and other properties which establish a single bidirectional {{Glossary("RTP", "SRTP")}}
stream for use by the {{domxref("RTCTrackEvent.track", "track")}} associated with the
`RTCTrackEvent`.

> [!NOTE]
> The {{domxref("RTCRtpReceiver")}} referred to by this
> `RTCRtpReceiver`'s {{domxref("RTCRtpTransceiver.receiver", "receiver")}}
> property will always be the same as the {{domxref("RTCTrackEvent")}}'s
> {{domxref("RTCTrackEvent.receiver", "receiver")}} property.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransformEvent

{{APIRef("WebRTC")}}

The **`RTCTransformEvent`** of the [WebRTC API](/en-US/docs/Web/API/WebRTC_API) represent an event that is fired in a dedicated worker when an encoded frame has been queued for processing by a [WebRTC Encoded Transform](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms).

The interface has a {{domxref("RTCTransformEvent.transformer","transformer")}} property that exposes a readable stream and a writable stream.
A worker should read encoded frames from `transformer.readable`, modify them as needed, and write them to `transformer.writable` in the same order and without any duplication.

At time of writing there is just one event based on `RTCTransformEvent`: {{domxref("DedicatedWorkerGlobalScope.rtctransform_event", "rtctransform")}}.

{{InheritanceDiagram}}

## Instance properties

_Since `RTCTransformEvent` is based on {{domxref("Event")}}, its properties are also available._

- {{domxref("RTCTransformEvent.transformer")}} {{ReadOnlyInline}}
  - : Returns the {{domxref("RTCRtpScriptTransformer")}} associated with the event.

## Transform event types

There is only one type of transform event.

### `rtctransform`

The {{domxref("DedicatedWorkerGlobalScope.rtctransform_event", "rtctransform")}} event is fired at the worker global scope on construction of an associated {{domxref("RTCRtpScriptTransform")}}, and whenever a new encoded video or audio frame is enqueued for processing.

You can add a `rtctransform` event listener to be notified when the new frame is available using either {{domxref("EventTarget.addEventListener", "DedicatedWorkerGlobalScope.addEventListener()")}} or the `onrtctransform` event handler property.

## Example

This example creates an event listener for the {{domxref("DedicatedWorkerGlobalScope.rtctransform_event", "rtctransform")}} event.

The example assumes we have a {{domxref("TransformStream")}} with an `options` object passed from a {{domxref("RTCRtpScriptTransform")}} constructor in the main-thread.
The code at the end shows how the stream is piped through the transform stream from the `readable` to the `writable`.

```js
addEventListener("rtctransform", (event) => {
  let transform;
  // Select a transform based on passed options
  if (event.transformer.options.name === "senderTransform") {
    transform = createSenderTransform(); // A TransformStream (not shown)
  } else if (event.transformer.options.name === "receiverTransform") {
    transform = createReceiverTransform(); // A TransformStream (not shown)
  }
  // Pipe frames from the readable to writeable through TransformStream
  event.transformer.readable
    .pipeThrough(transform)
    .pipeTo(event.transformer.writable);
});
```

Note that this code is part of a more complete example provided in [Using WebRTC Encoded Transforms](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

- [Using WebRTC Encoded Transforms](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms)
- {{domxref("TransformStream")}}
# RTCTransformEvent: transformer property

{{APIRef("WebRTC")}}

The read-only **`transformer`** property of the {{domxref("RTCTransformEvent")}} interface returns the {{domxref("RTCRtpScriptTransformer")}} associated with the event.

The property exposes the WebRTC sender or receiver pipeline as a readable and writable stream of encoded media frames, which a [WebRTC Encoded Transform](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms) can insert itself into in order to modify frames.

## Value

A {{domxref("RTCRtpScriptTransformer")}}.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Using WebRTC Encoded Transforms](/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms)
# RTCTransportStats: bytesReceived property

{{APIRef("WebRTC")}}

The **`bytesReceived`** property of the {{domxref("RTCTransportStats")}} dictionary indicates the total number of payload bytes received on this transport.

Only data bytes are counted; overhead such as padding, headers, and so on are not included in this count.

## Value

A positive integer indicating the number of received payload bytes.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: bytesSent property

{{APIRef("WebRTC")}}

The **`bytesSent`** property of the {{domxref("RTCTransportStats")}} dictionary indicates the total number of payload bytes sent on this transport.

Only data bytes are counted; overhead such as padding, headers, and so on are not included in this count.

## Value

A positive integer indicating the number of sent payload bytes.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: dtlsCipher property

{{APIRef("WebRTC")}}

The **`dtlsCipher`** property of the {{domxref("RTCTransportStats")}} dictionary is a string that indicates the descriptive name of the cipher suite used for the DTLS transport.

Allowed names are defined in the "Description" column of the [TLS Cipher Suites](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#table-tls-parameters-4) section in the _IANA cipher suite registry_.
For example `"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"`.

## Value

A string indicating the name of the DTLS cipher.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: dtlsRole property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`dtlsRole`** property of the {{domxref("RTCTransportStats")}} dictionary is a string that indicates the role of the associated {{domxref("RTCPeerConnection")}} in the DTLS negotiation.

Specifically, whether it acted like a server and listened for connections, or like a client and initiated the connection, or that negotiation has not yet started.

## Value

A string indicating the DTLS role.
This will be one of:

- `client`
  - : The peer initiated the DTLS handshake.
- `server`
  - : The peer waited for the DTLS handshake.
- `unknown`
  - : DTLS negotiation has not started.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: dtlsState property

{{APIRef("WebRTC")}}

The **`dtlsState`** property of the {{domxref("RTCTransportStats")}} dictionary is a string that indicates the current state of the underlying {{domxref("RTCDtlsTransport")}}.

This has the same value as the corresponding {{domxref("RTCDtlsTransport.state")}} property.

## Value

A string that will be one of the following values: `new`, `connecting`, `connected`, `closed`, `failed`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: iceLocalUsernameFragment property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`iceLocalUsernameFragment`** property of the {{domxref("RTCTransportStats")}} dictionary is a string that indicates the local username fragment ("ufrag" or "ice-ufrag") that uniquely identifies the ICE interaction session managed by this transport.

The same username fragment is used to identify the session for any communication with the STUN server.

This has the same values as the corresponding local {{domxref("RTCIceCandidate.usernameFragment")}} property.
It will change if the connection is renegotiated, for example on ICE restart, or if {{domxref("RTCPeerConnection.setLocalDescription()")}} is called.

## Value

A string containing the username fragment that uniquely identifies the ongoing ICE session on the transport.

The string may be up to 256 characters long, and has no default value.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: iceRole property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`iceRole`** property of the {{domxref("RTCTransportStats")}} dictionary is a string that indicates the ICE role that the transport is fulfilling: that of the controlling agent, or the agent that is being controlled.

This has the same value as the {{domxref("RTCIceTransport.role")}} property of the underlying {{domxref("RTCDtlsTransport.iceTransport")}}.

## Value

A string that will be one of the following values: `controlled`, `controlling`, or `unknown`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: iceState property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`iceState`** property of the {{domxref("RTCTransportStats")}} dictionary is a string that indicates the current ICE state of the underlying {{domxref("RTCIceTransport")}}.

This has the same value as the corresponding {{domxref("RTCIceTransport.state")}} property.

## Value

A string that will be one of the following values: `new`, `checking`, `connected`, `completed`, `disconnected`, `failed`, or `closed`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: id property

{{APIRef("WebRTC")}}

The **`id`** property of the {{domxref("RTCTransportStats")}} dictionary is a string which uniquely identifies the object for which this object provides statistics.

Using the `id`, you can correlate this statistics object with others, in order to monitor statistics over time for a given WebRTC object, such as an {{domxref("RTCDtlsTransport")}}, or an {{domxref("RTCPeerConnection")}}.

## Value

A string that uniquely identifies the object for which this `RTCTransportStats` object provides statistics.

The format of the ID string is not defined by the specification, so you cannot reliably make any assumptions about the contents of the string, or assume that the format of the string will remain unchanged for a given object type.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats

{{APIRef("WebRTC")}}

The **`RTCTransportStats`** dictionary of the [WebRTC API](/en-US/docs/Web/API/WebRTC_API) provides information about the transport ({{domxref("RTCDtlsTransport")}} and its underlying {{domxref("RTCIceTransport")}}) used by a particular candidate pair.

The _BUNDLE_ feature is an SDP extension that allows negotiation to use a single transport for sending and receiving media described by multiple SDP media descriptions.
If the remote endpoint is aware of this feature, all {{domxref("MediaStreamTrack")}} and data channels are bundled onto a single transport at the completion of negotiation.
This is true for current browsers, but if connecting to an older endpoint that is not BUNDLE-aware, then separate transports might be used for different media.
The policy to use in the negotiation is configured in the [`RTCPeerConnection` constructor](/en-US/docs/Web/API/RTCPeerConnection/RTCPeerConnection).

These statistics can be obtained by iterating the {{domxref("RTCStatsReport")}} returned by {{domxref("RTCPeerConnection.getStats()")}} until you find a report with the [`type`](/en-US/docs/Web/API/RTCTransportStats/type) of `transport`.

## Instance properties

- {{domxref("RTCTransportStats.bytesReceived", "bytesReceived")}} {{optional_inline}}
  - : The total number of payload bytes received on this transport (bytes received, not including headers, padding or ICE connectivity checks).
- {{domxref("RTCTransportStats.bytesSent", "bytesSent")}} {{optional_inline}}
  - : The total number of payload bytes sent on this transport (bytes sent, not including headers, padding or ICE connectivity checks).
- {{domxref("RTCTransportStats.dtlsCipher", "dtlsCipher")}} {{optional_inline}}
  - : A string indicating the name of the cipher suite used for the DTLS transport, such as `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`.
- {{domxref("RTCTransportStats.dtlsRole", "dtlsRole")}} {{optional_inline}} {{experimental_inline}}
  - : A string indicating the DTLS role of the associated {{domxref("RTCPeerConnection")}}.
    This is one of: `client`, `server`, `unknown` (before the DTLS negotiation starts).
- {{domxref("RTCTransportStats.dtlsState", "dtlsState")}}
  - : A string indicating the current {{domxref("RTCDtlsTransport.state","state")}} of the underlying {{domxref("RTCDtlsTransport")}}.
    This is one of: `new`, `connecting`, `connected`, `closed`, `failed`.
- {{domxref("RTCTransportStats.iceLocalUsernameFragment", "iceLocalUsernameFragment")}} {{optional_inline}} {{experimental_inline}}
  - : A string indicating the local username fragment that uniquely identifies the ICE interaction session managed by this transport.
- {{domxref("RTCTransportStats.iceRole", "iceRole")}} {{optional_inline}} {{experimental_inline}}
  - : A string indicating the ICE [`role`](/en-US/docs/Web/API/RTCIceTransport/role) of the underlying {{domxref("RTCIceTransport")}}.
    This is one of: `controlled`, `controlling`, or `unknown`.
- {{domxref("RTCTransportStats.iceState", "iceState")}} {{optional_inline}} {{experimental_inline}}
  - : A string indicating the current {{domxref("RTCIceTransport.state","state")}} of the underlying {{domxref("RTCIceTransport")}}.
    This is one of: `new`, `checking`, `connected`, `completed`, `disconnected`, `failed`, or `closed`.
- {{domxref("RTCTransportStats.localCertificateId", "localCertificateId")}} {{optional_inline}}
  - : A string containing the id of the local certificate used by this transport.
    Only present for DTLS transports, and after DTLS has been negotiated.
- {{domxref("RTCTransportStats.packetsReceived", "packetsReceived")}} {{optional_inline}} {{experimental_inline}}
  - : The total number of packets received on this transport.
- {{domxref("RTCTransportStats.packetsSent", "packetsSent")}} {{optional_inline}} {{experimental_inline}}
  - : The total number of packets sent over this transport.
- {{domxref("RTCTransportStats.remoteCertificateId", "remoteCertificateId")}} {{optional_inline}}
  - : A string containing the id or the remote certificate used by this transport.
    Only present for DTLS transports, and after DTLS has been negotiated.
- {{domxref("RTCTransportStats.selectedCandidatePairChanges", "selectedCandidatePairChanges")}} {{optional_inline}}
  - : The number of times that the selected candidate pair of this transport has changed.
    The value is initially zero and increases whenever a candidate pair selected or lost.
- {{domxref("RTCTransportStats.selectedCandidatePairId", "selectedCandidatePairId")}} {{optional_inline}}
  - : A string containing the unique identifier for the object that was inspected to produce the {{domxref("RTCIceCandidatePairStats")}} associated with this transport.
- {{domxref("RTCTransportStats.srtpCipher", "srtpCipher")}} {{optional_inline}}
  - : A string indicating the descriptive name of the protection profile used for the [Secure Real-time Transport Protocol (SRTP)](/en-US/docs/Glossary/RTP) transport.
- {{domxref("RTCTransportStats.tlsVersion", "tlsVersion")}} {{optional_inline}}
  - : A string containing the negotiated TLS version.
    This is present for DTLS transports, and only exists after DTLS has been negotiated.

### Common instance properties

The following properties are common to all WebRTC statistics objects.

<!-- RTCStats -->

- {{domxref("RTCTransportStats.id", "id")}}
  - : A string that uniquely identifies the object that is being monitored to produce this set of statistics.
- {{domxref("RTCTransportStats.timestamp", "timestamp")}}
  - : A {{domxref("DOMHighResTimeStamp")}} object indicating the time at which the sample was taken for this statistics object.
- {{domxref("RTCTransportStats.type", "type")}}
  - : A string with the value `"transport"`, indicating the type of statistics that the object contains.

## Examples

This example shows a function to return the transport statistics, or `null` if no statistics are provided.

The function waits for the result of a call to {{domxref("RTCPeerConnection.getStats()")}} and then iterates the returned {{domxref("RTCStatsReport")}} to get just the stats of type `"transport"`.
It then returns the statistics, or `null`, using the data in the report.

```js
async function numberOpenConnections (peerConnection) {
  const stats = await peerConnection.getStats();
  let transportStats = null;

  stats.forEach((report) => {
    if (report.type === "transport") {
      transportStats = report;
      break;
    }
  });

return transportStats
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: localCertificateId property

{{APIRef("WebRTC")}}

The **`localCertificateId`** property of the {{domxref("RTCTransportStats")}} dictionary is a string that indicates the id of the local certificate used by this {{domxref("RTCIceTransport")}}.

It is only present for DTLS transports, and after DTLS has been negotiated.

## Value

A string that containing the id of the local certificate used by this transport.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: packetsReceived property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`packetsReceived`** property of the {{domxref("RTCTransportStats")}} dictionary indicates the total number of packets received on this transport.

## Value

A positive integer indicating the number of packets received on the transport.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: packetsSent property

{{APIRef("WebRTC")}}{{SeeCompatTable}}

The **`packetsSent`** property of the {{domxref("RTCTransportStats")}} dictionary indicates the total number of packets sent over this transport.

## Value

A positive integer indicating the number of packets sent on the transport.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: remoteCertificateId property

{{APIRef("WebRTC")}}

The **`remoteCertificateId`** property of the {{domxref("RTCTransportStats")}} dictionary is a string that indicates the id of the remote certificate used by this {{domxref("RTCIceTransport")}}.

It is only present for DTLS transports, and after DTLS has been negotiated.

## Value

A string that containing the id of the remote certificate used by this transport.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: selectedCandidatePairChanges property

{{APIRef("WebRTC")}}

The **`selectedCandidatePairChanges`** property of the {{domxref("RTCTransportStats")}} dictionary indicates the total number of times that the selected candidate pair of this transport has changed.

## Value

A positive integer that is initially zero and increases whenever a candidate pair is selected or lost.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: selectedCandidatePairId property

{{APIRef("WebRTC")}}

The **`selectedCandidatePairId`** property of the {{domxref("RTCTransportStats")}} dictionary represents the unique identifier for the candidate pair stats associated with this transport.

## Value

A string that contains the unique identifier for the object that was inspected to produce the {{domxref("RTCIceCandidatePairStats")}} associated with this transport.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: srtpCipher property

{{APIRef("WebRTC")}}

The **`srtpCipher`** property of the {{domxref("RTCTransportStats")}} dictionary indicates the descriptive name of the protection profile used for the [Secure Real-time Transport Protocol (SRTP)](/en-US/docs/Glossary/RTP) transport.

## Value

A string that indicates the descriptive name of the SRTP protection profile.

Values are defined in the "Profile" column of the [IANA DTLS-SRTP protection profile registry](https://www.iana.org/assignments/srtp-protection/srtp-protection.xhtml#srtp-protection-1) and {{rfc("5764","", "4.1.2")}}.

## Examples

### SRTP_AES128_CM_HMAC_SHA1_80

`"SRTP_AES128_CM_HMAC_SHA1_80"` is the descriptive name of the following profile, where `maximum_lifetime` is the maximum number of packets that can be protected by a single set of keys.

```plain
SRTP_AES128_CM_HMAC_SHA1_80
cipher: AES_128_CM
cipher_key_length: 128
cipher_salt_length: 112
maximum_lifetime: 2^31
auth_function: HMAC-SHA1
auth_key_length: 160
auth_tag_length: 80
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: timestamp property

{{APIRef("WebRTC")}}

The **`timestamp`** property of the {{domxref("RTCTransportStats")}} dictionary is a {{domxref("DOMHighResTimeStamp")}} object specifying the time at which the data in the object was sampled.

## Value

A {{domxref("DOMHighResTimeStamp")}} value indicating the time at which the activity described by the statistics in this object was recorded, in milliseconds elapsed since the beginning of January 1, 1970, UTC.

The value should be accurate to within a few milliseconds but may not be entirely precise, either because of hardware or operating system limitations or because of [fingerprinting](/en-US/docs/Glossary/Fingerprinting) protection in the form of reduced clock precision or accuracy.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: tlsVersion property

{{APIRef("WebRTC")}}

The **`tlsVersion`** property of the {{domxref("RTCTransportStats")}} dictionary indicates the negotiated TLS version of an underlying DTLS transport.

It is only present for DTLS transports, and only exists after DTLS has been negotiated.

The value comes from the DTLS handshake `ServerHello.version`, and is represented as four upper case hexadecimal digits, where the digits represent the two bytes of the version.
Note however that the bytes might not map directly to version numbers.
For example, DTLS represents version 1.2 as `'FEFD'` which numerically is `{254, 253}`.

## Value

A string that indicates the negotiated DTS transport.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCTransportStats: type property

{{APIRef("WebRTC")}}

The **`type`** property of the {{domxref("RTCTransportStats")}} dictionary is a string with the value `"transport"`.

Different statistics are obtained by iterating the {{domxref("RTCStatsReport")}} object returned by a call to {{domxref("RTCPeerConnection.getStats()")}}.
The type indicates the set of statistics available through the object in a particular iteration step.
A value of `"transport"` indicates that the statistics available in the current step are those defined in {{domxref("RTCTransportStats")}}.

## Value

A string with the value `"transport"`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCVideoSourceStats: frames property

{{APIRef("WebRTC")}}

The **`frames`** property of the {{domxref("RTCVideoSourceStats")}} dictionary indicates the total number of frames originating from this video source over its lifetime.

## Value

A number indicating the total number of frames originating from this source.

## Examples

This example shows how you might iterate the stats object returned from `RTCRtpSender.getStats()` to get the video source stats, and then extract the `frames`.

```js
// where sender is an RTCRtpSender
const stats = await sender.getStats();
let videoSourceStats = null;

stats.forEach((report) => {
  if (report.type === "media-source" && report.kind==="video") {
    videoSourceStats = report;
    break;
  }
});

const frames = videoSourceStats?.frames;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCVideoSourceStats: framesPerSecond property

{{APIRef("WebRTC")}}

The **`framesPerSecond`** property of the {{domxref("RTCVideoSourceStats")}} dictionary indicates the number of frames originating from this video source in the last second.

The property is not defined on the stats object for the first second of its lifetime.

## Value

A number indicating the frames originating from this source in the last second.

## Examples

This example shows how you might iterate the stats object returned from `RTCRtpSender.getStats()` to get the video source stats, and then extract the `framesPerSecond`.

```js
// where sender is an RTCRtpSender
const stats = await sender.getStats();
let videoSourceStats = null;

stats.forEach((report) => {
  if (report.type === "media-source" && report.kind==="video") {
    videoSourceStats = report;
    break;
  }
});

// Note, test is conditional in case the stats object
// does not include video source stats
const fps = videoSourceStats?.framesPerSecond;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCVideoSourceStats: height property

{{APIRef("WebRTC")}}

The **`height`** property of the {{domxref("RTCVideoSourceStats")}} dictionary indicates the height, in pixels, of the last frame originating from this source.

This property is not defined on the stats object until after the first frame has been produced.

## Value

A positive number indicating the height, in pixels.

## Examples

This example shows how you might iterate the stats object returned from `RTCRtpSender.getStats()` to get the video source stats, and then extract the `height`.

```js
// where sender is an RTCRtpSender
const stats = await sender.getStats();
let videoSourceStats = null;

stats.forEach((report) => {
  if (report.type === "media-source" && report.kind==="video") {
    videoSourceStats = report;
    break;
  }
});

// Note, test is conditional in case the stats object
// does not include video source stats
const height = videoSourceStats?.height;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCVideoSourceStats: id property

{{APIRef("WebRTC")}}

The **`id`** property of the {{domxref("RTCVideoSourceStats")}} dictionary is a string which uniquely identifies the object for which this object provides statistics.

Using the `id`, you can correlate this statistics object with others, in order to monitor statistics over time for a given WebRTC object, such as an {{domxref("RTCPeerConnection")}}, or an {{domxref("RTCDataChannel")}}.

## Value

A string that uniquely identifies the object for which this `RTCVideoSourceStats` object provides statistics.

The format of the ID string is not defined by the specification, so you cannot reliably make any assumptions about the contents of the string, or assume that the format of the string will remain unchanged for a given object type.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCVideoSourceStats

{{APIRef("WebRTC")}}

The **`RTCVideoSourceStats`** dictionary of the [WebRTC API](/en-US/docs/Web/API/WebRTC_API) provides statistics information about a video track ({{domxref("MediaStreamTrack")}}) that is attached to one or more senders ({{domxref("RTCRtpSender")}}).

These statistics can be obtained by iterating the {{domxref("RTCStatsReport")}} returned by {{domxref("RTCRtpSender.getStats()")}} or {{domxref("RTCPeerConnection.getStats()")}} until you find a report with the [`type`](/en-US/docs/Web/API/RTCVideoSourceStats/type) of `media-source` and a [`kind`](/en-US/docs/Web/API/RTCVideoSourceStats/kind) of `video`.

> [!NOTE]
> For video information about remotely sourced tracks (that are being received), see {{domxref("RTCInboundRtpStreamStats")}}.

## Instance properties

- {{domxref("RTCVideoSourceStats.frames", "frames")}} {{optional_inline}}
  - : A positive number that indicates the total number of frames originating from this video source.
- {{domxref("RTCVideoSourceStats.framesPerSecond", "framesPerSecond")}} {{optional_inline}}
  - : A positive number that represents the number of frames originating from this video source in the last second.
    This property is not defined on this stats object for the first second of its existence.
- {{domxref("RTCVideoSourceStats.height", "height")}} {{optional_inline}}
  - : A number that represents the height, in pixels, of the last frame originating from this source.
    This property is not defined on this stats object until after the first frame has been produced.
- {{domxref("RTCVideoSourceStats.width", "width")}} {{optional_inline}}
  - : A number that represents the width, in pixels, of the most recent frame originating from this source.
    This property is not defined on this stats object until after the first frame has been produced.

### Common media-source properties

The following properties are present in both `RTCVideoSourceStats` and {{domxref("RTCAudioSourceStats")}}: <!-- RTCMediaSourceStats  -->

- {{domxref("RTCVideoSourceStats.trackIdentifier", "trackIdentifier")}}
  - : A string that contains the [`id`](/en-US/docs/Web/API/MediaStreamTrack/id) value of the [`MediaStreamTrack`](/en-US/docs/Web/API/MediaStreamTrack) associated with the video source.
- {{domxref("RTCVideoSourceStats.kind", "kind")}}
  - : A string indicating whether this object represents stats for a video source or a media source. For an `RTCVideoSourceStats` this will always be `video`.

### Common instance properties

The following properties are common to all statistics objects. <!-- RTCStats -->

- {{domxref("RTCVideoSourceStats.id", "id")}}
  - : A string that uniquely identifies the object that is being monitored to produce this set of statistics.
- {{domxref("RTCVideoSourceStats.timestamp", "timestamp")}}
  - : A {{domxref("DOMHighResTimeStamp")}} object indicating the time at which the sample was taken for this statistics object.
- {{domxref("RTCVideoSourceStats.type", "type")}}
  - : A string with the value `"media-source"`, indicating that the object is an instance of either {{domxref("RTCAudioSourceStats")}} or `RTCVideoSourceStats`.

## Description

The interface provides statistics about a video media source attached to one or more senders.
The information includes a identifier for the associated `MediaStreamTrack`, along with the height and width of the last frame sent from the source, the number of frames sent from the source, and the frame rate.

## Examples

This example shows how you might iterate the stats object returned from `RTCRtpSender.getStats()` to get the video-specific media-source stats.

```js
// where sender is an RTCRtpSender
const stats = await sender.getStats();
let videoSourceStats = null;

stats.forEach((report) => {
  if (report.type === "media-source" && report.kind==="video") {
    videoSourceStats = report;
    break;
  }
});

// videoSourceStats will be null if the report did not include video source stats
const frames = videoSourceStats?.frames;
const fps = videoSourceStats?.framesPerSecond;
const width = videoSourceStats?.width;
const height = videoSourceStats?.height;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCVideoSourceStats: kind property

{{APIRef("WebRTC")}}

The **`kind`** property of the {{domxref("RTCVideoSourceStats")}} dictionary is a string with the value `video`.

The `kind` is used to differentiate between audio and video media sources when iterating an {{domxref("RTCStatsReport")}}, which both have a {{domxref("RTCVideoSourceStats.type", "type")}} of `media-source` (a `kind` of `audio` indicates an {{domxref("RTCAudioSourceStats")}} object).

## Value

A string with the value `video`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCVideoSourceStats: timestamp property

{{APIRef("WebRTC")}}

The **`timestamp`** property of the {{domxref("RTCVideoSourceStats")}} dictionary is a {{domxref("DOMHighResTimeStamp")}} object specifying the time at which the data in the object was sampled.

The time is given in milliseconds elapsed since the first moment of January 1, 1970, UTC (also known as [Unix time](/en-US/docs/Glossary/Unix_time)).

## Value

A {{domxref("DOMHighResTimeStamp")}} value indicating the time at which the activity described by the statistics in this object was recorded, in milliseconds elapsed since the beginning of January 1, 1970, UTC.

The value should be accurate to within a few milliseconds but may not be entirely precise, either because of hardware or operating system limitations or because of [fingerprinting](/en-US/docs/Glossary/Fingerprinting) protection in the form of reduced clock precision or accuracy.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCVideoSourceStats: trackIdentifier property

{{APIRef("WebRTC")}}

The **`trackIdentifier`** property of the {{domxref("RTCVideoSourceStats")}} dictionary contains the `id` attribute of the associated [`MediaStreamTrack`](/en-US/docs/Web/API/MediaStreamTrack).

## Value

A string containing the value of the associated [`MediaStreamTrack.id`](/en-US/docs/Web/API/MediaStreamTrack/id).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCVideoSourceStats: type property

{{APIRef("WebRTC")}}

The **`type`** property of the {{domxref("RTCVideoSourceStats")}} dictionary is a string with value `media-source`.

The type of `media-source` identifies the type of statistics as either {{domxref("RTCAudioSourceStats")}} or {{domxref("RTCVideoSourceStats")}} when iterating the {{domxref("RTCStatsReport")}} returned by {{domxref("RTCRtpSender.getStats()")}} or {{domxref("RTCPeerConnection.getStats()")}}.
The type of stats can further be differentiated using the {{domxref("RTCVideoSourceStats.kind", "kind")}}, which will be `video` for `RTCVideoSourceStats`.

## Value

A string with the value `media-source`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# RTCVideoSourceStats: width property

{{APIRef("WebRTC")}}

The **`width`** property of the {{domxref("RTCVideoSourceStats")}} dictionary indicates the width, in pixels, of the last frame originating from this source.

This property is not defined on the stats object until after the first frame has been produced.

## Value

A positive number indicating the width, in pixels.

## Examples

This example shows how you might iterate the stats object returned from `RTCRtpSender.getStats()` to get the video source stats, and then extract the `width`.

```js
// where sender is an RTCRtpSender
const stats = await sender.getStats();
let videoSourceStats = null;

stats.forEach((report) => {
  if (report.type === "media-source" && report.kind==="video") {
    videoSourceStats = report;
    break;
  }
});

// Note, test is conditional in case the stats object
// does not include video source stats
const height = videoSourceStats?.width;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sanitizer: allowAttribute() method

{{APIRef("HTML Sanitizer API")}}{{SeeCompatTable}}

The **`allowAttribute()`** method of the {{domxref("Sanitizer")}} interface sets an attribute to be allowed on all elements.

The specified attribute is added to the list of [`attributes`](/en-US/docs/Web/API/SanitizerConfig#attributes_2) in this sanitizer's configuration.
The attribute is removed from the [`removeAttributes`](/en-US/docs/Web/API/SanitizerConfig#removeattributes_2) list if present.

Note that to allow/disallow attributes only on specific elements use {{domxref('Sanitizer.allowElement()')}}.

## Syntax

```js-nolint
allowAttribute(attribute)
```

### Parameters

- `attribute`
  - : A string indicating the name of the attribute to be allowed globally on elements, or an object with the following properties:
    - `name`
      - : A string containing the name of the attribute.
    - `namespace` {{optional_inline}}
      - : A string containing the namespace of the attribute, which defaults to `null`.

### Return value

None (`undefined`).

## Examples

### How to allow specific attributes on elements

This example shows how `allowAttribute()` is used to specify that an attribute is allowed on elements.

```html hidden
<pre id="log"></pre>
```

```css hidden
#log {
  height: 420px;
  overflow: scroll;
  padding: 0.5rem;
  border: 1px solid black;
}
```

```js hidden
const logElement = document.querySelector("#log");
function log(text) {
  logElement.textContent = text;
}
```

#### JavaScript

The code first creates a new `Sanitizer` object that initially allows no attributes.
We then call `allowAttribute()` with the attributes `title` and `mathcolor`.

```js hidden
if ("Sanitizer" in window) {
```

```js
// Create an allow sanitizer
const sanitizer = new Sanitizer({
  attributes: [],
});

// Allow the "title" attribute
sanitizer.allowAttribute("title");
// Allow the "mathcolor" attribute
sanitizer.allowAttribute("mathcolor");

// Log the sanitizer configuration
let sanitizerConfig = sanitizer.get();
log(JSON.stringify(sanitizerConfig, null, 2));
```

```js hidden
} else {
  log("The HTML Sanitizer API is NOT supported in this browser.");
}
```

#### Results

The final configuration is logged below.
Note how both attributes are now added to the [`attributes`](/en-US/docs/Web/API/SanitizerConfig#attributes_2) list (other attributes will not be allowed on elements when the sanitizer is used).

{{EmbedLiveSample("How to allow specific attributes on elements","100","480px")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sanitizer: allowElement() method

{{APIRef("HTML Sanitizer API")}}{{SeeCompatTable}}

The **`allowElement()`** method of the {{domxref("Sanitizer")}} interface sets that the specified element is allowed in the output when the sanitizer is used.
The element can be specified with lists of attributes that are allowed or disallowed on elements of that type.

The specified element is added to the [`elements`](/en-US/docs/Web/API/SanitizerConfig#elements) list in this sanitizer's configuration.
If the element is already present in the list, then the existing entry is first removed and the new definition is appended to the end of the list.
Note that if you need both per-element add-attribute and remove-attribute lists, they must be added in a single call to this method (since if done in two calls, the second call will replace the element definition added in the first call).

The specified element is removed from the sanitizer configuration [`removeElements`](/en-US/docs/Web/API/SanitizerConfig#removeelements) or [`replaceWithChildrenElements`](/en-US/docs/Web/API/SanitizerConfig#replacewithchildrenelements) lists if present.

## Syntax

```js-nolint
allowElement(element)
```

### Parameters

- `element`
  - : A string indicating the name of the allowed element, or an object with the following properties:
    - `name`
      - : A string containing the name of the element.
    - `namespace` {{optional_inline}}
      - : A string containing the namespace of the element.
        The default namespace is `"http://www.w3.org/1999/xhtml"`.
    - `attributes` {{optional_inline}}
      - : An array indicating the attributes to allow on this (allowed) element when sanitizing HTML.

        Each attribute can be specified by name (a string), or as a object with the following properties:
        - `name`
          - : A string containing the name of the attribute.
        - `namespace` {{optional_inline}}
          - : A string containing the namespace of the attribute, which defaults to `null`.

    - `removeAttributes` {{optional_inline}}
      - : An array indicating the attributes to remove on this (allowed) element when sanitizing HTML.

        Each attribute can be specified by name (a string), or as a object with the following properties:
        - `name`
          - : A string containing the name of the attribute.
        - `namespace` {{optional_inline}}
          - : A string containing the namespace of the attribute, which defaults to `null`.

### Return value

None (`undefined`).

## Examples

### How to allow elements

This example shows how `allowElement()` is used to add an element to the sanitizer's [`elements` configuration](/en-US/docs/Web/API/SanitizerConfig#elements) (the list of allowed elements).

```html hidden
<pre id="log"></pre>
```

```css hidden
#log {
  height: 400px;
  overflow: scroll;
  padding: 0.5rem;
  border: 1px solid black;
}
```

```js hidden
const logElement = document.querySelector("#log");
function log(text) {
  logElement.textContent = text;
}
```

#### JavaScript

The code first creates a new `Sanitizer` object that initially allows {{htmlelement("div")}} and {{htmlelement("script")}} elements.
It then calls `allowElement()` to add a {{htmlelement("p")}} element specified as a string parameter, and then again to add a {{htmlelement("span")}} element specified as an object.
We then get and log the configuration.

```js hidden
if ("Sanitizer" in window) {
```

```js
// Create sanitizer using SanitizerConfig
const sanitizer = new Sanitizer({
  elements: ["div", "script"],
});

// Allow <p> specifying an string
sanitizer.allowElement("p");

// Allow <span> specifying an object
sanitizer.allowElement({ name: "span" });

let sanitizerConfig = sanitizer.get();
log(JSON.stringify(sanitizerConfig, null, 2));
```

```js hidden
} else {
  log("The HTML Sanitizer API is NOT supported in this browser.");
}
```

#### Results

The final configuration is logged below.
This includes the original elements (`<div>` and `<script>`) and the two added with `allowElement()` (`<p>` and `<span>`).

{{EmbedLiveSample("How to allow elements","100","480px")}}

### Allowing elements that are already allowed or removed

This example shows the effect of using `allowElement()` to add elements that are already allowed, or that are in the configuration as "to be removed".

```html hidden
<pre id="log"></pre>
```

```css hidden
#log {
  height: 400px;
  overflow: scroll;
  padding: 0.5rem;
  border: 1px solid black;
}
```

```js hidden
const logElement = document.querySelector("#log");
function log(text) {
  logElement.textContent = text;
}
```

#### JavaScript

The code first creates a new `Sanitizer` object that initially allows {{htmlelement("div")}} elements (removing attributes other than `id`) and also replaced {{htmlelement("span")}} elements with any child elements.

It then calls `allowElement()`, firstly to add a {{htmlelement("div")}} element that removes `style` attributes.
Since the `<div>` element is already allowed, it is removed from the [`elements` configuration](/en-US/docs/Web/API/SanitizerConfig#elements) and the `<div>` element definition is appended.

A {{htmlelement("span")}} element is then added to the allow list, which removes it from the [`replaceWithChildrenElements` configuration list](/en-US/docs/Web/API/SanitizerConfig#replacewithchildrenelements).

```js hidden
if ("Sanitizer" in window) {
```

```js
// Create sanitizer using SanitizerConfig
const sanitizer = new Sanitizer({
  elements: [{ name: "div", attributes: [{ name: "id" }] }],
  replaceWithChildrenElements: ["span"],
});

// Allow <div> elements.
// Allow id elements but strip their style attributes
sanitizer.allowElement({
  name: "div",
  removeAttributes: ["style"],
});

// Allow <span> elements
sanitizer.allowElement("span");

let sanitizerConfig = sanitizer.get();
log(JSON.stringify(sanitizerConfig, null, 2));
```

```js hidden
} else {
  log("The HTML Sanitizer API is NOT supported in this browser.");
}
```

#### Results

The final configuration is logged, and is shown below.
From the log we can see that the original filter for the `<div>` element has been removed and the new definition appended to the `elements` list.
Adding the `<span>` element to the `elements` list has removed it from the `replaceWithChildrenElements` list.

{{EmbedLiveSample("Allowing elements that are already allowed or removed","100","480px")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sanitizer: get() method

{{APIRef("HTML Sanitizer API")}}{{SeeCompatTable}}

The **`get()`** method of the {{domxref("Sanitizer")}} interface returns a {{domxref('SanitizerConfig')}} dictionary instance that represents the current `Sanitizer` configuration.

This may be used to create a sanitizer that is slightly modified from the default; by first getting and then modifying the default sanitizer configuration, and then using it to construct a new sanitizer.

The returned configuration can also be used to inspect the configuration, and can be passed directly the HTML parsing functions.
Note however that it will be more efficient to pass a {{domxref("Sanitizer")}} rather than a configuration dictionary, particularly where the `Sanitizer` is to be used multiple times.

## Syntax

```js-nolint
get()
```

### Parameters

None

### Return value

A {{domxref("SanitizerConfig")}}.

## Examples

### Getting a configuration

This example shows how you might create a new sanitizer and get its configuration.

```html hidden
<pre id="log"></pre>
```

```css hidden
#log {
  height: 400px;
  overflow: scroll;
  padding: 0.5rem;
  border: 1px solid black;
}
```

```js hidden
const logElement = document.querySelector("#log");
function log(text) {
  logElement.textContent = text;
}
```

#### JavaScript

The following code tests whether the `Sanitizer` interface is supported, and if so creates a new `Sanitizer` object using a simple {{domxref("SanitizerConfig")}} that allows the HTML elements: {{htmlelement("div")}}, {{htmlelement("p")}}, {{htmlelement("span")}}, {{htmlelement("script")}}.
It then gets and logs the configuration.

```js hidden
if ("Sanitizer" in window) {
```

```js
// Create sanitizer using SanitizerConfig
const sanitizer = new Sanitizer({ elements: ["div", "p", "span", "script"] });

// Get current configuration
const sanitizerConfig = sanitizer.get();

log(JSON.stringify(sanitizerConfig, null, 2));
```

```js hidden
} else {
  log("The HTML Sanitizer API is NOT supported in this browser.");
}
```

#### Results

The output is logged below.
Note that the same elements set when constructing the sanitizer are returned, but the new elements also have a namespace.
Note also here that comments and data attributes will be allowed.

{{EmbedLiveSample("Getting a configuration","100","480px")}}

### Getting the default sanitizer

This example shows how you can get the configuration for the default `Sanitizer`.
This might then be modified and used to create a new `Sanitizer` that meets your specific needs.

```html hidden
<pre id="log"></pre>
```

```css hidden
#log {
  height: 400px;
  overflow: scroll;
  padding: 0.5rem;
  border: 1px solid black;
}
```

#### JavaScript

The following code tests whether the `Sanitizer` interface is supported.
It then creates the default `Sanitizer`, passing no options, and then gets and logs the configuration.

```js hidden
const logElement = document.querySelector("#log");
function log(text) {
  logElement.textContent = text;
}
```

```js hidden
if ("Sanitizer" in window) {
```

```js
// Create default sanitizer
const sanitizer = new Sanitizer();

// Get default configuration
const defaultConfig = sanitizer.get();

log(JSON.stringify(defaultConfig, null, 2));
```

```js hidden
} else {
  log("The HTML Sanitizer API is NOT supported in this browser.");
}
```

#### Results

The default sanitizer configuration is logged below.
Note that the default configuration is quite big, allowing many elements and attributes.

{{EmbedLiveSample("Getting the default sanitizer","100","480px")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sanitizer

{{APIRef("HTML Sanitizer API")}}{{SeeCompatTable}}

The **`Sanitizer`** interface of the [HTML Sanitizer API](/en-US/docs/Web/API/HTML_Sanitizer_API) defines a configuration object that specifies what elements, attributes and comments are allowed or should be removed when inserting strings of HTML into an {{domxref("Element")}} or {{domxref("ShadowRoot")}}, or when parsing an HTML string into a {{domxref("Document")}}.

A `Sanitizer` instance is effectively a wrapper around a {{domxref("SanitizerConfig")}}, and can be passed as a configuration alternative in the same [sanitization methods](/en-US/docs/Web/API/HTML_Sanitizer_API#sanitization_methods):

- {{domxref("Element/setHTML","setHTML()")}} or {{domxref("Element/setHTMLUnsafe","setHTMLUnsafe()")}} on {{domxref("Element")}}.
- {{domxref("ShadowRoot/setHTML","setHTML()")}} or {{domxref("ShadowRoot/setHTMLUnsafe","setHTMLUnsafe()")}} on {{domxref("ShadowRoot")}}.
- [`Document.parseHTML()`](/en-US/docs/Web/API/Document/parseHTML_static) or [`Document.parseHTMLUnsafe()`](/en-US/docs/Web/API/Document/parseHTMLUnsafe_static) static methods.

Note that `Sanitizer` is expected to be more efficient to reuse and modify when needed.

## Constructors

- {{domxref("Sanitizer.Sanitizer", "Sanitizer()")}} {{experimental_inline}}
  - : Creates and returns a `Sanitizer` object, optionally with custom sanitization behavior defined in a {{domxref('SanitizerConfig')}}.

## Instance methods

- {{domxref('Sanitizer.allowElement()')}} {{experimental_inline}}
  - : Sets an element as allowed by the sanitizer, optionally with an array of attributes that are allowed or disallowed.
- {{domxref('Sanitizer.get()')}} {{experimental_inline}}
  - : Returns the current `Sanitizer` configuration as an {{domxref('SanitizerConfig')}} dictionary instance.
- {{domxref('Sanitizer.removeElement()')}} {{experimental_inline}}
  - : Sets an element to be removed by the sanitizer.
- {{domxref('Sanitizer.removeUnsafe()')}} {{experimental_inline}}
  - : Updates the sanitizer configuration so that it will remove any XSS-unsafe HTML.
- {{domxref('Sanitizer.replaceElementWithChildren()')}} {{experimental_inline}}
  - : Sets an element to be replaced by its child HTML elements.
- {{domxref('Sanitizer.allowAttribute()')}} {{experimental_inline}}
  - : Sets an attribute as allowed on any element.
- {{domxref('Sanitizer.removeAttribute()')}} {{experimental_inline}}
  - : Sets an attribute to be removed from any element.
- {{domxref('Sanitizer.setComments()')}} {{experimental_inline}}
  - : Sets whether comments will be allowed or removed by the sanitizer.
- {{domxref('Sanitizer.setDataAttributes()')}} {{experimental_inline}}
  - : Sets whether data attributes on elements will be allowed or removed by the sanitizer.

## Examples

For more examples see the [HTML Sanitizer API](/en-US/docs/Web/API/HTML_Sanitizer_API) and the individual methods.
Below we show a few examples of how you might create different sanitizer configurations.

### Creating a default sanitizer

The default sanitizer is constructed as shown below.

```js
const sanitizer = new Sanitizer();
```

The XSS-safe [sanitization methods](/en-US/docs/Web/API/HTML_Sanitizer_API#sanitization_methods) create the same sanitizer automatically if no options are passed.

### Creating an empty sanitizer

To create an empty sanitizer, pass an empty object to the constructor.
The resulting sanitizer configuration is shown below.

```js
const sanitizer = new Sanitizer({});
/*
{
  "attributes": [],
  "comments": true,
  "dataAttributes": true,
  "elements": [],
  "removeAttributes": [],
  "removeElements": [],
  "replaceWithChildrenElements": []
}
*/
```

### Creating an "allow" sanitizer

This example shows how you might create an "allow sanitizer": a sanitizer that allows only a subset of attributes and elements.

The code first uses the {{domxref("Sanitizer.Sanitizer", "Sanitizer()")}} constructor to create a `Sanitizer`, specifying a {{domxref("SanitizerConfig")}} that allows the element `<div>`, `<p>` and `<script>`.

The example then uses `allowElement()` to further allow `<span>` elements, `allowAttribute()` to allow the `id` attribute on any element, and `replaceElementWithChildren()` method to set that any `<b>` elements should be replaced by their inner content (this is a kind of "allow" in that you are explicitly specifying some entities to keep).
Lastly we specify that comments should be retained.

```js
const sanitizer = new Sanitizer({ elements: ["div", "p", "script"] });
sanitizer.allowElement("span");
sanitizer.allowAttribute("id");
sanitizer.replaceElementWithChildren("b");
sanitizer.setComments(true);
```

### Creating a "remove" sanitizer

This example shows how you might create a "remove sanitizer", specifying items to remove from the input.

The code first uses the {{domxref("Sanitizer.Sanitizer", "Sanitizer()")}} constructor to create a `Sanitizer`, specifying a {{domxref("SanitizerConfig")}} that removes the element `<span>` and `<script>`.
We then use `removeElement()` to add `<h6>` to the array of elements to be removed, and `removeAttribute()` to remove `lang` from the attributes list. We also remove comments.

```js
const sanitizer = new Sanitizer({ removeElements: ["span", "script"] });
sanitizer.removeElement("h6");
sanitizer.removeAttribute("lang");
sanitizer.setComments(false);
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sanitizer: removeAttribute() method

{{APIRef("HTML Sanitizer API")}}{{SeeCompatTable}}

The **`removeAttribute()`** method of the {{domxref("Sanitizer")}} interface sets an attribute to be disallowed on all elements.

The specified attribute is added to the list of [`removeAttributes`](/en-US/docs/Web/API/SanitizerConfig#removeattributes_2) in this sanitizer's configuration.
The attribute is removed from the [`attributes`](/en-US/docs/Web/API/SanitizerConfig#attributes_2) list if present.

Note that to allow/disallow attributes only on specific elements use {{domxref('Sanitizer.allowElement()')}}.

## Syntax

```js-nolint
removeAttribute(attribute)
```

### Parameters

- `attribute`
  - : A string indicating the name of the attribute to be disallowed globally on elements, or an object with the following properties:
    - `name`
      - : A string containing the name of the attribute.
    - `namespace` {{optional_inline}}
      - : A string containing the namespace of the attribute, which defaults to `null`.

### Return value

None (`undefined`).

## Examples

### How to disallow specific attributes

This example shows how `removeAttribute()` is used to specify that an attribute is should be removed from elements.

```html hidden
<pre id="log"></pre>
```

```css hidden
#log {
  height: 300px;
  overflow: scroll;
  padding: 0.5rem;
  border: 1px solid black;
}
```

```js hidden
const logElement = document.querySelector("#log");
function log(text) {
  logElement.textContent = text;
}
```

#### JavaScript

The code first creates a new `Sanitizer` object that initially specifies no attributes or elements.
We then call `removeAttribute()` with the attributes `title` and `mathcolor`.

```js hidden
if ("Sanitizer" in window) {
```

```js
// Create sanitizer that allows
const sanitizer = new Sanitizer({
  removeAttributes: [],
});

// Remove the title attribute
sanitizer.removeAttribute("title");
// Remove the mathcolor attribute
sanitizer.removeAttribute("mathcolor");

// Log the sanitizer configuration
let sanitizerConfig = sanitizer.get();
log(JSON.stringify(sanitizerConfig, null, 2));
```

```js hidden
} else {
  log("The HTML Sanitizer API is NOT supported in this browser.");
}
```

#### Results

The final configuration is logged below.
Note how both attributes are now added to the [`removeAttributes`](/en-US/docs/Web/API/SanitizerConfig#removeattributes_2) list (these attributes will removed if present on elements when the sanitizer is used).

{{EmbedLiveSample("How to disallow specific attributes","100","360px")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sanitizer: removeElement() method

{{APIRef("HTML Sanitizer API")}}{{SeeCompatTable}}

The **`removeElement()`** method of the {{domxref("Sanitizer")}} interface sets an element to be disallowed — removed from input when the sanitizer is used.

The specified element is added to the list of [`removeElements`](/en-US/docs/Web/API/SanitizerConfig#removeelements) in this sanitizer's configuration.
The element is removed from the [`elements`](/en-US/docs/Web/API/SanitizerConfig#elements) or [`replaceWithChildrenElements`](/en-US/docs/Web/API/SanitizerConfig#replacewithchildrenelements) lists if present.

## Syntax

```js-nolint
removeElement(element)
```

### Parameters

- `element`
  - : A string indicating the name of the element to be disallowed, or an object with the following properties:
    - `name`
      - : A string containing the name of the element.
    - `namespace` {{optional_inline}}
      - : A string containing the namespace of the element.
        The default namespace is `"http://www.w3.org/1999/xhtml"`.

### Return value

None (`undefined`).

## Examples

### How to disallow elements

This example shows how `removeElement()` is used to specify an element to be "disallowed".

```html hidden
<pre id="log"></pre>
```

```css hidden
#log {
  height: 420px;
  overflow: scroll;
  padding: 0.5rem;
  border: 1px solid black;
}
```

```js hidden
const logElement = document.querySelector("#log");
function log(text) {
  logElement.textContent = text;
}
```

#### JavaScript

The code first creates a new `Sanitizer` object that initially allows {{htmlelement("div")}} and {{htmlelement("script")}} elements, and that replaces {{htmlelement("span")}} elements with their child elements.

The code then calls `removeElement()` to add {{htmlelement("p")}}, `<script>` and `<span>` elements to the [`removeElements`](/en-US/docs/Web/API/SanitizerConfig#removeelements) list in the configuration.
Note that adding `<script>` and `<span>` removes the elements from their original lists.

```js hidden
if ("Sanitizer" in window) {
```

```js
// Create sanitizer using SanitizerConfig
const sanitizer = new Sanitizer({
  elements: ["div", "script"],
  replaceWithChildrenElements: ["span"],
});

// Disallow the <p> element
sanitizer.removeElement("p");

// Disallow the <script> element
sanitizer.removeElement("script");
// Disallow the <span> element
sanitizer.removeElement("span");

// Log the sanitizer configuration
let sanitizerConfig = sanitizer.get();
log(JSON.stringify(sanitizerConfig, null, 2));
```

```js hidden
} else {
  log("The HTML Sanitizer API is NOT supported in this browser.");
}
```

> [!NOTE]
> This configuration is provided for demonstration only.
> Sanitizer configurations should include either just the allowed elements ([`elements`](/en-US/docs/Web/API/SanitizerConfig#elements)) or just the disallowed elements ([`removeElements`](/en-US/docs/Web/API/SanitizerConfig#removeelements)), but not both.
> In this case only the `<div>` element is allowed and all other elements will be removed from the input: so the removed elements have no effect.

#### Results

The final configuration is logged below.

{{EmbedLiveSample("How to disallow elements","100","480px")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sanitizer: removeUnsafe() method

{{APIRef("HTML Sanitizer API")}}{{SeeCompatTable}}

The **`removeUnsafe()`** method of the {{domxref("Sanitizer")}} interface configures the sanitizer configuration so that it will remove all elements, attributes, and event handler content attributes that are considered XSS-unsafe by the browser.

The unsafe elements and attributes are added to the configuration by calling {{domxref('Sanitizer.removeElement()')}} and {{domxref('Sanitizer.removeAttribute()')}} for each, respectively.
This adds them to the sanitizer configuration disallow lists: [`removeElements`](/en-US/docs/Web/API/SanitizerConfig#removeelements) and [`removeAttributes`](/en-US/docs/Web/API/SanitizerConfig#removeattributes_2), and removes them (if present) from the configuration allow lists: [`elements`](/en-US/docs/Web/API/SanitizerConfig#removeelements), [`replaceWithChildrenElements`](/en-US/docs/Web/API/SanitizerConfig#replacewithchildrenelements) and [`attributes`](/en-US/docs/Web/API/SanitizerConfig#attributes).

The method can be called to make any custom configuration XSS-safe.
If used with a configuration that uses the allow lists, it will remove the XSS-unsafe entities from those lists.
If used with a configuration that uses only the disallow ("remove") lists, then it ensures the configuration includes the unsafe elements in those lists.

Note that if you're using the sanitizer with one of the "safe" HTML setters, such as {{domxref("Element.setHTML()")}} and {{domxref("ShadowRoot.setHTML()")}}, you do not need to call this method to make the sanitizer safe.
When used in these setters the method is called implicitly, without modifying the `Sanitizer` instance that is passed.

## Syntax

```js-nolint
removeUnsafe()
```

### Parameters

None.

### Return value

None (`undefined`).

## Examples

### Basic usage

The following code shows how `removeUnsafe()` is used.

```js
// Create sanitizer.
const sanitizer = new Sanitizer(/* Some configuration */);

// Make the configuration XSS-safe
sanitizer.removeUnsafe();
```

### Making a sanitizer configuration safe

This example demonstrates how calling `removeUnsafe()` makes the sanitizer configuration XSS-safe.

```html hidden
<pre id="log"></pre>
```

```css hidden
#log {
  height: 420px;
  overflow: scroll;
  padding: 0.5rem;
  border: 1px solid black;
}
```

```js hidden
const logElement = document.querySelector("#log");
function log(text) {
  logElement.textContent += text;
}
```

#### JavaScript

The code first creates a new `Sanitizer` object that allows the safe element {{htmlelement("p")}}, the unsafe elements {{htmlelement("script")}} and {{htmlelement("iframe")}}, and the unsafe `onwebkitanimationend` event handler attribute.

The code then calls `removeUnsafe()` on the sanitizer and logs its configuration.

```js hidden
if ("Sanitizer" in window) {
```

```js
// Create sanitizer that allows
const sanitizer = new Sanitizer({
  elements: ["p", "script"],
  attributes: ["onwebkitanimationend"],
  replaceWithChildrenElements: ["iframe"],
});

// Make the sanitizer safe!
sanitizer.removeUnsafe();

// Log the sanitizer configuration
const sanitizerConfig = sanitizer.get();
log(JSON.stringify(sanitizerConfig, null, 2));
```

```js hidden
} else {
  log("The HTML Sanitizer API is NOT supported in this browser.");
}
```

#### Results

The resulting configuration is shown below.
Note how the unsafe elements and attributes have been removed from the "allow" lists to the corresponding "remove" lists.
In this case we still have {{htmlelement("p")}} in the allowed elements, so only `<p>` elements in the input will be imported when the sanitizer is used.

{{EmbedLiveSample("Making a sanitizer configuration safe","100","480px")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sanitizer: replaceElementWithChildren() method

{{APIRef("HTML Sanitizer API")}}{{SeeCompatTable}}

The **`replaceElementWithChildren()`** method of the {{domxref("Sanitizer")}} interface sets an element to be replaced by its child HTML elements when the sanitizer is used.
The is primarily used for stripping styles from text.

The specified element, along with its namespace, is added to the list of [`replaceWithChildrenElements`](/en-US/docs/Web/API/SanitizerConfig#replacewithchildrenelements) in this sanitizer's configuration.
The element is removed from the [`elements`](/en-US/docs/Web/API/SanitizerConfig#elements) or [`removeElements`](/en-US/docs/Web/API/SanitizerConfig#removeelements) lists if present.

## Syntax

```js-nolint
replaceElementWithChildren(element)
```

### Parameters

- `element`
  - : A string indicating the name of the element to be replaced, or an object with the following properties:
    - `name`
      - : A string containing the name of the element.
    - `namespace` {{optional_inline}}
      - : A string containing the namespace of the element.
        The default namespace is `"http://www.w3.org/1999/xhtml"`.

### Return value

None (`undefined`).

## Examples

### Basic usage

This example shows the basic usage of the method, configuring a sanitizer that replaces the `<em>` element in inputs with its child content.

```js
// Create sanitizer (in this case the default)
const sanitizer = new Sanitizer();

// Replace <em> elements with their innerHTML
sanitizer.replaceElementWithChildren("em");
```

### How to strip styles from text

This example shows how `replaceElementWithChildren()` can be used to strip styles from text.

```html hidden
<pre id="log"></pre>
```

```css hidden
#log {
  height: 480px;
  overflow: scroll;
  padding: 0.5rem;
  border: 1px solid black;
}
```

```js hidden
const logElement = document.querySelector("#log");
function log(text) {
  logElement.textContent += text;
}
```

#### JavaScript

The code first creates a new `Sanitizer` object that initially allows {{htmlelement("p")}}, {{htmlelement("em")}}, and {{htmlelement("strong")}} elements.
We then call `replaceElementWithChildren()` on the sanitizer specifying that `<strong>` elements should be replaced.

The code defines a string that has `<strong>` elements and uses {{domxref("Element.setHTML()")}} with the sanitizer to inject the string.
The original string, the sanitized HTML from the element, and the sanitizer are logged.

```js hidden
if ("Sanitizer" in window) {
```

```js
// Create sanitizer using SanitizerConfig
const sanitizer = new Sanitizer({
  elements: ["p", "em", "strong"],
});

// Replace the <strong> element
sanitizer.replaceElementWithChildren("strong");

const unsanitizedString = `<p>This is a with <strong>important</strong> text <em>highlighted</em>.</p>`;
log(`unsanitizedHTMLString:\n ${unsanitizedString}`);

// Create a <div> element
const divElement = document.createElement("div");

divElement.setHTML(unsanitizedString, { sanitizer });
log(`\n\nsanitizedHTML:\n ${divElement.innerHTML}`);

// Log the sanitizer configuration
const sanitizerConfig = sanitizer.get();
log(`\n\nsanitizerConfig:\n ${JSON.stringify(sanitizerConfig, null, 2)}`);
```

```js hidden
} else {
  log("The HTML Sanitizer API is NOT supported in this browser.");
}
```

#### Results

The original unsanitized HTML string, the sanitized string from the element, and the sanitizer are logged below.
Note that the `<strong>` styling is stripped from the text, but the `<em>` element is not.
Note also that the `<strong>` element was originally in the `elements` list in the configuration, but was removed when it was added to the `replaceWithChildrenElements` list.

{{EmbedLiveSample("How to strip styles from text","100","520px")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sanitizer: Sanitizer() constructor

{{APIRef("HTML Sanitizer API")}}{{SeeCompatTable}}

The **`Sanitizer()`** constructor creates a new {{domxref("Sanitizer")}} object, which can be used to filter unwanted elements and attributes from HTML or documents before they are inserted/parsed into the DOM.

The default `Sanitizer()` configuration allows only XSS-safe input by default, omitting elements such as {{HTMLElement("script")}}, {{HTMLElement("frame")}}, {{HTMLElement("iframe")}}, {{HTMLElement("object")}}, `<use>`, and event handler attributes from their respective allow lists, and disallowing data attributes, and comments.

The constructor `configuration` option can be used to customize the sanitizer behavior.

<!--
Either here or in the config (or both) explain what a (in)valid config looks like
-->

## Syntax

```js-nolint
new Sanitizer()
new Sanitizer(configuration)
```

### Parameters

- `configuration` {{optional_inline}}
  - : A {{domxref("SanitizerConfig")}} defining a sanitizer configuration, or the string `"default"` to indicate the default configuration.

### Returns

An instance of the {{domxref("Sanitizer")}} object.

### Exceptions

- {{jsxref("TypeError")}}
  - : Thrown if a non-normalized {{domxref("SanitizerConfig")}} is passed (one that includes both "allowed" and "removed" configuration settings), or if a string is passed that isn't `"default"`.

## Examples

### Creating the default sanitizer

This example shows how you can create the default `Sanitizer` and logs the resulting configuration object.

```html hidden
<pre id="log"></pre>
```

```css hidden
#log {
  height: 400px;
  overflow: scroll;
  padding: 0.5rem;
  border: 1px solid black;
}
```

#### JavaScript

The code first tests whether the `Sanitizer` interface is supported.
It then creates the default `Sanitizer`, passing no options, and then gets and logs the configuration.

```js hidden
const logElement = document.querySelector("#log");
function log(text) {
  logElement.textContent = text;
}
```

```js hidden
if ("Sanitizer" in window) {
```

```js
// Create default sanitizer
const sanitizer = new Sanitizer();

// Get and log the (default) configuration
const defaultConfig = sanitizer.get();
log(JSON.stringify(defaultConfig, null, 2));
```

```js hidden
} else {
  log("The HTML Sanitizer API is NOT supported in this browser.");
}
```

#### Results

The output is logged below.
Note that the default configuration is quite big, allowing many elements and attributes.

{{EmbedLiveSample("Creating the default sanitizer","100","480px")}}

### Creating a sanitizer and using it with `setHTML()`

This example shows how you might create and use a custom sanitizer in a safe HTML DOM insertion method.

#### HTML

Here we define two {{htmlelement("pre")}} elements in which we'll display both the sanitized and unsanitized HTML.

```html
<pre id="unmodified"></pre>
<pre id="setHTML"></pre>
```

```html hidden
<pre id="log"></pre>
```

```css hidden
#log {
  height: 430px;
  overflow: scroll;
  padding: 0.5rem;
  border: 1px solid black;
}
```

#### JavaScript

```js hidden
const logElement = document.querySelector("#log");
function log(text) {
  logElement.textContent = text;
}
```

The following code tests whether the `Sanitizer` interface is supported.
It then defines a string of "unsafe HTML", which contains bot safe elements, such as {{htmlelement("p")}} and {{htmlelement("span")}}, and XSS-unsafe elements such as {{htmlelement("script")}}

We then create a `Sanitizer` object with a {{domxref("SanitizerConfig")}} that allows the HTML elements: {{htmlelement("div")}}, {{htmlelement("p")}}, {{htmlelement("span")}}, and {{htmlelement("script")}}.
The sanitizer is used with the unsafe string in {{domxref("Element.setHTML()")}}.
Both the original and sanitized strings are displayed as text nodes.

```js hidden
if ("Sanitizer" in window) {
```

```js
// Define unsafe string of HTML
const unsafeHTMLString = `
  <div>
    <p>This is a paragraph. <span onclick="alert('You clicked the span!')">Click me</span></p>
    <script src="path/to/amodule.js" type="module"
  </div>
`;

// Set unsafe string as a text node of first element
const unmodifiedElement = document.querySelector("#unmodified");
unmodifiedElement.innerText = unsafeHTMLString;

// Create sanitizer using a SanitizerConfig that allows script (and other elements)
const sanitizer = new Sanitizer({ elements: ["div", "p", "span", "script"] });

// Use the sanitizer to set the HTML of the second element using the safe method
const setHTMLElement = document.querySelector("#setHTML");
setHTMLElement.setHTML(unsafeHTMLString, { sanitizer });

// Get that HTML and set it back to the element as a text node
// (so we can see the elements)
setHTMLElement.innerText = setHTMLElement.innerHTML;

// Log the configuration
const sanitizerConfig = sanitizer.get();
log(JSON.stringify(sanitizerConfig, null, 2));
```

```js hidden
} else {
  log("The HTML Sanitizer API is NOT supported in this browser.");
}
```

#### Results

The original string and sanitized HTML that was parsed into the DOM are shown below.
Note that even though the sanitizer allows `<script>` elements, these are stripped out of the injected HTML when using {{domxref("Element.setHTML()")}}.
Also note that the configuration includes both the names of the elements and their namespaces.

{{EmbedLiveSample("Creating the default sanitizer","100","650px")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sanitizer: setComments() method

{{APIRef("HTML Sanitizer API")}}{{SeeCompatTable}}

The **`setComments()`** method of the {{domxref("Sanitizer")}} interface sets whether comments will be allowed or removed by the sanitizer.

The method sets the [`comments`](/en-US/docs/Web/API/SanitizerConfig#comments) property in this sanitizer's configuration.

## Syntax

```js-nolint
setComments(allow);
```

### Parameters

- `allow`
  - : `true` if comments are allowed, and `false` if they are to be removed.

### Return value

None (`undefined`).

## Examples

### How to sanitize comments

The code below shows the basic usage of the `setComments()` method.

```js
// Create sanitizer (in this case the default)
const sanitizer = new Sanitizer();

// Allow comments
sanitizer.setComments(true);

// Remove comments
sanitizer.setComments(false);
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sanitizer: setDataAttributes() method

{{APIRef("HTML Sanitizer API")}}{{SeeCompatTable}}

The **`setDataAttributes()`** method of the {{domxref("Sanitizer")}} interface sets whether [data attributes](/en-US/docs/Web/HTML/Reference/Global_attributes/data-*) will be allowed or removed by the sanitizer.

The method sets the [`dataAttributes`](/en-US/docs/Web/API/SanitizerConfig#dataattributes) property in this sanitizer's configuration.

## Syntax

```js-nolint
setDataAttributes(allow);
```

### Parameters

- `allow`
  - : `true` if data attributes are allowed, and `false` if they are to be removed.

### Return value

None (`undefined`).

## Examples

### How to sanitize data attributes

The code below shows the basic usage of the `setDataAttributes()` method.

```js
// Create sanitizer (in this case the default)
const sanitizer = new Sanitizer();

// Allow data attributes
sanitizer.setDataAttributes(true);

// Remove data attributes
sanitizer.setDataAttributes(false);
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# SanitizerConfig

{{APIRef("HTML Sanitizer API")}}{{SeeCompatTable}}

The **`SanitizerConfig`** dictionary of the [HTML Sanitizer API](/en-US/docs/Web/API/HTML_Sanitizer_API) represents a sanitizer configuration object.
The configuration specifies what elements, attributes and comments are allowed or should be removed when inserting strings of HTML into an {{domxref("Element")}} or {{domxref("ShadowRoot")}}, or when parsing an HTML string into a {{domxref("Document")}}.

An instance of this type can be passed to the {{domxref("Sanitizer.Sanitizer", "Sanitizer()")}} constructor to configure a {{domxref("Sanitizer")}}, and is returned by {{domxref('Sanitizer.get()')}}.
It can also be passed as the `option.sanitizer` parameter when calling the [sanitization methods](/en-US/docs/Web/API/HTML_Sanitizer_API#sanitization_methods):

- {{domxref("Element/setHTML","setHTML()")}} or {{domxref("Element/setHTMLUnsafe","setHTMLUnsafe()")}} on {{domxref("Element")}}.
- {{domxref("ShadowRoot/setHTML","setHTML()")}} or {{domxref("ShadowRoot/setHTMLUnsafe","setHTMLUnsafe()")}} on {{domxref("ShadowRoot")}}.
- [`Document.parseHTML()`](/en-US/docs/Web/API/Document/parseHTML_static) or [`Document.parseHTMLUnsafe()`](/en-US/docs/Web/API/Document/parseHTMLUnsafe_static) static methods.

Note that normally a {{domxref("Sanitizer")}} instance would be passed as the option instead of `SanitizerConfig` in the above methods, in particular because `sanitizer` instances are more efficient to share and modify.

## Instance properties

- `elements`
  - : An array indicating the elements to allow when sanitizing HTML, optionally also specifying their allowed or removed attributes.

    Each element can be specified by name (a string), or as a object with the following properties:
    - `name`
      - : A string containing the name of the element.
    - `namespace` {{optional_inline}}
      - : A string containing the namespace of the element.
        The default namespace is `"http://www.w3.org/1999/xhtml"`.
    - `attributes` {{optional_inline}}
      - : An array indicating the attributes to allow on this (allowed) element when sanitizing HTML.

        Each attribute can be specified by name (a string), or as a object with the following properties:
        - `name`
          - : A string containing the name of the attribute.
        - `namespace` {{optional_inline}}
          - : A string containing the namespace of the attribute, which defaults to `null`.

    - `removeAttributes` {{optional_inline}}
      - : An array indicating the attributes to remove on this (allowed) element when sanitizing HTML.

        Each attribute can be specified by name (a string), or as a object with the following properties:
        - `name`
          - : A string containing the name of the attribute.
        - `namespace` {{optional_inline}}
          - : A string containing the namespace of the attribute, which defaults to `null`.

- `removeElements`
  - : An array indicating the elements to remove when sanitizing HTML.

    Each element can be specified by name (a string), or as a object with the following properties:
    - `name`
      - : A string containing the name of the element.
    - `namespace` {{optional_inline}}
      - : A string containing the namespace of the element.
        The default namespace is `"http://www.w3.org/1999/xhtml"`.

- `replaceWithChildrenElements`
  - : An array indicating the elements to replace with their content when sanitizing HTML.
    This is primarily used to strip styles from text (for example, you could use this to change `<b>some text</b>` to `some text`).

    Each element can be specified by name (a string), or as a object with the following properties:
    - `name`
      - : A string containing the name of the element.
    - `namespace` {{optional_inline}}
      - : A string containing the namespace of the element.
        The default namespace is `"http://www.w3.org/1999/xhtml"`.

- `attributes`
  - : An array indicating the attributes to allow when sanitizing HTML.

    Each attribute can be specified by name (a string), or as a object with the following properties:
    - `name`
      - : A string containing the name of the attribute.
    - `namespace` {{optional_inline}}
      - : A string containing the namespace of the attribute, which defaults to `null`.

- `removeAttributes`
  - : An array indicating the attributes to remove from elements when sanitizing HTML.

    Each attribute can be specified by name (a string), or as a object with the following properties:
    - `name`
      - : A string containing the name of the attribute.
    - `namespace` {{optional_inline}}
      - : A string containing the namespace of the attribute, which defaults to `null`.

- `comments`
  - : `true` if comments are allowed, and `false` if they are to be removed.
- `dataAttributes`
  - : `true` if data attributes are allowed, and `false` if they are to be removed.

## Examples

### Creating an "allow" configuration

This example shows how you might create an "allow" sanitizer configuration, and in this case pass it to the {{domxref("Sanitizer.Sanitizer", "Sanitizer()")}} constructor.

```js
const sanitizer = new Sanitizer({
  elements: ["div", "p", "script"],
  attributes: ["id"],
  replaceWithChildrenElements: ["b"],
  comments: true,
  dataAttributes: false,
});
```

Note that you cannot specify both allow and remove lists in the same configuration without causing an exception when passing the configuration to the constructor or a sanitization method.

### Creating a "remove" configuration

This example shows how you might create a "remove" sanitizer configuration, and in this case pass it to the {{domxref("Sanitizer.Sanitizer", "Sanitizer()")}} constructor.

```js
const sanitizer = new Sanitizer({
  removeElements: ["span", "script"],
  removeAttributes: ["lang", "id"],
  comments: false,
});
```

Note that you cannot specify both allow and remove lists in the same configuration without causing an exception when passing the configuration to the constructor or a sanitization method.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Scheduler

{{APIRef("Prioritized Task Scheduling API")}}{{AvailableInWorkers}}

The **`Scheduler`** interface of the [Prioritized Task Scheduling API](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API) provides methods for scheduling prioritized tasks.

A `Scheduler` can be accessed from the global object using {{domxref("Window.scheduler")}} or {{domxref("WorkerGlobalScope.scheduler")}} within a worker.

## Instance properties

None.

## Instance methods

- {{domxref('Scheduler.postTask()')}}
  - : Adds a task to the scheduler as a callback, optionally specifying a priority, delay, and/or a signal for aborting the task.
- {{domxref('Scheduler.yield()')}}
  - : Yields control of the main thread back to the browser, returning a promise that resolves to continue execution where it left off.

## Examples

If the feature is defined, an instance of this object is returned by the {{jsxref("globalThis")}} property in both workers and the main thread.

The code below shows a simple task that resolves with the text 'Task executing'.
This text is logged on success.
The code also shows a `catch` block, which would be required in more complex code to handle when a task is aborted or throws an error.

```js
if ("scheduler" in this) {
  // Post task with default priority: 'user-visible' (no other options)
  // When the task resolves, Promise.then() logs the result.
  scheduler
    .postTask(() => "Task executing")
    .then((taskResult) => console.log(`${taskResult}`)) // Log result
    .catch((error) => console.error(`Error: ${error}`)); // Log errors
}
```

For more comprehensive example code see [Prioritized Task Scheduling API > Examples](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#examples).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Scheduler: postTask() method

{{APIRef("Prioritized Task Scheduling API")}}{{AvailableInWorkers}}

The **`postTask()`** method of the {{domxref("Scheduler")}} interface is used for adding tasks to be [scheduled](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API) according to their [priority](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#task_priorities).

The method allows users to optionally specify a minimum delay before the task will run, a priority for the task, and a signal that can be used to modify the task priority and/or abort the task.
It returns a promise that is resolved with the result of the task callback function, or rejected with the abort reason or an error thrown in the task.

Task priority can be [mutable or immutable](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#mutable_and_immutable_task_priority).
If the task priority will never need to change then it should be set using the `options.priority` parameter (any priority set through a signal will then be ignored).
You can still pass an {{domxref("AbortSignal")}} (which has no priority) or {{domxref("TaskSignal")}} to the `options.signal` parameter for aborting the task.

If the task priority might need to be changed the `options.priority` parameter must not be set.
Instead a {{domxref("TaskController")}} should be created and its {{domxref("TaskSignal")}} should be passed to `options.signal`.
The task priority will be initialized from the signal priority, and can later be modified using the signal's associated {{domxref("TaskController")}}.

If no priority is set then the task priority defaults to [`"user-visible"`](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#user-visible).

If a delay is specified and greater than 0, then the execution of the task will be delayed for at least that many milliseconds.
Otherwise the task is immediately scheduled for prioritization.

## Syntax

```js-nolint
postTask(callback)
postTask(callback, options)
```

### Parameters

- `callback`
  - : An callback function that implements the task.
    The return value of the callback is used to resolve the promise returned by this function.

- `options` {{optional_inline}}
  - : Task options, including:
    - `priority` {{optional_inline}}
      - : The immutable [priority](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#task_priorities) of the task.
        One of: [`"user-blocking"`](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#user-blocking), [`"user-visible"`](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#user-visible), [`"background"`](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#background).
        If set, this priority is used for the lifetime of the task and priority set on the `signal` is ignored.

    - `signal` {{optional_inline}}
      - : A {{domxref("TaskSignal")}} or {{domxref("AbortSignal")}} that can be used to abort the task (from its associated controller).

        If the `options.priority` parameter is set then the task priority cannot be changed, and any priority on the signal is ignored.
        Otherwise, if the signal is a {{domxref("TaskSignal")}} its priority is used to set the initial task priority, and the signal's controller may later use it to change the task priority.

    - `delay` {{optional_inline}}
      - : The minimum amount of time after which the task will be added to the scheduler queue, in whole milliseconds.
        The actual delay may be higher than specified, but will not be less.
        The default delay is 0.

### Return value

Returns a {{jsxref("Promise")}} that is resolved with the return value of the `callback` function, or which may be rejected with the `signal`'s abort reason ({{domxref("AbortSignal.reason")}}).
The promise may also be rejected with an error thrown by the callback during execution.

## Examples

The following examples are slightly simplified versions of the live examples provided in [Prioritized Task Scheduling API > Examples](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#examples).

### Feature checking

Check whether prioritized task scheduling is supported by testing for the `scheduler` property in the global scope (such as {{domxref("Window.scheduler")}} in window's scope or {{domxref("WorkerGlobalScope.scheduler")}} in worker's scope).

For example, the code below logs "Feature: Supported" if the API is supported on this browser.

```js
// Check that feature is supported
if ("scheduler" in globalThis) {
  console.log("Feature: Supported");
} else {
  console.error("Feature: NOT Supported");
}
```

### Basic usage

Tasks are posted specifying a callback function (task) in the first argument, and an optional second argument that can be used to specify a task priority, signal, and/or delay.
The method returns a {{jsxref("Promise")}} that resolves with the return value of the callback function, or rejects with either an abort error or an error thrown in the function.

Because it returns a promise, `postTask()` can be [chained with other promises](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#chained_promises).
Below we show how to wait on the promise to resolve using [`then`](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then) or reject using [`catch`](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch).
The priority is not specified, so the default priority of `user-visible` will be used.

```js
// A function that defines a task
function myTask() {
  return "Task 1: user-visible";
}

// Post task with default priority: 'user-visible' (no other options)
// When the task resolves, Promise.then() logs the result.
scheduler
  .postTask(myTask, { signal: abortTaskController.signal })
  .then((taskResult) => console.log(`${taskResult}`)) // Log resolved value
  .catch((error) => console.error("Error:", error)); // Log error or abort
```

The method can also be used with [`await`](/en-US/docs/Web/JavaScript/Reference/Operators/await) inside an [async function](/en-US/docs/Web/JavaScript/Reference/Statements/async_function).
The code below shows how you might use this approach to wait on a `user-blocking` task.

```js
function myTask2() {
  return "Task 2: user-blocking";
}

async function runTask2() {
  const result = await scheduler.postTask(myTask2, {
    priority: "user-blocking",
  });
  console.log(result); // 'Task 2: user-blocking'.
}
runTask2();
```

### Permanent priorities

[Task priorities](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#task_priorities) may be set using `priority` parameter in the optional second argument.
Priorities that are set in this way cannot be changed (are [immutable](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#mutable_and_immutable_task_priority)).

Below we post two groups of three tasks, each member in reverse order of priority.
The final task has the default priority.
When run, each task simply logs it's expected order (we're not waiting on the result because we don't need to in order to show execution order).

```js
// three tasks, in reverse order of priority
scheduler.postTask(() => console.log("bkg 1"), { priority: "background" });
scheduler.postTask(() => console.log("usr-vis 1"), {
  priority: "user-visible",
});
scheduler.postTask(() => console.log("usr-blk 1"), {
  priority: "user-blocking",
});

// three more tasks, in reverse order of priority
scheduler.postTask(() => console.log("bkg 2"), { priority: "background" });
scheduler.postTask(() => console.log("usr-vis 2"), {
  priority: "user-visible",
});
scheduler.postTask(() => console.log("usr-blk 2"), {
  priority: "user-blocking",
});

// Task with default priority: user-visible
scheduler.postTask(() => {
  console.log("usr-vis 3 (default)");
});
```

The expected output is shown below: tasks are executed in priority order, and then declaration order.

```plain
usr-blk 1
usr-blk 2
usr-vis 1
usr-vis 2
usr-vis 3 (default)
bkg 1
bkg 2
```

### Changing task priorities

[Task priorities](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#task_priorities) can also take their initial value from a {{domxref("TaskSignal")}} passed to `postTask()` in the optional second argument.
If set in this way, the priority of the task [can then be changed](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#mutable_and_immutable_task_priority) using the controller associated with the signal.

> [!NOTE]
> Setting and changing task priorities using a signal only works when the `options.priority` argument to `postTask()` is not set, and when the `options.signal` is a {{domxref("TaskSignal")}} (and not an {{domxref("AbortSignal")}}).

The code below first shows how to create a {{domxref("TaskController")}}, setting the initial priority of its signal to `user-blocking` in the [`TaskController()` constructor](/en-US/docs/Web/API/TaskController/TaskController).

We then use `addEventListener()` to add an event listener to the controller's signal (we could alternatively use the `TaskSignal.onprioritychange` property to add an event handler).
The event handler uses {{domxref('TaskPriorityChangeEvent.previousPriority', 'previousPriority')}} on the event to get the original priority and {{domxref("TaskSignal.priority")}} on the event target to get the new/current priority.

```js
// Create a TaskController, setting its signal priority to 'user-blocking'
const controller = new TaskController({ priority: "user-blocking" });

// Listen for 'prioritychange' events on the controller's signal.
controller.signal.addEventListener("prioritychange", (event) => {
  const previousPriority = event.previousPriority;
  const newPriority = event.target.priority;
  console.log(`Priority changed from ${previousPriority} to ${newPriority}.`);
});
```

Finally, the task is posted, passing in the signal, and then we immediately change the priority to `background` by calling {{domxref("TaskController.setPriority()")}} on the controller.

```js
// Post task using the controller's signal.
// The signal priority sets the initial priority of the task
scheduler.postTask(() => console.log("Task 1"), { signal: controller.signal });

// Change the priority to 'background' using the controller
controller.setPriority("background");
```

The expected output is shown below.
Note that in this case the priority is changed before the task is executed, but it could equally have been changed while the task was running.

```js
// Expected output
// Priority changed from user-blocking to background.
// Task 1
```

### Aborting tasks

Tasks can be aborted using either {{domxref("TaskController")}} and {{domxref("AbortController")}}, in exactly the same way.
The only difference is that you must use {{domxref("TaskController")}} if you also want to set the task priority.

The code below creates a controller and passes its signal to the task.
The task is then immediately aborted.
This causes the promise to be rejected with an `AbortError`, which is caught in the `catch` block and logged.
Note that we could also have listened for the [`abort` event](/en-US/docs/Web/API/AbortSignal/abort_event) fired on the {{domxref("TaskSignal")}} or {{domxref("AbortSignal")}} and logged the abort there.

```js
// Declare a TaskController with default priority
const abortTaskController = new TaskController();
// Post task passing the controller's signal
scheduler
  .postTask(() => console.log("Task executing"), {
    signal: abortTaskController.signal,
  })
  .then((taskResult) => console.log(`${taskResult}`)) // This won't run!
  .catch((error) => console.error("Error:", error)); // Log the error

// Abort the task
abortTaskController.abort();
```

### Delaying tasks

Tasks can be delayed by specifying an integer number of milliseconds in the `options.delay` parameter to `postTask()`.
This effectively adds the task to the prioritized queue on a timeout, as might be created using {{domxref("Window.setTimeout", "setTimeout()")}}.
The `delay` is the minimum amount of time before the task is added to the scheduler; it may be longer.

The code below shows two tasks added (as arrow functions) with a delay.

```js
// Post task as arrow function with delay of 2 seconds
scheduler
  .postTask(() => "Task delayed by 2000ms", { delay: 2000 })
  .then((taskResult) => console.log(`${taskResult}`));
scheduler
  .postTask(() => "Next task should complete in about 2000ms", { delay: 1 })
  .then((taskResult) => console.log(`${taskResult}`));
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Scheduler: yield() method

{{APIRef("Prioritized Task Scheduling API")}}{{AvailableInWorkers}}

The **`yield()`** method of the {{domxref('Scheduler')}} interface is used for yielding to the [main thread](/en-US/docs/Glossary/Main_thread) during a task and continuing execution later, with the continuation scheduled as a prioritized task (see the [Prioritized Task Scheduling API](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API) for more information). This allows long-running work to be broken up so the browser stays responsive.

The task can continue when the promise returned by the method is resolved. The priority for when the promise is resolved defaults to [`"user-visible"`](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#user-visible), but can inherit a different priority if the `yield()` call occurs within a {{domxref('Scheduler.postTask()')}} callback.

In addition, the continuation of work after the `yield()` call can be canceled if it occurs within a `postTask()` callback and the [task is aborted](/en-US/docs/Web/API/Scheduler/postTask#aborting_tasks).

## Syntax

```js-nolint
yield()
```

### Parameters

None.

### Return value

Returns a {{jsxref('Promise')}} that is fulfilled with {{jsxref('undefined')}}, or rejected with an {{domxref('AbortSignal.reason')}}.

## Examples

### Feature checking

Check whether prioritized task scheduling is supported by testing for `scheduler.yield` on {{jsxref('globalThis')}}, either in a window or worker scope.

For example, the code below logs `"scheduler.yield: Supported"` if the API is supported in the current browser.

```js
// Check for support before using.
if (globalThis.scheduler?.yield) {
  console.log("scheduler.yield: Supported");
} else {
  console.error("scheduler.yield: NOT Supported");
}
```

### Basic usage

Long tasks can be broken up by awaiting `scheduler.yield()`. The function returns a promise, yielding to the main thread to allow the browser to execute other pending work—like responding to user input—if needed. The browser schedules a follow-up task that resolves the promise, at which point execution of the code can continue where it left off.

For instance, if a [`click`](/en-US/docs/Web/API/Element/click_event) event listener on a button results in significant work to load and display new page content, there will be no visual feedback to the user that their button click was even registered by the page until that work is complete. A `scheduler.yield()` can be inserted into the event listener so that quick feedback can be shown (like a spinner), and then the remainder of the work can be done when execution continues after the yield.

```js
button.addEventListener("click", async () => {
  // Provide immediate feedback so the user knows their click was received.
  showSpinner();
  await scheduler.yield();
  // Do longer processing
  doSlowContentSwap();
});
```

It may also be sufficient to provide quick interaction feedback with the default UI. For instance, if a [`change`](/en-US/docs/Web/API/HTMLElement/change_event) event listener on a checkbox triggers slow filtering of page content, a `scheduler.yield()` call can be inserted to show the check state change immediately before continuing to the remainder of the event response.

```js
checkbox.addEventListener("change", async () => {
  await scheduler.yield();
  doSlowContentFiltering();
});
```

In situations where there is lengthy work that needs to be done on the main thread that can be chunked into a series of tasks, `scheduler.yield()` can be called repeatedly to keep the page responsive throughout.

```js
function doWork(value) {
  console.log(`work chunk ${value}`);
}

const workList = [0, 1, 2, 3, 4];

for (const work of workList) {
  doWork(work);
  await scheduler.yield();
}
```

### Yield priority

The order in which the promise returned by `scheduler.yield()` is resolved relative to other tasks is based on an implicit [task priority](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#task_priorities).

By default, `scheduler.yield()` is run with a [`"user-visible"`](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#user-visible) priority. However, continuation after a `scheduler.yield()` call has a slightly different behavior than `scheduler.postTask()` tasks of the same `priority`.

`scheduler.yield()` enqueues its task in a boosted task queue compared to a `scheduler.postTask()` of the same priority level. So, for instance, a `scheduler.yield()` continuation with `"user-visible"` priority will be prioritized after `scheduler.postTask()` tasks of the higher `"user-blocking"` priority level, but before `scheduler.postTask()` tasks of the same `"user-visible"` priority (in the spec, this is defined by a task queue's [effective priority](https://wicg.github.io/scheduling-apis/#scheduler-task-queue-effective-priority)).

This is sometimes described as `scheduler.yield()` enqueuing its task at the front of a priority level's queue, while `scheduler.postTask()` tasks go at the end. This can be a useful mental model. In situations with just a few tasks, this means that with the same priority, the `scheduler.yield()` continuation will come first, allowing additional flexibility in how tasks can be scheduled. For example:

```js
scheduler.postTask(() => console.log("user-visible postTask"));
scheduler.postTask(() => console.log("user-blocking postTask"), {
  priority: "user-blocking",
});
await scheduler.yield();
console.log("user-visible yield");
```

will log the following:

```plain
user-blocking postTask
user-visible yield
user-visible postTask
```

However, in cases where there are multiple `scheduler.yield()` calls, the distinction that the `scheduler.yield()` continuation tasks go into a boosted-priority _queue_ becomes important because a second `scheduler.yield()` task won't be run before one that's already in the queue.

If one function yields its work before a second function does, the first function to yield will continue first. For example:

```js
async function first() {
  console.log("starting first function");
  await scheduler.yield();
  console.log("ending first function");
}

async function second() {
  console.log("starting second function");
  await scheduler.yield();
  console.log("ending second function");
}

first();
second();
```

will log the following:

```plain
starting first function
starting second function
ending first function
ending second function
```

### Inheriting task priorities

A `scheduler.yield()` call within a `scheduler.postTask()` task will inherit the task's priority. For example, work after a `scheduler.yield()` within a low-priority [`"background"`](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#user-blocking) task will also be scheduled as `"background"` by default (but, again, inserted in the boosted `"background"` priority queue so running before any `"background"` `postTask()` tasks).

For example:

```js
async function backgroundWork() {
  scheduler.postTask(() => console.log("background postTask"), {
    priority: "background",
  });
  scheduler.postTask(() => console.log("user-visible postTask"), {
    priority: "user-visible",
  });
  // yield() inherits "background" priority from surrounding task.
  await scheduler.yield();
  console.log("default-background yield");
}

await scheduler.postTask(backgroundWork, { priority: "background" });
```

will log the following:

```plain
user-visible postTask
default-background yield
background postTask
```

`scheduler.yield()` continuations will inherit whatever priority the containing `scheduler.postTask()` task has, including whether the task's priority was [changed dynamically](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#changing_task_priorities).

### Aborting a yield

Similar to setting priority, a `scheduler.yield()` call can't be aborted directly, but it will inherit the abort signal from a surrounding `scheduler.postTask()` task. Aborting the task will also abort any pending yields within it.

This example uses a {{domxref('TaskController')}} to [abort a task](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#aborting_tasks) with a `scheduler.yield()` within it.

```js
const taskController = new TaskController();

function firstHalfOfWork() {
  console.log("first half of work");
  taskController.abort("cancel work");
}

function secondHalfOfWork() {
  // Never runs.
  console.log("second half of work");
}

scheduler.postTask(
  async () => {
    firstHalfOfWork();
    await scheduler.yield();
    secondHalfOfWork();
  },
  { signal: taskController.signal },
);
```

The example is somewhat contrived in that it always triggers the `taskController.abort()` call within the task itself, but the `abort()` call could come from anywhere. For example, it could be triggered by the user pressing a 'Cancel' button.

In this case, the `abort()` occurs after the `scheduler.postTask()` task has already started (`"first half of work"` is logged), but the yield call inherits the [abort signal](/en-US/docs/Web/API/AbortSignal) therefore the `await scheduler.yield()` call will throw with an abort reason of `"cancel work"`.

### Using `yield()` within `requestIdleCallback()`

`scheduler.yield()` calls also inherit their priority from {{domxref("Window.requestIdleCallback()")}}, when called from inside the callback function. In this case, the [`"background"`](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#background) priority value is inherited. Note however that `scheduler.yield()` calls inside `requestIdleCallback()` callbacks are not abortable.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Prioritized Task Scheduling API](/en-US/docs/Web/API/Prioritized_Task_Scheduling_API)
- {{domxref('Scheduler')}}
- {{domxref('Scheduler.postTask()')}}
# Scheduling

{{SeeCompatTable}}{{APIRef("Prioritized Task Scheduling API")}}

The **`Scheduling`** object provides methods and properties to control scheduling tasks within the current document.

> [!WARNING]
> The `Scheduling` interface has been superseded by the {{domxref("Scheduler")}} interface, the features of which are better designed for addressing scheduling tasks. See [Don't use `isInputPending()`](https://web.dev/articles/optimize-long-tasks#isinputpending) for more details.

## Instance methods

- {{domxref("Scheduling.isInputPending", "isInputPending()")}} {{Experimental_Inline}}
  - : Returns a boolean that indicates whether there are pending input events in the event queue, meaning that the user is attempting to interact with the page.

## Example

See the {{domxref("Scheduling.isInputPending()")}} page for a full example.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Scheduler")}} interface
- {{domxref("Prioritized_task_scheduling_api", "Prioritized Task Scheduling API", "", "nocode")}}
- [Faster input events with Facebook's first browser API contribution](https://engineering.fb.com/2019/04/22/developer-tools/isinputpending-api/) on engineering.fb.com (2019)
- [Better JS scheduling with isInputPending()](https://developer.chrome.com/docs/capabilities/web-apis/isinputpending) on developer.chrome.com (2020)
- [Optimizing long tasks](https://web.dev/articles/optimize-long-tasks) on web.dev (2022)
# Scheduling: isInputPending() method

{{SeeCompatTable}}{{APIRef("Prioritized Task Scheduling API")}}

The **`isInputPending()`** method of the {{domxref("Scheduling")}} interface allows you to check whether there are pending input events in the event queue, indicating that the user is attempting to interact with the page.

This feature can be useful in situations where you have a queue of tasks to run, and you want to yield to the main thread regularly to allow user interaction to occur so that the app is kept as responsive and performant as possible. `isInputPending()` allows you to yield only when there is input pending, rather than having to do it at arbitrary intervals.

> [!WARNING]
> The `isInputPending()` method has been superseded by features available on the {{domxref("Scheduler")}} interface such as {{domxref("Scheduler.yield()", "yield()")}}, which are better designed for addressing scheduling tasks. See [Don't use `isInputPending()`](https://web.dev/articles/optimize-long-tasks#isinputpending) for more details.

`isInputPending()` is called using `navigator.scheduling.isInputPending()`.

## Syntax

```js-nolint
isInputPending()
isInputPending(options)
```

### Parameters

- `options` {{optional_inline}}
  - : An object providing options. Currently, the only option is:
    - `includeContinuous` {{optional_inline}}
      - : A boolean, which is `false` by default. If set to `true`, it indicates that continuous events should be considered when checking for pending input. Continuous events are trusted events (events dispatched by the browser) that are fired successively, such as {{domxref("Element/mousemove_event", "mousemove")}}, {{domxref("Element/wheel_event", "wheel")}}, {{domxref("Element/touchmove_event", "touchmove")}}, {{domxref("HTMLElement/drag_event", "drag")}}, {{domxref("Element/pointermove_event", "pointermove")}}, and {{domxref("Element/pointerrawupdate_event", "pointerrawupdate")}}.

### Return value

A boolean that indicates whether there are pending input events in the event queue (`true`) or not (`false`).

## Examples

We can use `isInputPending()` inside a task runner structure to run the `yield()` function only when the user is attempting to interact with the page:

```js
function yield() {
  return new Promise((resolve) => {
    setTimeout(resolve, 0);
  });
}

async function main() {
  // Create an array of functions to run
  const tasks = [a, b, c, d, e];

  while (tasks.length > 0) {
    // Yield to a pending user input
    if (navigator.scheduling.isInputPending()) {
      await yield();
    } else {
      // Shift the first task off the tasks array
      const task = tasks.shift();

      // Run the task
      task();
    }
  }
}
```

This allows you to avoid blocking the main thread when the user is actively interacting with the page, potentially providing a smoother user experience. However, by only yielding when necessary, we can continue running the current task when there are no user inputs to process. This also avoids tasks being placed at the back of the queue behind other non-essential browser-initiated tasks that were scheduled after the current one.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Scheduler")}} interface
- {{domxref("Prioritized_task_scheduling_api", "Prioritized Task Scheduling API", "", "nocode")}}
- [Faster input events with Facebook's first browser API contribution](https://engineering.fb.com/2019/04/22/developer-tools/isinputpending-api/) on engineering.fb.com (2019)
- [Better JS scheduling with isInputPending()](https://developer.chrome.com/docs/capabilities/web-apis/isinputpending) on developer.chrome.com (2020)
- [Optimizing long tasks](https://web.dev/articles/optimize-long-tasks#yield_only_when_necessary) on web.dev (2022)
# Screen: availHeight property

{{APIRef("CSSOM view API")}}

The read-only {{DOMxRef("Screen")}} interface's
**`availHeight`** property returns the height, in CSS pixels, of
the space available for Web content on the screen. Since {{DOMxRef("Screen")}} is
exposed on the {{DOMxRef("Window")}} interface's {{DOMxRef("Window.screen", "window.screen")}}
property, you access `availHeight` using `window.screen.availHeight`.

You can similarly use {{DOMxRef("Screen.availWidth")}} to get the number of pixels
which are horizontally available to the browser for its use.

## Value

A numeric value indicating the number of CSS pixels tall the screen's available space
is. This can be no larger than the value of {{DOMxRef("Screen.height", "window.screen.height")}},
and will be less if the device or user agent reserves any
vertical space for itself.

For instance, on a Mac whose Dock is located at the bottom of screen (which is the default), the value of `availHeight` is approximately the value of `height` (the total height of the screen in CSS pixels) minus the heights of the Dock and menu bar, as seen in the diagram below. They only take up `availHeight` if they are always shown: if the page is fullscreened, or if the dock is configured to automatically hide and show, then they won't be counted in `availHeight`.

![Diagram showing how Screen.availHeight relates to Screen.height and the screen's contents](availheight-diagram.svg)

## Examples

If your web application needs to open a new window, such as a tool palette which can
contain multiple panels, and wants to position it so that it occupies the entire
vertical space available, you can do so using code similar to what's seen here.

In the main window, when it's time to open the panels, code like the following is used.

```js
const paletteWindow = window.open(
  "panels.html",
  "Panels",
  "left=0, top=0, width=200",
);
```

The Panels window's HTML, in `panels.html`, has JavaScript code of its own,
which is executed as soon as the window is created. It doesn't even need to wait for any
particular event (or any event at all). That code handles resizing the window based on
the available space:

```js
window.outerHeight = window.screen.availHeight;
```

The result is something similar to the below. Note the Panels window filling all
available vertical space at the left of the screen.

![Screenshot of the example for Screen.availHeight](screen-availheight.png)

On a Windows system, this would function similarly, by opening the window and sizing it
vertically so it uses all available vertical space, leaving room for the taskbar and any
other interface elements that reserve space.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{DOMxRef("Window")}}
- {{DOMxRef("Screen")}}
- {{DOMxRef("Screen.availWidth")}}
- {{DOMxRef("Window.innerHeight")}}
# Screen: availWidth property

{{APIRef("CSSOM view API")}}

The **`Screen.availWidth`** property returns the amount of
horizontal space (in CSS pixels) available to the window.

## Value

A number.

## Examples

```js
const screenAvailWidth = window.screen.availWidth;

console.log(screenAvailWidth);
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Using the Captured Surface Control API

{{DefaultAPISidebar("Screen Capture API")}}

This guide explains how to use the features provided by the Captured Surface Control API to control a display surface (browser tab, window, or screen) captured by the [Screen Capture API](/en-US/docs/Web/API/Screen_Capture_API).

## Background

The Screen Capture API is most commonly used to share another open tab or window on your device with other conference participants in a conferencing app, for example to demo a new feature or present a report.

A significant issue with this is that, when you want to interact with the captured display surface, for example to scroll the display or zoom it in, you can't do so without switching to the captured display surface. This creates several issues and makes the app more frustrating than it needs to be. Screen sharing users will find themselves having to jump back and forth between the conferencing app and the captured display surface to handle adjusting the media display, letting late users in, reading chat messages, and so on.

The Captured Surface Control API tackles these problems by allowing app developers to implement a limited set of features that can be used by conference participants to control the captured display surface from directly within the app, without compromising security.

Currently these are:

1. Zooming the captured display surface.
2. Using mouse wheel/touchpad gestures (and other equivalents) to scroll the captured display surface.

This functionality is all accessed via the {{domxref("CaptureController")}} object. To control a captured display surface, a capture controller must be passed into a {{domxref("MediaDevices.getDisplayMedia()")}} call inside its options object:

```js
controller = new CaptureController();

const displayMediaOptions = {
  controller,
};

videoElem.srcObject =
  await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);
```

The controller can then be used to, for example, zoom the captured display surface in:

```js
controller.increaseZoomLevel();
```

In this article we will walk through the code for a basic screen sharing app that shows how to implement such features.

## A note on permissions

A website can control access to the Captured Surface Control API using the {{HTTPHeader("Permissions-Policy")}} {{HTTPHeader("Permissions-Policy/captured-surface-control", "captured-surface-control")}} directive, or the equivalent {{HTMLElement("iframe")}} [`allow`](/en-US/docs/Web/HTML/Reference/Elements/iframe#allow) attribute value:

```html
<iframe allow="captured-surface-control" src="/some-other-document.html">
  ...
</iframe>
```

Specifically, the {{domxref("CaptureController.forwardWheel", "forwardWheel()")}}, {{domxref("CaptureController.increaseZoomLevel", "increaseZoomLevel()")}}, {{domxref("CaptureController.decreaseZoomLevel", "decreaseZoomLevel()")}}, and {{domxref("CaptureController.resetZoomLevel", "resetZoomLevel()")}} methods are controlled by this directive.

The default allowlist for `captured-surface-control` is `self`, which lets any content within the same origin use Captured Surface Control.

If permission is allowed by the website policy, the user may then grant (or deny) permission to access the controlled APIs. This can either be explicit permission, granted by responding to a prompt, or implicit permission granted by interacting with a control that calls one of the methods ([transient activation](/en-US/docs/Glossary/Transient_activation)) when user permission has not been explicitly denied.

See also [Screen Capture API > Security considerations](/en-US/docs/Web/API/Screen_Capture_API#security_considerations).

## App HTML

The markup for our sample app is as follows:

```html live-sample___surface-control-demo
<h1>Captured Surface Control API demo</h1>

<p>
  <button id="start">Start Capture</button>
  <button id="stop">Stop Capture</button>
</p>
<p id="zoom-controls">
  <button id="dec">Zoom -</button>
  <output>100%</output>
  <button id="inc">Zoom +</button>
  <button id="reset">Reset zoom</button>
</p>

<video autoplay></video>
```

This contains two sets of {{htmlelement("button")}} elements — one to start and stop screen capture, and one to control zooming the captured display surface. The latter also includes an {{htmlelement("output")}} element to print the current zoom level into.

Finally, we include a {{htmlelement("video")}} element to display the captured display surface into.

## App CSS

The app CSS is minimal; it is worth noting that we have given the `<video>` a {{cssxref("max-width")}} of `100%`, so that it is constrained inside the `<body>`. The `<video>` could grow dramatically when the captured display surface is embedded inside it (its size is the capture's intrinsic size), which could cause overflow issues if we didn't constrain it.

```css live-sample___surface-control-demo
body {
  max-width: 640px;
  margin: 0 auto;
}

video {
  max-width: 100%;
}
```

## Initial setup

In our first section of script, we define the variables we need to set up the app:

```js live-sample___surface-control-demo
// Grab references to the <video> element and zoom controls
const videoElem = document.querySelector("video");
const zoomControls = document.getElementById("zoom-controls");

// Grab references to the start and stop capture buttons
const startBtn = document.getElementById("start");
const stopBtn = document.getElementById("stop");

// Grab references to the zoom out, in, and reset buttons,
// and the zoom level output
const decBtn = document.getElementById("dec");
const outputElem = document.querySelector("output");
const incBtn = document.getElementById("inc");
const resetBtn = document.getElementById("reset");

// Define variables to store the controller and the zoom levels
// in, when we later create them
let controller = undefined;
let zoomLevels = undefined;
```

We then initially hide the surface controls bar by setting its {{cssxref("display")}} CSS property to `none`, and disable the stop button by setting its [`disabled`](/en-US/docs/Web/HTML/Reference/Attributes/disabled) attribute to `true`. These controls are not relevant until we have started capture, so we don't want to confuse the user by showing them at the start.

```js live-sample___surface-control-demo
zoomControls.style.display = "none";
stopBtn.disabled = true;
```

## Controlling screen capture

Next up, we add `click` event listeners (using {{domxref("EventTarget.addEventListener()")}}) to the start and stop buttons, to start and stop screen capture when they are pressed.

```js live-sample___surface-control-demo
startBtn.addEventListener("click", startCapture);
stopBtn.addEventListener("click", stopCapture);
```

The `startCapture()` function, which starts screen capture, looks like so. We first create a new `CaptureController`, and pass it into our [`MediaDisplayOptions`](/en-US/docs/Web/API/MediaDevices/getDisplayMedia#options) object, along with a [`displaySurface`](/en-US/docs/Web/API/MediaTrackConstraints/displaySurface) constraint that causes the app to recommend sharing browser tabs.

Now it's time to capture our media; we do so using a {{domxref("MediaDevices.getDisplayMedia()")}} call, to which we pass our options, and set the resulting promise as the value of the `<video>` element's {{domxref("HTMLMediaElement.srcObject", "srcObject")}} property. When it resolves, we continue the function by calling {{domxref("CaptureController.resetZoomLevel()")}} and setting the `<output>` element's contents to `100%`. This is not strictly necessary, but it can be a bit confusing when you capture a tab to find it is already zoomed out or in. Setting the zoom level to `100%` on capture feels a bit more logical. These lines of code deal with the case where the app is refreshed without pressing "Stop Capture", then capture is started again.

Our next step is to call {{domxref("CaptureController.getSupportedZoomLevels()")}} to retrieve the zoom levels the captured display surface supports, and store the resulting array in the `zoomLevels` variable.

Next, we use the controller's {{domxref("CaptureController.zoomlevelchange_event", "zoomlevelchange")}} event to detect when the zoom level is changed, print the current {{domxref("CaptureController.zoomLevel", "zoomLevel")}} to the `<output>` element, and call the user-defined `updateZoomButtonState()` function. This function will query the `zoomLevels` array to check whether the user can zoom in or out any further after each zoom change. We'll explain `updateZoomButtonState()` later on.

We next unhide our zoom controls with `display: block`, enable our stop button, and disable our start button, so that the state of the controls makes sense after capture has bene started.

To finish off our function, we call {{domxref("CaptureController.setFocusBehavior()")}} to stop the focus shifting to the captured display surface when the capture starts, and call our user-defined `startForwarding()` function to enable scrolling the captured display surface with wheel/touchpad gestures. We'll explain this function later on.

```js live-sample___surface-control-demo
async function startCapture() {
  try {
    // Create a new CaptureController instance
    controller = new CaptureController();

    // Options for getDisplayMedia()
    const displayMediaOptions = {
      controller,
      video: {
        displaySurface: "browser",
      },
    };

    // Capture a tab and display it inside the video element
    videoElem.srcObject =
      await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);

    // Reset the zoom level when capture starts
    controller.resetZoomLevel();
    outputElem.textContent = `100%`;

    // Get zoom levels for the current captured display surface
    zoomLevels = controller.getSupportedZoomLevels();

    // Report zoom level when it changes
    controller.addEventListener("zoomlevelchange", () => {
      outputElem.textContent = `${controller.zoomLevel}%`;
      updateZoomButtonState();
    });

    zoomControls.style.display = "block";
    stopBtn.disabled = false;
    startBtn.disabled = true;

    // Stop the focus from jumping to the captured tab, if you are self-sharing
    controller.setFocusBehavior("focus-capturing-application");

    // Start forwarding wheel events
    startForwarding();
  } catch (e) {
    console.error(e);
  }
}
```

Now on to the definition of our `stopCapture()` function, which stops screen capture. We start this function by again calling {{domxref("CaptureController.resetZoomLevel()")}} and setting the `<output>` element's contents to `100%` so the zoom level is reset. This deals with the case where you stop the capture by pressing "Stop Capture" and then start it again.

We then loop through all of the {{domxref("MediaStreamTrack")}} objects associated with the {{domxref("MediaStream")}} and {{domxref("MediaStreamTrack.stop", "stop()")}} them all. We then call the `resetApp()` function, which sets the `<video>` element's `srcObject` back to `null`, hides the zoom controls, disables the stop button, and enables the start button.

```js live-sample___surface-control-demo
function stopCapture() {
  let tracks = videoElem.srcObject.getTracks();
  tracks.forEach((track) => track.stop());
  resetApp();
}

function resetApp() {
  videoElem.srcObject = null;
  zoomControls.style.display = "none";
  stopBtn.disabled = true;
  startBtn.disabled = false;
}
```

## Implementing zoom controls

In the next section of our script, we wire up our zoom buttons to appropriate `click` handler functions so we can zoom the captured display surface in and out. The functions they run when clicked are as follows:

- "Zoom out" button: `decreaseZoom()`. This calls the {{domxref("CaptureController.decreaseZoomLevel()")}} method, zooming the captured surface out.
- "Zoom in" button: `increaseZoom()`. This calls the {{domxref("CaptureController.increaseZoomLevel()")}} method, zooming the captured surface in.
- "Reset zoom" button: `resetZoom()`. This calls the {{domxref("CaptureController.resetZoomLevel()")}} method, resetting the captured surface to its starting zoom factor, which is `100`.

```js live-sample___surface-control-demo
decBtn.addEventListener("click", decreaseZoom);
incBtn.addEventListener("click", increaseZoom);
resetBtn.addEventListener("click", resetZoom);

async function decreaseZoom() {
  try {
    await controller.decreaseZoomLevel();
  } catch (e) {
    console.log(e);
  }
}

async function increaseZoom() {
  try {
    await controller.increaseZoomLevel();
  } catch (e) {
    console.log(e);
  }
}

async function resetZoom() {
  await controller.resetZoomLevel();
}
```

> [!NOTE]
> It is generally a best practice to call `decreaseZoomLevel()` and `increaseZoomLevel()` from within a [`try...catch`](/en-US/docs/Web/JavaScript/Reference/Statements/try...catch) block because the zoom level could be changed asynchronously by an entity other than the application, which might lead to an error being thrown. For example, the user might directly interact with the captured surface to zoom in or out.

When the zoom changes, the controller's {{domxref("CaptureController.zoomlevelchange_event", "zoomlevelchange")}} event fires, which causes the code we saw earlier in the `startCapture()` function to run, writing the updated zoom level to the `<output>` element and running the `updateZoomButtonState()` function to stop the user from zooming in and out too far.

```js
controller.addEventListener("zoomlevelchange", () => {
  outputElem.textContent = `${controller.zoomLevel}%`;
  updateZoomButtonState();
});
```

## Forwarding wheel events to the captured display surface

Earlier on, at bottom of the `startCapture()` function, we ran the `startForwarding()` function, which allows the captured display surface to be scrolled from the capturing app. This runs the {{domxref("CaptureController.forwardWheel()")}} method, to which we pass a reference to the `<video>` element. When the resulting promise resolves, the browser starts to forward all {{domxref("Element.wheel_event", "wheel")}} events fired on the `<video>` to the captured tab or window, so it will scroll.

```js live-sample___surface-control-demo
async function startForwarding() {
  try {
    await controller.forwardWheel(videoElem);
  } catch (e) {
    console.log(e);
  }
}
```

## Stopping the user from zooming in and out too far

Finally, it's time to define the `updateZoomButtonState()` function, which is run inside the `zoomlevelchange` event handler function you saw earlier. The problem this solves is that, if you try to zoom out below the minimum supported zoom level, or zoom in above the maximum supported zoom level, `decreaseZoomLevel()`/`increaseZoomLevel()` will throw an `InvalidStateError` {{domxref("DOMException")}}.

The `updateZoomButtonState()` function avoids this issue by first making sure both the "Zoom out" and "Zoom in" buttons are enabled. It then does two checks:

- If the current zoom level (returned by the `CaptureController.zoomLevel` property) is equal to the minimum supported zoom level (stored in the first value of the `zoomLevels` array), we disable the "Zoom out" button so the user can't zoom out any further.
- If the current zoom level is equal to the maximum supported zoom level (stored in the last value of the `zoomLevels` array), we disable the "Zoom in" button so the user can't zoom in any further.

```js live-sample___surface-control-demo
function updateZoomButtonState() {
  decBtn.disabled = false;
  incBtn.disabled = false;
  if (controller.zoomLevel === zoomLevels[0]) {
    decBtn.disabled = true;
  } else if (controller.zoomLevel === zoomLevels[zoomLevels.length - 1]) {
    incBtn.disabled = true;
  }
}
```

## Finished demo

The finished demo renders like this:

{{EmbedLiveSample("surface-control-demo", , "500px", , , , "display-capture; captured-surface-control")}}
# Using the Element Capture and Region Capture APIs

{{DefaultAPISidebar("Screen Capture API")}}

This guide provides a walkthrough of typical usage of the Element Capture and Region Capture APIs, showing how to use them and the problem they solve.

## Background

By default, the [Screen Capture API](/en-US/docs/Web/API/Screen_Capture_API) captures an entire screen, window, or tab. The Element Capture and Region Capture APIs respectively enable you to restrict the captured stream to a specific rendered DOM tree, or to the part of the screen defined by a specific DOM tree's bounding box.

This is useful when you want to share only a limited region to cut down on unnecessary bandwidth or screen space required to show the capture, or for privacy reasons (you might not want to show other participants your message notifications, or background settings required to run the demo you are sharing).

In addition, when capturing your web cam output, you can end up with one of those undesirable "infinite wormhole" or "hall of mirrors" type effects. The Element Capture and Region Capture APIs can help you avoid these kinds of problems too.

## When to use each API

The Element Capture API captures the element itself (and its descendants), whereas the Region Capture API captures the area of the browser tab defined by the bounding box of the target element. Element Capture will always show just the captured element, even if other DOM content overlaps it, whereas Region Capture can result in overlapping content being shown over the top of the content you intended to share.

There are legitimate use cases for both:

- If you need to keep the capture specific to one DOM tree, and exclude anything outside it, then the Element Capture API is a better choice. For example, you don't want private content such as a set of message notifications or a speaker notes UI showing up in the capture.
- However, if you really do want to capture a region of the browser tab, regardless of what is shown in it, the Region Capture API will serve you well.

In the next section we'll start with a basic Screen Capture API demo to illustrate the issues that the Element Capture and Region Capture APIs were created to solve.

## Screen Capture API demo

This demo uses the Screen Capture API to capture a window, screen, or tab, and broadcast the stream via a {{htmlelement("video")}} element on the same page. You can see it running live at [Screen Capture API example](https://mdn.github.io/dom-examples/screen-capture-api/basic-screen-capture/) (also see the [source code](https://github.com/mdn/dom-examples/tree/main/screen-capture-api/basic-screen-capture)).

### HTML

The HTML starts off with a main heading and intro text, then includes two {{htmlelement("button")}} elements to start and stop the capture:

```html
<h1>Screen Capture API example</h1>
<p>
  This example shows you the contents of the selected part of your display.
  Click the Start Capture button to begin.
</p>

<p>
  <button id="start">Start Capture</button>&nbsp;
  <button id="stop">Stop Capture</button>
</p>
```

Next, we include the main app container, which contains the `<video>` element to broadcast the capture, and plus a demo placeholder {{htmlelement("div")}}:

```html
<div id="main-app">
  <video autoplay></video>
  <div id="demo">
    <h2>Some kind of demo</h2>
    <p>
      This container is a placeholder for some kind of demo that you might want
      to share with other participants.
    </p>
  </div>
</div>
```

### CSS

The CSS for this demo is mostly unremarkable, but the following few rules are worth explaining. We've hidden the rest of the CSS for brevity.

```css hidden
* {
  box-sizing: border-box;
}

body {
  padding: 0 25px;
}

video,
#demo > p {
  border: 1px solid #cccccc;
  margin: 0;
}

#demo > h2 {
  margin-top: 0;
}

#demo > p {
  padding: 5px;
  height: 320px;
}
```

We set a {{cssxref("display")}} value of `flex` on the `main-app` `<div>` to lay the video and the demo placeholder out side by side in two columns, setting a {{cssxref("gap")}} of `5%` between them. We also set a {{cssxref("min-width")}} of `980px` on the container, essentially limiting the demo app to being a desktop layout. This is because Element Capture and Region Capture are only supported on desktop browsers, and off-screen content is not captured.

```css
#main-app {
  display: flex;
  gap: 5%;
  min-width: 980px;
}
```

We also give the `<video>` element and the `demo` `<div>` a {{cssxref("flex")}} value of `1`, so they will take up the same amount of horizontal space.

```css
video,
#demo {
  flex: 1;
}
```

Finally, we give the `<video>` element a {{cssxref("max-width")}} of `50%` and a fixed {{cssxref("aspect-ratio")}} of `4/3`. This is to keep the video at a consistent size and avoid too much layout upheaval when the screen capture starts to be broadcast. If we didn't do this, the `<video>` element would grow to the same width as the entire captured area (window or screen), which would affect the layout. It is a {{ glossary("replaced elements", "replaced element")}}, after all, so its [intrinsic size](/en-US/docs/Glossary/Intrinsic_Size) depends on that of its content.

```css
video {
  max-width: 50%;
  aspect-ratio: 4/3;
}
```

Layout shift can also cause problems when using the Region and Element Capture APIs, hence this code is included in all three demos.

### JavaScript

The JavaScript for this example is adapted from the [Streaming screen capture](/en-US/docs/Web/API/Screen_Capture_API/Using_Screen_Capture#streaming_screen_capture) example in our "Using the Screen Capture API" guide. We won't repeat the full code explanation here; we'll just explain the most relevant capture code.

In the options object passed into `getDisplayMedia()` when we invoke it, we set [`preferCurrentTab: true`](/en-US/docs/Web/API/MediaDevices/getDisplayMedia#prefercurrenttab). This hint suggests that the browser should offer the user's current tab as the most prominent capture source in the dialog that asks them what to share. Chrome, for example, only gives them this option when `preferCurrentTab: true` is set.

```js
const displayMediaOptions = {
  video: {
    displaySurface: "window",
  },
  preferCurrentTab: true,
};
```

This option is very useful if you are building an app with a built-in "share screen" option — you don't want to allow users to share a different tab or window.

When the "Start Capture" button is pressed, the `startCapture()` function runs, which invokes {{domxref("MediaDevices.getDisplayMedia()")}}. This causes the browser to prompt the user to choose a surface to share (window, tab, etc.). Once a choice is made, the resulting {{domxref("MediaStream")}} is set to the value of the `<video>` element's {{domxref("HTMLMediaElement.srcObject")}} property to broadcast it:

```js
async function startCapture() {
  try {
    videoElem.srcObject =
      await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);
  } catch (err) {
    console.error(err);
  }
}
```

## Screen Capture API issues

Run the demo above in a [supporting browser](/en-US/docs/Web/API/Screen_Capture_API#browser_compatibility), click "Start Capture", and select the same tab the demo is running in. You will see the "hall of mirrors effect", as mentioned earlier:

![A browser window containing a video capture of that same browser window, meaning that it shows infinite captures inside captures, getting smaller and smaller](hall-of-mirrors.png)

This obviously isn't ideal, and would cause issues in any kind of conferencing application with a built-in "share screen" option.

## The Element Capture API

The Element Capture API restricts the captured region to a specified rendered DOM tree (a selected element and its descendants). In this section we will explore a second demo that is identical to the one presented above, except that it uses Element Capture on top of basic Screen Capture. See this demo running live at [Element Capture API example](https://mdn.github.io/dom-examples/screen-capture-api/element-capture/) (also see the [source code](https://github.com/mdn/dom-examples/tree/main/screen-capture-api/element-capture)).

The HTML is identical to the previous example, and the CSS is _nearly_ identical. We'll explain the differences in the JavaScript now, then look at the CSS differences later on, in the [Restrictions on the Element Capture API](#restrictions_on_the_element_capture_api) section.

To use the Element Capture API, we additionally grab a reference to a DOM element that we will later use as a **restriction target** — the screen area shown in the stream will be restricted to just that rendered element and its descendants:

```js
const demoElem = document.querySelector("#demo");
```

The other code differences are all in the modified `startCapture()` function:

```js
async function startCapture() {
  try {
    const stream =
      await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);
    const [track] = stream.getVideoTracks();
    const restrictionTarget = await RestrictionTarget.fromElement(demoElem);
    await track.restrictTo(restrictionTarget);
    videoElem.srcObject = stream;
  } catch (err) {
    console.error(err);
  }
}
```

1. Here, we start by grabbing the media stream as before, using `mediaDevices.getDisplayMedia()`.
2. We then isolate the video track from the stream using {{domxref("MediaStream.getVideoTracks()")}}.
3. We create the necessary `restrictionTarget` object to apply the restriction to the video track by running {{domxref("RestrictionTarget.fromElement_static", "RestrictionTarget.fromElement()")}}, passing to it the DOM element reference we grabbed earlier.
4. We apply the restriction target to the track by calling {{domxref("BrowserCaptureMediaStreamTrack.restrictTo()")}} on it, passing it the `restrictionTarget` object.
5. Once all the above is done, we then set the `<video>` element's `srcObject` property value to the stream, to start broadcasting it.

Try running the [Element Capture API example](https://mdn.github.io/dom-examples/screen-capture-api/element-capture/) in a [supporting browser](/en-US/docs/Web/API/RestrictionTarget#browser_compatibility) now. You should see that only the demo placeholder is included in the stream, thereby fixing the "hall of mirrors" problem.

> [!NOTE]
> You can stop the restriction by calling `restrictTo()` again on the same track, passing an argument of `null` to it:
>
> ```js
> await track.restrictTo(null);
> ```

### Restrictions on the Element Capture API

To ensure that the element is **eligible for restriction**, that is, it will be captured when chosen as the restriction target element, it must form a [stacking context](/en-US/docs/Web/CSS/CSS_positioned_layout/Stacking_context) and be flattened in 3D space.

To handle these restrictions, we've set the following additional CSS rule that targets the demo container element:

```css
#demo {
  /* Forms a stacking context */
  isolation: isolate;
  /* Flattened */
  transform-style: flat;
  /* Explicit background color to stop the capture being transparent */
  background-color: white;
}
```

The {{cssxref("isolation")}} property is set to `isolate` to make the element form a stacking context, and the {{cssxref("transform-style")}} property is set to `flat` to flatten it. Also, because of the nature of the isolation we've set, the element will no longer inherit the page's default white color. As a result, we set {{cssxref("background-color")}} to `white` to stop the capture being transparent.

For the full list of restrictions on the elements that can be used as restriction targets, see the [`RestrictionTarget.fromElement()`](/en-US/docs/Web/API/RestrictionTarget/fromElement_static#element) reference page.

## The Region Capture API

The Region Capture API has a very similar effect to the Element Capture API, except that rather than restricting the captured region to a specific rendered DOM tree, it crops the stream to the area of the current browser tab defined by the bounding box of the target element. Let's look at a demo and then explore the differences between the two in more detail later on.

In this section we will explore a third demo that is identical to the others, except that it uses Region Capture on top of basic Screen Capture. See this demo running live at [Region Capture API example](https://mdn.github.io/dom-examples/screen-capture-api/region-capture/) (also see the [source code](https://github.com/mdn/dom-examples/tree/main/screen-capture-api/region-capture)).

The HTML and CSS are identical to the previous examples. The JavaScript is nearly the same as the Element Capture JavaScript, with a few notable differences that we'll now explain.

To use the Region Capture API, we first grab a reference to a DOM element that we will later use as a **crop target** — the region shown in the stream will be cropped to just the area that element is rendered in:

```js
const demoElem = document.querySelector("#demo");
```

Now let's examine the Region Capture demo's `startCapture()` function:

```js
async function startCapture() {
  try {
    const stream =
      await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);
    const [track] = stream.getVideoTracks();
    const cropTarget = await CropTarget.fromElement(demoElem);
    await track.cropTo(cropTarget);
    videoElem.srcObject = stream;
  } catch (err) {
    console.error(err);
  }
}
```

1. As before, we start by grabbing the media stream using `mediaDevices.getDisplayMedia()`, then isolate the video track from the stream using {{domxref("MediaStream.getVideoTracks()")}}.
2. We create the necessary `cropTarget` object to apply the crop to the video track by running {{domxref("CropTarget.fromElement_static", "fromElement()")}}, passing to it the DOM element reference we grabbed earlier.
3. We apply the crop target to the track by calling {{domxref("BrowserCaptureMediaStreamTrack.cropTo()")}} on it, passing it the `cropTarget` object.
4. Once all the above is done, we then set the `<video>` element's `srcObject` property value to the stream, to start broadcasting it.

Try running the [Region Capture API example](https://mdn.github.io/dom-examples/screen-capture-api/region-capture/) in a [supporting browser](/en-US/docs/Web/API/CropTarget#browser_compatibility) now. You should see that only the demo placeholder is included in the stream, which also fixes the "hall of mirrors" problem.

> [!NOTE]
> You can stop the cropping by calling `cropTo()` again on the same track, passing an argument of `null` to it:
>
> ```js
> await track.cropTo(null);
> ```

### Restrictions on the Region Capture API

Region Capture doesn't have the same level of restrictions as Element Capture — it is cropping the stream to a particular size, rather than broadcasting a specific rendered DOM tree, so it doesn't require this rule:

```css
#demo {
  /* Forms a stacking context */
  isolation: isolate;
  /* Flattened */
  transform-style: flat;
  /* Explicit background color to stop the capture being transparent */
  background-color: white;
}
```

However, there are still restrictions on the elements that can be used as crop targets. For the full list, see the [`CropTarget.fromElement()`](/en-US/docs/Web/API/CropTarget/fromElement_static#element) reference page.

## See also

- [Capture a video stream from any element](https://developer.chrome.com/docs/web-platform/element-capture) on developer.chrome.com (2025)
- [Better tab sharing with Region Capture](https://developer.chrome.com/docs/web-platform/region-capture) on developer.chrome.com (2023)
# Screen Capture API

{{DefaultAPISidebar("Screen Capture API")}}

The Screen Capture API introduces additions to the existing Media Capture and Streams API to let the user select a screen or portion of a screen (such as a window) to capture as a media stream. This stream can then be recorded or shared with others over the network.

## Screen Capture API concepts and usage

The Screen Capture API is relatively simple to use. Its main method is {{domxref("MediaDevices.getDisplayMedia()")}}, whose job is to ask the user to select a screen or portion of a screen to capture in the form of a {{domxref("MediaStream")}}.

To start capturing video from the screen, you call `getDisplayMedia()` on `navigator.mediaDevices`:

```js
captureStream =
  await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);
```

The {{jsxref("Promise")}} returned by `getDisplayMedia()` resolves to a {{domxref("MediaStream")}} which streams the captured display surface.

See the article [Using the Screen Capture API](/en-US/docs/Web/API/Screen_Capture_API/Using_Screen_Capture) for a more in-depth look at how to use the API to capture screen contents as a stream.

### Screen capture extensions

The Screen Capture API has additional features that extend its capabilities:

#### Limiting the screen area captured in the stream

- The **Element Capture API** restricts the captured region to a specified rendered DOM element and its descendants.
- The **Region Capture API** crops the captured region to the area of the screen in which a specified DOM element is rendered.

See [Using the Element Capture and Region Capture APIs](/en-US/docs/Web/API/Screen_Capture_API/Element_Region_Capture) to learn more.

#### Controlling the captured screen area

The **Captured Surface Control API** allows the capturing application to provide limited control over the captured display surface, for example zooming and scrolling its contents.

See [Using the Captured Surface Control API](/en-US/docs/Web/API/Screen_Capture_API/Captured_Surface_Control) to learn more.

## Interfaces

- {{domxref("BrowserCaptureMediaStreamTrack")}}
  - : Represents a single video track; extends the {{domxref("MediaStreamTrack")}} class with methods to limit the part of a self-capture stream (for example, a user's screen or window) that is captured.
- {{domxref("CaptureController")}}
  - : Provides methods that can be used to further manipulate a captured display surface (captured via {{domxref("MediaDevices.getDisplayMedia()")}}). A `CaptureController` object is associated with a captured display surface by passing it into a `getDisplayMedia()` call as the value of the options object's `controller` property.
- {{domxref("CropTarget")}}
  - : Provides a static method, {{domxref("CropTarget.fromElement_static", "fromElement()")}}, which returns a {{domxref("CropTarget")}} instance that can be used to crop a captured video track to the area in which a specified element is rendered.
- {{domxref("RestrictionTarget")}}
  - : Provides a static method, {{domxref("RestrictionTarget.fromElement_static", "fromElement()")}}, which returns a {{domxref("RestrictionTarget")}} instance that can be used to restrict a captured video track to a specified DOM element.

## Additions to the MediaDevices interface

- {{domxref("MediaDevices.getDisplayMedia()")}}
  - : The `getDisplayMedia()` method is added to the `MediaDevices` interface. Similar to {{domxref("MediaDevices.getUserMedia", "getUserMedia()")}}, this method creates a promise that resolves with a {{domxref("MediaStream")}} containing the display area selected by the user, in a format that matches the specified options.

## Additions to existing dictionaries

The Screen Capture API adds properties to the following dictionaries defined by other specifications.

### MediaTrackConstraints

- {{domxref("MediaTrackConstraints.displaySurface")}}
  - : A [`ConstrainDOMString`](/en-US/docs/Web/API/MediaTrackConstraints#constraindomstring) indicating what type of display surface is to be captured. The value is one of `browser`, `monitor`, or `window`.
- {{domxref("MediaTrackConstraints.logicalSurface")}}
  - : Indicates whether or not the video in the stream represents a logical display surface (that is, one which may not be entirely visible onscreen, or may be completely offscreen). A value of `true` indicates a logical display surface is to be captured.
- {{domxref("MediaTrackConstraints.suppressLocalAudioPlayback")}}
  - : Controls whether the audio playing in a tab will continue to be played out of a user's local speakers when the tab is captured, or whether it will be suppressed. A value of `true` indicates that it will be suppressed.

### MediaTrackSettings

- {{domxref("MediaTrackSettings.cursor")}}
  - : A string which indicates whether or not the display surface currently being captured includes the mouse cursor, and if so, whether it's only visible while the mouse is in motion or if it's always visible. The value is one of `always`, `motion`, or `never`.
- {{domxref("MediaTrackSettings.displaySurface")}}
  - : A string indicating what type of display surface is currently being captured. The value is one of `browser`, `monitor`, or `window`.
- {{domxref("MediaTrackSettings.logicalSurface")}}
  - : A boolean value, which is `true` if the video being captured doesn't directly correspond to a single onscreen display area.
- {{domxref("MediaTrackSettings.suppressLocalAudioPlayback")}}
  - : A boolean value, which is `true` if the audio being captured is not played out of the user's local speakers.
- {{domxref("MediaTrackSettings.screenPixelRatio")}}
  - : A number representing the ratio of the physical size of a pixel on the captured display surface (displayed at its physical resolution) to the logical size of a CSS pixel on the capturing screen (displayed at its logical resolution). It cannot be used as a constraint or capability.

### MediaTrackSupportedConstraints

- {{domxref("MediaTrackSupportedConstraints.displaySurface")}}
  - : A boolean, which is `true` if the current environment supports the {{domxref("MediaTrackConstraints.displaySurface")}} constraint.
- {{domxref("MediaTrackSupportedConstraints.logicalSurface")}}
  - : A boolean, which is `true` if the current environment supports the constraint {{domxref("MediaTrackConstraints.logicalSurface")}}.
- {{domxref("MediaTrackSupportedConstraints.suppressLocalAudioPlayback")}}
  - : A boolean, which is `true` if the current environment supports the constraint {{domxref("MediaTrackConstraints.suppressLocalAudioPlayback")}}.

## Security considerations

Websites that support [Permissions Policy](/en-US/docs/Web/HTTP/Guides/Permissions_Policy) (either using the HTTP {{HTTPHeader("Permissions-Policy")}} header or the {{HTMLElement("iframe")}} attribute [`allow`](/en-US/docs/Web/HTML/Reference/Elements/iframe#allow)) can specify a desire to use the Screen Capture API using the directive {{HTTPHeader("Permissions-Policy/display-capture", "display-capture")}}:

```html
<iframe allow="display-capture" src="/some-other-document.html">…</iframe>
```

A site can also specify a desire to use the [Captured Surface Control API](/en-US/docs/Web/API/Screen_Capture_API/Captured_Surface_Control) via the {{HTTPHeader("Permissions-Policy/captured-surface-control", "captured-surface-control")}} directive. Specifically, the {{domxref("CaptureController.forwardWheel", "forwardWheel()")}}, {{domxref("CaptureController.increaseZoomLevel", "increaseZoomLevel()")}}, {{domxref("CaptureController.decreaseZoomLevel", "decreaseZoomLevel()")}}, and {{domxref("CaptureController.resetZoomLevel", "resetZoomLevel()")}} methods are controlled by this directive.

The default allowlist for both directives is `self`, which permits any content within the same origin use Screen Capture.

These methods are considered [powerful features](/en-US/docs/Web/Security#secure_contexts_and_feature_permissions), which means that even if permission is allowed via a `Permissions-Policy`, the user will still be prompted for permission to use them. The [Permissions API](/en-US/docs/Web/API/Permissions_API) can be used to query the aggregate permission (from both the website and the user) for using the listed features.

In addition, the specification requires that a user has recently interacted with the page to use these features — this means that [transient activation](/en-US/docs/Glossary/Transient_activation) is required. See the individual method pages for more details.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Using the Screen Capture API](/en-US/docs/Web/API/Screen_Capture_API/Using_Screen_Capture)
- [Using the Element Capture and Region Capture APIs](/en-US/docs/Web/API/Screen_Capture_API/Element_Region_Capture)
- [Using the Captured Surface Control API](/en-US/docs/Web/API/Screen_Capture_API/Captured_Surface_Control)
- {{domxref("MediaDevices.getDisplayMedia()")}}
# Using the Screen Capture API

{{DefaultAPISidebar("Screen Capture API")}}

In this article, we will examine how to use the Screen Capture API and its {{domxref("MediaDevices.getDisplayMedia", "getDisplayMedia()")}} method to capture part or all of a screen for streaming, recording, or sharing during a [WebRTC](/en-US/docs/Web/API/WebRTC_API) conference session.

> [!NOTE]
> It may be useful to note that recent versions of the [WebRTC adapter.js shim](https://github.com/webrtcHacks/adapter) include implementations of `getDisplayMedia()` to enable screen sharing on browsers that support it but do not implement the current standard API. This works with at least Chrome, Edge, and Firefox.

## Capturing screen contents

Capturing screen contents as a live {{domxref("MediaStream")}} is initiated by calling {{domxref("MediaDevices.getDisplayMedia", "navigator.mediaDevices.getDisplayMedia()")}}, which returns a promise that resolves to a stream containing the live screen contents. The `displayMediaOptions` object referenced in the below examples might look something like this:

```js
const displayMediaOptions = {
  video: {
    displaySurface: "browser",
  },
  audio: {
    suppressLocalAudioPlayback: false,
  },
  preferCurrentTab: false,
  selfBrowserSurface: "exclude",
  systemAudio: "include",
  surfaceSwitching: "include",
  monitorTypeSurfaces: "include",
};
```

### Starting screen capture: `async`/`await` style

```js
async function startCapture(displayMediaOptions) {
  let captureStream = null;

  try {
    captureStream =
      await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);
  } catch (err) {
    console.error(`Error: ${err}`);
  }
  return captureStream;
}
```

You can write this code either using an asynchronous function and the [`await`](/en-US/docs/Web/JavaScript/Reference/Operators/await) operator, as shown above, or using the {{jsxref("Promise")}} directly, as seen below.

### Starting screen capture: `Promise` style

```js
function startCapture(displayMediaOptions) {
  return navigator.mediaDevices
    .getDisplayMedia(displayMediaOptions)
    .catch((err) => {
      console.error(err);
      return null;
    });
}
```

Either way, the {{Glossary("user agent")}} responds by presenting a user interface that prompts the user to choose the screen area to share. Both of these implementations of `startCapture()` return the {{domxref("MediaStream")}} containing the captured display imagery.

See [Options and constraints](#options_and_constraints), below, for more on both how to specify the type of surface you want as well as other ways to adjust the resulting stream.

### Example of a window allowing the user to select a display surface to capture

![Screenshot of Chrome's window for picking a source surface](chrome-screen-capture-window.png)

You can then use the captured stream, `captureStream`, for anything that accepts a stream as input. The [examples](#examples) below show a few ways to make use of the stream.

### Visible vs. logical display surfaces

For the purposes of the Screen Capture API, a **display surface** is any content object that can be selected by the API for sharing purposes. Sharing surfaces include the contents of a browser tab, a complete window, and a monitor (or group of monitors combined together into one surface).

There are two types of display surface. A **visible display surface** is a surface which is entirely visible on the screen, such as the frontmost window or tab, or the entire screen.

A **logical display surface** is one which is in part or completely obscured, either by being overlapped by another object to some extent, or by being entirely hidden or offscreen. How these are handled by the Screen Capture API varies. Generally, the browser will provide an image which obscures the hidden portion of the logical display surface in some way, such as by blurring or replacing with a color or pattern. This is done for security reasons, as the content that cannot be seen by the user may contain data which they do not want to share.

A user agent might allow the capture of the entire content of an obscured window after gaining permission from the user to do so. In this case, the user agent may include the obscured content, either by getting the current contents of the hidden portion of the window or by presenting the most-recently-visible contents if the current contents are not available.

### Options and constraints

The options object passed into {{domxref("MediaDevices.getDisplayMedia", "getDisplayMedia()")}} is used to set options for the resulting stream.

The `video` and `audio` objects passed into the options object can also hold additional constraints particular to those media tracks. See [Properties of shared screen tracks](/en-US/docs/Web/API/MediaTrackConstraints#instance_properties_of_shared_screen_tracks) for details about additional constraints for configuring a screen-capture stream that are added to {{domxref("MediaTrackConstraints")}}, {{domxref("MediaTrackSupportedConstraints")}}, and {{domxref("MediaTrackSettings")}}).

None of the constraints are applied in any way until after the content to capture has been selected. The constraints alter what you see in the resulting stream. For example, if you specify a {{domxref("MediaTrackConstraints.width", "width")}} constraint for the video, it's applied by scaling the video after the user selects the area to share. It doesn't establish a restriction on the size of the source itself.

> [!NOTE]
> Constraints _never_ cause changes to the list of sources available for capture by the Screen Sharing API. This ensures that web applications can't force the user to share specific content by restricting the source list until only one item is left.

While display capture is in effect, the machine which is sharing screen contents will display some form of indicator so the user is aware that sharing is taking place.

> [!NOTE]
> For privacy and security reasons, screen sharing sources are not enumerable using {{domxref("MediaDevices.enumerateDevices", "enumerateDevices()")}}. Related to this, the {{domxref("MediaDevices/devicechange_event", "devicechange")}} event is never sent when there are changes to the sources available for `getDisplayMedia()`.

### Capturing shared audio

{{domxref("MediaDevices.getDisplayMedia", "getDisplayMedia()")}} is most commonly used to capture video of a user's screen (or parts thereof). However, {{Glossary("user agent", "user agents")}} may allow the capture of audio along with the video content. The source of this audio might be the selected window, the entire computer's audio system, or the user's microphone (or a combination of all of the above).

Before starting a project that will require sharing of audio, be sure to check the [browser compatibility](/en-US/docs/Web/API/MediaDevices/getDisplayMedia#browser_compatibility) for `getDisplayMedia()` to see if the browsers you wish compatibility with have support for audio in captured screen streams.

To request that the screen be shared with included audio, the options passed into `getDisplayMedia()` might look like this:

```js
const displayMediaOptions = {
  video: true,
  audio: true,
};
```

This allows the user total freedom to select whatever they want, within the limits of what the user agent supports. This could be refined further by specifying additional options, and constraints inside the `audio` and `video` objects:

```js
const displayMediaOptions = {
  video: {
    displaySurface: "window",
  },
  audio: {
    echoCancellation: true,
    noiseSuppression: true,
    sampleRate: 44100,
    suppressLocalAudioPlayback: true,
  },
  surfaceSwitching: "include",
  selfBrowserSurface: "exclude",
  systemAudio: "exclude",
};
```

In this example the display surface captured is to be the whole window. The audio track should ideally have noise suppression and echo cancellation features enabled, as well as an ideal audio sample rate of 44.1kHz, and suppression of local audio playback.

In addition, the app is hinting to the user agent that it should:

- Provide a control during screen sharing to allow the user to dynamically switch the shared tab.
- Hide the current tab from the list of options presented to the user when capture is requested.
- Not include the system audio among the possible audio sources offered to the user.

Capturing audio is always optional, and even when web content requests a stream with both audio and video, the returned {{domxref("MediaStream")}} may still have only one video track, with no audio.

## Using the captured stream

The {{jsxref("promise")}} returned by {{domxref("MediaDevices.getDisplayMedia", "getDisplayMedia()")}} resolves to a {{domxref("MediaStream")}} that contains at least one video stream that contains the screen or screen area, and which is adjusted or filtered based upon the constraints specified when `getDisplayMedia()` was called.

### Potential risks

Privacy and security issues surrounding screen sharing are usually not overly serious, but they do exist. The largest potential issue is users inadvertently sharing content they did not wish to share.

For example, privacy and/or security violations can easily occur if the user is sharing their screen and a visible background window happens to contain personal information, or if their password manager is visible in the shared stream. This effect can be amplified when capturing logical display surfaces, which may contain content that the user doesn't know about at all, let alone see.

User agents which take privacy seriously should obfuscate content that is not actually visible onscreen, unless authorization has been given to share that content specifically.

### Authorizing capture of display contents

Before streaming of captured screen contents can begin, the {{Glossary("user agent")}} will ask the user to confirm the sharing request, and to select the content to share.

## Examples

### Streaming screen capture

In this example, the contents of the captured screen area are streamed into a {{HTMLElement("video")}} element on the same page.

#### JavaScript

There isn't all that much code needed in order to make this work, and if you're familiar with using {{domxref("MediaDevices.getUserMedia", "getUserMedia()")}} to capture video from a camera, you'll find {{domxref("MediaDevices.getDisplayMedia", "getDisplayMedia()")}} to be very familiar.

##### Setup

First, some constants are set up to reference the elements on the page to which we'll need access: the {{HTMLElement("video")}} into which the captured screen contents will be streamed, a box into which logged output will be drawn, and the start and stop buttons that will turn on and off capture of screen imagery.

The object `displayMediaOptions` contains the options to pass into `getDisplayMedia()`; here, the {{domxref("MediaTrackConstraints.displaySurface", "displaySurface")}} property is set to `window`, indicating that the whole window should be captured.

Finally, event listeners are established to detect user clicks on the start and stop buttons.

```js
const videoElem = document.getElementById("video");
const logElem = document.getElementById("log");
const startElem = document.getElementById("start");
const stopElem = document.getElementById("stop");

// Options for getDisplayMedia()

const displayMediaOptions = {
  video: {
    displaySurface: "window",
  },
  audio: false,
};

// Set event listeners for the start and stop buttons
startElem.addEventListener("click", (evt) => {
  startCapture();
});

stopElem.addEventListener("click", (evt) => {
  stopCapture();
});
```

##### Logging content

This example overrides certain {{domxref("console")}} methods to output their messages to the {{HTMLElement("pre")}} block whose ID is `log`.

```js
console.log = (msg) => (logElem.textContent = `${logElem.textContent}\n${msg}`);
console.error = (msg) =>
  (logElem.textContent = `${logElem.textContent}\nError: ${msg}`);
```

This allows us to use {{domxref("console/log_static", "console.log()")}} and {{domxref("console.error_static", "console.error()")}} to log information to the log box in the document.

##### Starting display capture

The `startCapture()` method, below, starts the capture of a {{domxref("MediaStream")}} whose contents are taken from a user-selected area of the screen. `startCapture()` is called when the "Start Capture" button is clicked.

```js
async function startCapture() {
  logElem.textContent = "";

  try {
    videoElem.srcObject =
      await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);
    dumpOptionsInfo();
  } catch (err) {
    console.error(err);
  }
}
```

After clearing the contents of the log in order to get rid of any leftover text from the previous attempt to connect, `startCapture()` calls {{domxref("MediaDevices.getDisplayMedia", "getDisplayMedia()")}}, passing into it the constraints object defined by `displayMediaOptions`. Using {{jsxref("Operators/await", "await")}}, the following line of code does not get executed until after the {{jsxref("promise")}} returned by `getDisplayMedia()` resolves. Upon resolution, the promise returns a {{domxref("MediaStream")}}, which will stream the contents of the screen, window, or other region selected by the user.

The stream is connected to the {{HTMLElement("video")}} element by storing the returned `MediaStream` into the element's {{domxref("HTMLMediaElement.srcObject", "srcObject")}}.

The `dumpOptionsInfo()` function—which we will look at in a moment—dumps information about the stream to the log box for educational purposes.

If any of that fails, the [`catch()`](/en-US/docs/Web/JavaScript/Reference/Statements/try...catch) clause outputs an error message to the log box.

##### Stopping display capture

The `stopCapture()` method is called when the "Stop Capture" button is clicked. It stops the stream by getting its track list using {{domxref("MediaStream.getTracks()")}}, then calling each track's {{domxref("MediaStreamTrack.stop", "stop()")}} method. Once that's done, `srcObject` is set to `null` to make sure it's understood by anyone interested that there's no stream connected.

```js
function stopCapture(evt) {
  let tracks = videoElem.srcObject.getTracks();

  tracks.forEach((track) => track.stop());
  videoElem.srcObject = null;
}
```

##### Dumping configuration information

For informational purposes, the `startCapture()` method shown above calls a method named `dumpOptions()`, which outputs the current track settings as well as the constraints that were placed upon the stream when it was created.

```js
function dumpOptionsInfo() {
  const videoTrack = videoElem.srcObject.getVideoTracks()[0];

  console.log("Track settings:");
  console.log(JSON.stringify(videoTrack.getSettings(), null, 2));
  console.log("Track constraints:");
  console.log(JSON.stringify(videoTrack.getConstraints(), null, 2));
}
```

The track list is obtained by calling {{domxref("MediaStream.getVideoTracks", "getVideoTracks()")}} on the captured screen's {{domxref("MediaStream")}}. The settings currently in effect are obtained using {{domxref("MediaStreamTrack.getSettings", "getSettings()")}} and the established constraints are gotten with {{domxref("MediaStreamTrack.getConstraints", "getConstraints()")}}

#### HTML

The HTML starts with an introductory paragraph, then gets into the meat of things.

```html
<p>
  This example shows you the contents of the selected part of your display.
  Click the Start Capture button to begin.
</p>

<p>
  <button id="start">Start Capture</button>&nbsp;<button id="stop">
    Stop Capture
  </button>
</p>

<video id="video" autoplay></video>
<br />

<strong>Log:</strong>
<br />
<pre id="log"></pre>
```

The key parts of the HTML are:

1. A {{HTMLElement("button")}} labeled "Start Capture" which, when clicked, calls the `startCapture()` function to request access to, and begin capturing, screen contents.
2. A second button, "Stop Capture", which upon being clicked calls `stopCapture()` to terminate capture of screen contents.
3. A {{HTMLElement("video")}} into which the captured screen contents are streamed.
4. A {{HTMLElement("pre")}} block into which logged text is placed by the intercepted {{domxref("console")}} method.

#### CSS

The CSS is entirely cosmetic in this example. The video is given a border, and its width is set to occupy nearly the entire available horizontal space (`width: 98%`). {{cssxref("max-width")}} is set to `860px` to set an absolute upper limit on the video's size,

```css
#video {
  border: 1px solid #999999;
  width: 98%;
  max-width: 860px;
}

#log {
  width: 25rem;
  height: 15rem;
  border: 1px solid black;
  padding: 0.5rem;
  overflow: scroll;
}
```

#### Result

The final product looks like this. If your browser supports Screen Capture API, clicking "Start Capture" will present the {{Glossary("user agent", "user agent's")}} interface for selecting a screen, window, or tab to share.

{{EmbedLiveSample("Streaming screen capture", 640, 800, "", "", "", "display-capture")}}

## Security

In order to function when [Permissions Policy](/en-US/docs/Web/HTTP/Guides/Permissions_Policy) is enabled, you will need the `display-capture` permission. This can be done using the {{HTTPHeader("Permissions-Policy")}} {{Glossary("HTTP")}} header or—if you're using the Screen Capture API in an {{HTMLElement("iframe")}}, the `<iframe>` element's [`allow`](/en-US/docs/Web/HTML/Reference/Elements/iframe#allow) attribute.

For example, this line in the HTTP headers will enable Screen Capture API for the document and any embedded {{HTMLElement("iframe")}} elements that are loaded from the same origin:

```http
Permissions-Policy: display-capture=(self)
```

If you're performing screen capture within an `<iframe>`, you can request permission just for that frame, which is clearly more secure than requesting permission more generally:

```html
<iframe src="https://mycode.example.net/etc" allow="display-capture"> </iframe>
```

## Browser compatibility

{{Compat}}

## See also

- [Screen Capture API](/en-US/docs/Web/API/Screen_Capture_API)
- [Media Capture and Streams API](/en-US/docs/Web/API/Media_Capture_and_Streams_API)
- [Taking still photos with WebRTC](/en-US/docs/Web/API/Media_Capture_and_Streams_API/Taking_still_photos)
- {{domxref("HTMLCanvasElement.captureStream()")}} to obtain a {{domxref("MediaStream")}} with the live contents of a {{HTMLElement("canvas")}}
# Screen: change event

{{APIRef("Window Management API")}}{{SeeCompatTable}}{{securecontext_header}}

The **`change`** event of the {{domxref("Screen")}} interface is fired on a specific screen when one or more of the following properties change on it:

- {{domxref("Screen.width", "width")}}
- {{domxref("Screen.height", "height")}}
- {{domxref("Screen.availWidth", "availWidth")}}
- {{domxref("Screen.availHeight", "availHeight")}}
- {{domxref("Screen.colorDepth", "colorDepth")}}
- {{domxref("Screen.orientation", "orientation")}}

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("change", (event) => { })

onchange = (event) => { }
```

## Event type

A generic {{domxref("Event")}}.

## Examples

```js
const firstScreen = (await window.getScreenDetails()).screens[0];
firstScreen.addEventListener("change", (event) => {
  console.log("The first screen has changed.", event, firstScreen);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Window Management API](/en-US/docs/Web/API/Window_Management_API)
# Screen: colorDepth property

{{APIRef("CSSOM view API")}}

The **`Screen.colorDepth`** read-only property returns the
color depth of the screen. Per the CSSOM, some implementations return `24`
for compatibility reasons. See the browser compatibility section for those that don't.

## Value

A number.

## Examples

```js
// Check the color depth of the screen
if (window.screen.colorDepth < 8) {
  // Use low-color version of page
} else {
  // Use regular, colorful page
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{DOMxRef("Screen.pixelDepth")}}
# Screen: height property

{{APIRef("CSSOM view API")}}

The **`Screen.height`** read-only property returns the height
of the screen in CSS pixels.

## Value

A number.

## Examples

```js
if (window.screen.availHeight !== window.screen.height) {
  // Something is occupying some screen real estate!
}
```

## Notes

Note that not all of the height given by this property may be available to the window
itself. Widgets such as taskbars or other special application windows that integrate
with the OS (e.g., the Spinner player minimized to act like an additional toolbar on
windows) may reduce the amount of space available to browser windows and other
applications, there is a difference in `window.screen.height` and
`window.screen.availHeight`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Screen

{{APIRef("CSSOM view API")}}

The `Screen` interface represents a screen, usually the one on which the current window is being rendered, and is obtained using {{DOMxRef("window.screen")}}.

Note that browsers determine which screen to report as current by detecting which screen has the center of the browser window.

{{InheritanceDiagram}}

## Instance properties

_Also inherits properties from its parent {{domxref("EventTarget")}}_.

- {{DOMxRef("Screen.availHeight")}}
  - : Specifies the height of the screen, in pixels, minus permanent or semipermanent user interface features displayed by the operating system, such as the Taskbar on Windows.
- {{DOMxRef("Screen.availWidth")}}
  - : Returns the amount of horizontal space in pixels available to the window.
- {{DOMxRef("Screen.colorDepth")}}
  - : Returns the color depth of the screen.
- {{DOMxRef("Screen.height")}}
  - : Returns the height of the screen in pixels.
- {{domxref("Screen.isExtended")}} {{experimental_inline}} {{securecontext_inline}}
  - : Returns `true` if the user's device has multiple screens, and `false` if not.
- {{DOMxRef("Screen.orientation")}}
  - : Returns the {{DOMxRef("ScreenOrientation")}} instance associated with this screen.
- {{DOMxRef("Screen.pixelDepth")}}
  - : Gets the bit depth of the screen.
- {{DOMxRef("Screen.width")}}
  - : Returns the width of the screen.
- {{DOMxRef("Screen.mozEnabled")}} {{Non-standard_Inline}} {{Deprecated_Inline}}
  - : Boolean. Setting to false will turn off the device's screen.
- {{DOMxRef("Screen.mozBrightness")}} {{Non-standard_Inline}} {{Deprecated_Inline}}
  - : Controls the brightness of a device's screen. A double between 0 and 1.0 is expected.

## Non-standard properties

The following properties are specified as part of the [Window Management API](/en-US/docs/Web/API/Window_Management_API), which makes them available on the {{domxref("ScreenDetailed")}} interface; this is where we have chosen to document them. However, non-standard versions of these properties are available on the `Screen` interface in browsers that don't support that API. See this page's [Browser compatibility](#browser_compatibility) table for details of the non-standard support.

- {{domxref("ScreenDetailed.availLeft", "Screen.availLeft")}} {{ReadOnlyInline}} {{Non-standard_Inline}} {{SecureContext_Inline}}
  - : A number representing the x-coordinate (left-hand edge) of the available screen area.
- {{domxref("ScreenDetailed.availTop", "Screen.availTop")}} {{ReadOnlyInline}} {{Non-standard_Inline}} {{SecureContext_Inline}}
  - : A number representing the y-coordinate (top edge) of the available screen area.
- {{domxref("ScreenDetailed.left", "Screen.left")}} {{ReadOnlyInline}} {{Non-standard_Inline}} {{SecureContext_Inline}}
  - : A number representing the x-coordinate (left-hand edge) of the total screen area.
- {{domxref("ScreenDetailed.top", "Screen.top")}} {{ReadOnlyInline}} {{Non-standard_Inline}} {{deprecated_inline}} {{SecureContext_Inline}}
  - : A number representing the y-coordinate (top edge) of the total screen area.

## Instance methods

_Also inherits methods from its parent {{domxref("EventTarget")}}_.

- {{DOMxRef("Screen.lockOrientation")}} {{Deprecated_Inline}}
  - : Lock the screen orientation (only works in fullscreen or for installed apps)
- {{DOMxRef("Screen.unlockOrientation")}} {{Deprecated_Inline}}
  - : Unlock the screen orientation (only works in fullscreen or for installed apps)

## Events

- {{domxref("Screen.change_event", "change")}} {{experimental_inline}} {{securecontext_inline}}
  - : Fired on a specific screen when it changes in some way — width or height, available width or height, color depth, or orientation.
- {{DOMxRef("Screen.orientationchange_event", "orientationchange")}} {{Deprecated_Inline}} {{Non-standard_Inline}}
  - : Fires when the screen orientation changes.

## Examples

```js
if (screen.colorDepth < 8) {
  // use low-color version of page
} else {
  // use regular, colorful page
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Screen: isExtended property

{{APIRef("Window Management API")}}{{SeeCompatTable}}{{securecontext_header}}

The **`isExtended`** read-only property of the
{{domxref("Screen")}} interface returns `true` if the user's device has multiple screens, and `false` if not.

This property is typically accessed via `window.screen.isExtended`, and can be used to test whether multiple screens are available before attempting to create a multi-window, multi-screen layout using the [Window Management API](/en-US/docs/Web/API/Window_Management_API).

## Value

A boolean value — `true` if the device has multiple screens, and `false` if not.

> [!NOTE]
> If a {{httpheader("Permissions-Policy/window-management", "window-management")}} [Permissions-Policy](/en-US/docs/Web/HTTP/Guides/Permissions_Policy) is set that blocks use the Window Management API, `isExtended` will always return `false`.

## Examples

```js
if (window.screen.isExtended) {
  // Create multi-screen window layout
} else {
  // Create single-screen window layout
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Window Management API](/en-US/docs/Web/API/Window_Management_API)
# Screen: lockOrientation() method

{{APIRef("Screen Orientation API")}}{{Deprecated_Header}}

The **`lockOrientation()`** method of the {{DOMxRef("Screen")}}
interface locks the screen into a specified orientation.

> [!WARNING]
> This feature is deprecated and should be avoided. Use the {{DOMxRef("ScreenOrientation.lock()")}} method instead.

> [!NOTE]
> This method only works for installed Web apps or for Web pages
> in [fullscreen mode](/en-US/docs/Web/API/Fullscreen_API).

## Syntax

```js-nolint
lockOrientation(orientation)
```

### Parameters

- `orientation`
  - : The orientation into which to lock the screen. This is either a string or an array
    of strings. Passing several strings lets the screen rotate only in the selected
    orientations.

    The following strings represent the possible orientation requirements you may specify:
    - `portrait-primary`
      - : It represents the orientation of the screen when it is in its primary portrait mode.
        A screen is considered in its primary portrait mode if the device is held in its
        normal position and that position is in portrait, or if the normal position of the
        device is in landscape and the device held turned by 90° clockwise. The normal
        position is device dependent.

    - `portrait-secondary`
      - : It represents the orientation of the screen when it is in its secondary portrait
        mode. A screen is considered in its secondary portrait mode if the device is held 180°
        from its normal position and that position is in portrait, or if the normal position
        of the device is in landscape and the device held is turned by 90° counterclockwise. The
        normal position is device dependent.
    - `landscape-primary`
      - : It represents the orientation of the screen when it is in its primary landscape
        mode. A screen is considered in its primary landscape mode if the device is held in
        its normal position and that position is in landscape, or if the normal position of
        the device is in portrait and the device held is turned by 90° clockwise. The normal
        position is device dependent.
    - `landscape-secondary`
      - : It represents the orientation of the screen when it is in its secondary landscape
        mode. A screen is considered in its secondary landscape mode if the device held is
        180° from its normal position and that position is in landscape, or if the normal
        position of the device is in portrait and the device held is turned by 90°
        counterclockwise. The normal position is device dependent.
    - `portrait`
      - : It represents both `portrait-primary` and
        `portrait-secondary`.
    - `landscape`
      - : It represents both `landscape-primary` and
        `landscape-secondary`.
    - `default`
      - : It represents either `portrait-primary` and
        `landscape-primary` depends on natural orientation of devices. For example,
        if the panel resolution is 1280\*800, `default` will make it landscape, if
        the resolution is 800\*1280, `default` will make it to portrait.

> [!NOTE]
> It's possible to set several locks at the same time. So, if
> the lock is set for only one orientation, the screen orientation will never change
> until the screen orientation is unlocked. Otherwise, the screen orientation will
> change from an orientation to another as long as the orientations are amongst the
> orientations the device has been locked to.

### Return value

Returns `true` if the orientation was authorized to be locked or
`false` if the orientation locking was denied. Note that the return value
doesn't indicate that the screen orientation is indeed locked: there may be a delay.

## Examples

### Usage with a string argument

```js
screen.lockOrientationUniversal =
  screen.lockOrientation ||
  screen.mozLockOrientation ||
  screen.msLockOrientation;

if (screen.lockOrientationUniversal("landscape-primary")) {
  // Orientation was locked
} else {
  // Orientation lock failed
}
```

### Usage with an `Array` argument

```js
screen.lockOrientationUniversal =
  screen.lockOrientation ||
  screen.mozLockOrientation ||
  screen.msLockOrientation;

if (
  screen.lockOrientationUniversal(["landscape-primary", "landscape-secondary"])
) {
  // Orientation was locked
} else {
  // Orientation lock failed
}
```

## Specifications

This feature is not part of any specification. It is no longer on track to becoming a standard.

Use {{domxref("ScreenOrientation.lock()")}} instead.

## Browser compatibility

{{Compat}}

## See also

- {{DOMxRef("Screen.orientation")}}
- {{DOMxRef("Screen.unlockOrientation()")}}
- {{DOMxRef("Screen.orientationchange_event", "orientationchange")}} event
- [Managing screen orientation](/en-US/docs/Web/API/CSS_Object_Model/Managing_screen_orientation)
# Screen: mozBrightness property

{{APIRef("CSSOM view API")}}{{Deprecated_Header}}{{Non-standard_Header}}

Indicates how bright the screen's backlight is, on a scale from 0 (very dim) to 1 (full
brightness); this value is a double-precision float.

You can read and write this attribute even when the screen is disabled, but the
backlight is off while the screen is disabled. If you write a value of X into this
attribute, the attribute may not have the same value X when you later read it. Most
screens don't support as many different brightness levels as there are doubles between 0
and 1. The value's precision might be reduced before storing it.

## Value

A number.

## Specifications

Not part of specification.

## Browser compatibility

{{Compat}}
# Screen: mozEnabled property

{{APIRef("CSSOM view API")}}{{Deprecated_Header}}{{Non-standard_Header}}

This Boolean attribute controls the device's screen. Setting it to `false`
will turn off the screen.

## Value

A boolean.

## Specifications

Not part of specification.

## Browser compatibility

{{Compat}}
# Screen Orientation API

{{DefaultAPISidebar("Screen Orientation API")}}

The **Screen Orientation API** provides information about the orientation of the screen.

## Interfaces

- {{DOMxRef("ScreenOrientation")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Screen: orientation property

{{APIRef("Screen Orientation API")}}

The **`orientation`** read-only property of the
{{DOMxRef("Screen")}} interface returns the current orientation of the screen.

## Value

An instance of {{DOMxRef("ScreenOrientation")}} representing the orientation of the
screen.

Note that older, prefixed versions returned a string equivalent to
{{DOMxRef("ScreenOrientation.type")}}.

## Examples

```js
switch (screen.orientation.type) {
  case "landscape-primary":
    console.log("That looks good.");
    break;
  case "landscape-secondary":
    console.log("Mmm… the screen is upside down!");
    break;
  case "portrait-secondary":
  case "portrait-primary":
    console.log("Mmm… you should rotate your device to landscape");
    break;
  default:
    console.log("The orientation API isn't supported in this browser :(");
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{DOMxRef("ScreenOrientation")}}
- {{DOMxRef("Screen.orientationchange_event", "orientationchange")}} event
- [Managing screen orientation](/en-US/docs/Web/API/CSS_Object_Model/Managing_screen_orientation)
# Screen: orientationchange event

{{APIRef("Screen Orientation API")}}{{Deprecated_Header}}{{Non-standard_Header}}

The `orientationchange` event fires when the device's orientation has changed.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("orientationchange", (event) => { })

onorientationchange = (event) => { }
```

## Event type

A generic {{domxref("Event")}}.

## Specifications

This feature is not part of any specification. It is no longer on track to becoming a standard.

Use the `ScreenOrientation` {{domxref("ScreenOrientation.change_event", "change")}} event instead.

## Browser compatibility

{{Compat}}

## See also

- [Managing screen orientation](/en-US/docs/Web/API/CSS_Object_Model/Managing_screen_orientation)
# Screen: pixelDepth property

{{APIRef("CSSOM view API")}}

Returns the bit depth of the screen. Per the CSSOM, some implementations
return `24` for compatibility reasons. See the [browser compatibility](#browser_compatibility) section for those that don't.

## Value

A number.

## Examples

```js
// if there is not adequate bit depth
// choose a simpler color
document.style.color = window.screen.pixelDepth > 8 ? "#FAEBD7" : "white";
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{DOMxRef("Screen.colorDepth")}}
# Screen: unlockOrientation() method

{{APIRef("Screen Orientation API")}}{{Deprecated_Header}}

The **`Screen.unlockOrientation()`** method removes all the
previous screen locks set by the page/app. The {{DOMxRef("ScreenOrientation.unlock()")}}
method should be used instead.

> [!WARNING]
> This feature is deprecated and should be avoided. Use the {{DOMxRef("ScreenOrientation.unlock()")}} method instead.

> [!NOTE]
> This method only works for installed Web apps or for Web pages
> in [fullscreen mode](/en-US/docs/Web/API/Fullscreen_API).

## Syntax

```js-nolint
unlockOrientation()
```

### Parameters

None.

### Return value

Returns `true` if the orientation was successfully unlocked or
`false` if the orientation couldn't be unlocked.

## Examples

```js
const unlockOrientation =
  screen.unlockOrientation ||
  screen.mozUnlockOrientation ||
  screen.msUnlockOrientation ||
  (screen.orientation && screen.orientation.unlock);

if (unlockOrientation()) {
  // orientation was unlocked
} else {
  // orientation unlock failed
}
```

## Specifications

This feature is not part of any specification. It is no longer on track to becoming a standard.

Use {{domxref("ScreenOrientation.unlock()")}} instead.

## Browser compatibility

{{Compat}}

## See also

- {{DOMxRef("Screen.orientation")}}
- {{DOMxRef("Screen.lockOrientation()")}}
- {{DOMxRef("Screen.orientationchange_event", "orientationchange")}} event
- [Managing screen orientation](/en-US/docs/Web/API/CSS_Object_Model/Managing_screen_orientation)
# Screen Wake Lock API

{{DefaultAPISidebar("Screen Wake Lock API")}}{{securecontext_header}}

The **Screen Wake Lock API** provides a way to prevent devices from dimming or locking the screen when an application needs to keep running.

## Concepts and usage

Most devices by default turn off their screen after a specified amount of time to prolong the life of the hardware. Modern devices do this to save on battery power. Whilst this is a useful feature, some applications need the screen to stay awake to be their most useful.

The Screen Wake Lock API prevents the screen from turning off, dimming or locking. It allows for a simple platform-based solution for visible (active) documents to acquire the platform screen wake lock.

There are plenty of use cases for keeping a screen on, including reading an ebook, map navigation, following a recipe, presenting to an audience, scanning a QR/barcode or applications that use voice or gesture control, rather than tactile input (the default way to keep a screen awake).

You acquire a {{DOMxRef("WakeLockSentinel")}} object by calling the {{domxref('WakeLock.request','navigator.wakeLock.request()')}} {{jsxref('Promise')}}-based method that resolves if the platform allows it. A request may be rejected for a number of reasons, including system settings (such as power save mode or low battery level) or if the document is not active or visible.
It is good practice to store a reference to the sentinel object to allow the application to later control release.

The sentinel is attached to the underlying system wake lock. It can be released by the system, again if the battery power is too low or the document is not active or visible. It can also be released manually via the {{domxref('WakeLockSentinel.release()')}} method.
After being released a `WakeLockSentinel` can no longer be used. If a screen wake lock is required again/still, the application will need to request a new one.

The Screen Wake Lock API should be used to keep the screen on to benefit usability. It's a good idea to show some feedback on the interface to show if wake lock is active and a way for the user to disable it if they wish.

## Interfaces

- {{domxref("WakeLock")}}
  - : Prevents device screens from dimming or locking when an application needs to keep running.
- {{domxref("WakeLockSentinel")}}
  - : Provides a handle to the underlying platform wake lock and if referenced can be manually released and reacquired. Get an instance of the object by calling {{domxref('WakeLock.request')}}.

### Extensions to other interfaces

- {{domxref("Navigator.wakeLock")}} {{ReadOnlyInline}}
  - : Returns a {{domxref("WakeLock")}} object instance, from which all other functionality can be accessed.

- [`Permissions-Policy: screen-wake-lock`](/en-US/docs/Web/HTTP/Reference/Headers/Permissions-Policy/screen-wake-lock)
  - : Access to the API is gated by the [`Permissions-Policy`](/en-US/docs/Web/HTTP/Reference/Headers/Permissions-Policy) directive `screen-wake-lock`.
    See [Security considerations](#security_considerations) below.

## Examples

### Feature detection

This code checks for wake lock support and updates the UI accordingly.

```js
if ("wakeLock" in navigator) {
  isSupported = true;
  statusElem.textContent = "Screen Wake Lock API supported!";
} else {
  wakeButton.disabled = true;
  statusElem.textContent = "Wake lock is not supported by this browser.";
}
```

### Requesting a wake lock

The following example demonstrates how to request a {{domxref('WakeLockSentinel')}} object. The {{domxref('WakeLock.request')}} method is {{jsxref('Promise')}}-based and so we can create an asynchronous function, which in turn updates the UI to reflect the wake lock is active.

```js
// Create a reference for the Wake Lock.
let wakeLock = null;

// create an async function to request a wake lock
try {
  wakeLock = await navigator.wakeLock.request("screen");
  statusElem.textContent = "Wake Lock is active!";
} catch (err) {
  // The Wake Lock request has failed - usually system related, such as battery.
  statusElem.textContent = `${err.name}, ${err.message}`;
}
```

### Releasing wake lock

The following example shows how to release the previously acquired wake lock.

```js
wakeLock.release().then(() => {
  wakeLock = null;
});
```

### Listening for wake lock release

This example updates the UI if the wake lock has been released for any reason (such as navigating away from the active window/tab).

```js
wakeLock.addEventListener("release", () => {
  // the wake lock has been released
  statusElem.textContent = "Wake Lock has been released";
});
```

### Reacquiring a wake lock

The following code reacquires the wake lock should the visibility of the document change and the wake lock is released.

```js
document.addEventListener("visibilitychange", async () => {
  if (wakeLock !== null && document.visibilityState === "visible") {
    wakeLock = await navigator.wakeLock.request("screen");
  }
});
```

### Putting it all together

You can find the [complete code on GitHub here](https://github.com/mdn/dom-examples/tree/main/screen-wake-lock-api). The [demo](https://mdn.github.io/dom-examples/screen-wake-lock-api/) uses a button to acquire a wake lock and also release it, which in turn updates the UI. The UI also updates if the wake lock is released automatically for any reason. There's a checkbox which when checked, will automatically reacquire the wake lock if the document's visibility state changes and becomes visible again.

## Performance considerations

- Release the screen wake lock when user ends activity that required always-on screen. For example, a ticketing app which uses QR codes to transmit ticket information, might acquire screen wake lock when the QR code is displayed (so that code is successfully scanned) but release afterwards. A presentation app might hold the lock only while a presentation is active, but not when presentation is being edited.
- If your app is performing long-running downloads, consider using background fetch.
- If your app is synchronizing data from a remote server, consider using background sync.
- Only active documents can acquire screen wake locks and previously acquired locks are automatically released when document becomes inactive. Therefore make sure to re-acquire screen wake lock if necessary when document becomes active (listen for [visibilitychange](/en-US/docs/Web/API/Document/visibilitychange_event) event).

## Security considerations

Access to the Screen Wake Lock API is controlled by the [Permissions Policy](/en-US/docs/Web/HTTP/Guides/Permissions_Policy) directive {{HTTPHeader("Permissions-Policy/screen-wake-lock","screen-wake-lock")}}.

When using the [Permissions Policy](/en-US/docs/Web/HTTP/Guides/Permissions_Policy), the default allowlist for `screen-wake-lock` is `self`.
This allows lock wake usage in same-origin nested frames but prevents third-party content from using locks.
Third party usage can be enabled by the server first setting the `Permissions-Policy` header to grant permission a particular third party origin.

```http
Permissions-Policy: screen-wake-lock=(self b.example.com)
```

Then the `allow="screen-wake-lock"` attribute must be added the frame container element for sources from that origin:

```html
<iframe src="https://b.example.com" allow="screen-wake-lock"></iframe>
```

Browsers may also block the screen lock in a particular document for an implementation specific reason, such as a user or platform setting.
They are expected to provide some unobtrusive mechanism to inform the user when wake lock is active, and to provide users the ability to remove the application's screen lock.

The [Permissions API](/en-US/docs/Web/API/Permissions_API) `screen-wake-lock` permission can be used to test whether access to use the screen lock is `granted`, `denied` or `prompt` (requires user acknowledgement of a prompt).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Stay awake with the Screen Wake Lock API](https://developer.chrome.com/docs/capabilities/web-apis/wake-lock/) on developer.chrome.com
# Screen: width property

{{APIRef("CSSOM view API")}}

The **`Screen.width`** read-only property returns the width of
the screen in CSS pixels.

## Value

A number.

## Examples

```js
// Crude way to check that the screen is at least 1024x768
if (window.screen.width >= 1024 && window.screen.height >= 768) {
  // Resolution is 1024x768 or above
}
```

## Notes

Note that not all of the width given by this property may be available to the window
itself. When other widgets occupy space that cannot be used by the `window`
object, there is a difference in `window.screen.width` and
`window.screen.availWidth`. See also {{DOMxRef("screen.height")}}.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ScreenDetailed: availLeft property

{{APIRef("Window Management API")}}{{seecompattable}}{{SecureContext_Header}}

The **`availLeft`** read-only property of the
{{domxref("ScreenDetailed")}} interface is a number representing the x-coordinate (left-hand edge) of the available screen area inside the OS virtual screen arrangement, relative to the [multi-screen origin](/en-US/docs/Web/API/Window_Management_API/Multi-screen_origin).

This is equal to the {{domxref("ScreenDetailed.left")}} property, plus the width of any OS UI element drawn on the left of the screen. Windows cannot be placed in those areas, so `availLeft` is useful for giving you the left boundary of the actual area available to open or place windows.

> [!NOTE]
> A non-standard implementation of the `availLeft` property is available on the `Screen` interface in all browsers. See the [Non-standard example](#non-standard_example) below for usage details, and see the [`Screen`](/en-US/docs/Web/API/Screen#browser_compatibility) reference page for browser support information relating to the non-standard implementation.

## Value

A number.

## Examples

### Window Management API example

```js
// Available in browsers that support the Window Management API
const screenDetails = await window.getScreenDetails();

// Return the availLeft value of the first screen
const screen1AvailLeft = screenDetails.screens[0].availLeft;
```

### Non-standard example

```js
// Available in all browsers
// Return the availLeft value of the current screen
const screenAvailLeft = window.screen.availLeft;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Window Management API](/en-US/docs/Web/API/Window_Management_API)
# ScreenDetailed: availTop property

{{APIRef("Window Management API")}}{{seecompattable}}{{SecureContext_Header}}

The **`availTop`** read-only property of the
{{domxref("ScreenDetailed")}} interface is a number representing the y-coordinate (top edge) of the available screen area inside the OS virtual screen arrangement, relative to the [multi-screen origin](/en-US/docs/Web/API/Window_Management_API/Multi-screen_origin).

This is equal to the {{domxref("ScreenDetailed.top")}} property, plus the height of any OS UI element drawn at the top of the screen. Windows cannot be placed in those areas, so `availTop` is useful for giving you the top boundary of the actual area available to open or place windows.

> [!NOTE]
> A non-standard implementation of the `availTop` property is available on the `Screen` interface in all browsers. See the [Non-standard example](#non-standard_example) below for usage details, and see the [`Screen`](/en-US/docs/Web/API/Screen#browser_compatibility) reference page for browser support information relating to the non-standard implementation.

## Value

A number.

## Examples

### Window Management API example

```js
// Available in browsers that support the Window Management API
const screenDetails = await window.getScreenDetails();

// Return the availTop value of the first screen
const screen1AvailTop = screenDetails.screens[0].availTop;
```

### Non-standard example

```js
// Available in all browsers
// Return the availTop value of the current screen
const screenAvailTop = window.screen.availTop;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Window Management API](/en-US/docs/Web/API/Window_Management_API)
# ScreenDetailed: devicePixelRatio property

{{APIRef("Window Management API")}}{{SeeCompatTable}}{{SecureContext_Header}}

The **`devicePixelRatio`** read-only property of the
{{domxref("ScreenDetailed")}} interface is a number representing the screen's {{glossary("device pixel")}} ratio.

This is the same as the value returned by {{domxref("Window.devicePixelRatio")}}, except that `Window.devicePixelRatio`:

- always returns the device pixel ratio for the {{domxref("ScreenDetails.currentScreen", "current screen", "", "nocode")}}.
- also includes scaling of the window itself, i.e., page zoom (at least on some browser implementations).

## Value

A number.

## Examples

```js
const screenDetails = await window.getScreenDetails();

// Return the device pixel ratio of the first screen
const screen1DPR = screenDetails.screens[0].devicePixelRatio;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Window Management API](/en-US/docs/Web/API/Window_Management_API)
# ScreenDetailed

{{APIRef("Window Management API")}}{{SeeCompatTable}}{{securecontext_header}}

The **`ScreenDetailed`** interface of the [Window Management API](/en-US/docs/Web/API/Window_Management_API) represents detailed information about one specific screen available to the user's device.

`ScreenDetailed` objects can be accessed via the {{domxref("ScreenDetails.screens")}} and {{domxref("ScreenDetails.currentScreen")}} properties.

{{InheritanceDiagram}}

## Instance properties

_Inherits properties from its parent, {{DOMxRef("Screen")}}._

- {{domxref("ScreenDetailed.availLeft", "availLeft")}} {{ReadOnlyInline}} {{Experimental_Inline}}
  - : A number representing the x-coordinate (left-hand edge) of the available screen area.
- {{domxref("ScreenDetailed.availTop", "availTop")}} {{ReadOnlyInline}} {{Experimental_Inline}}
  - : A number representing the y-coordinate (top edge) of the available screen area.
- {{domxref("ScreenDetailed.devicePixelRatio", "devicePixelRatio")}} {{ReadOnlyInline}} {{Experimental_Inline}}
  - : A number representing the screen's device pixel ratio.
- {{domxref("ScreenDetailed.isInternal", "isInternal")}} {{ReadOnlyInline}} {{Experimental_Inline}}
  - : A boolean indicating whether the screen is internal to the device or external.
- {{domxref("ScreenDetailed.isPrimary", "isPrimary")}} {{ReadOnlyInline}} {{Experimental_Inline}}
  - : A boolean indicating whether the screen is set as the operating system (OS) primary screen or not.
- {{domxref("ScreenDetailed.label", "label")}} {{ReadOnlyInline}} {{Experimental_Inline}}
  - : A string providing a descriptive label for the screen, for example "Built-in Retina Display".
- {{domxref("ScreenDetailed.left", "left")}} {{ReadOnlyInline}} {{Experimental_Inline}}
  - : A number representing the x-coordinate (left-hand edge) of the total screen area.
- {{domxref("ScreenDetailed.top", "top")}} {{ReadOnlyInline}} {{Experimental_Inline}}
  - : A number representing the y-coordinate (top edge) of the total screen area.

## Events

_Inherits events from its parent, {{DOMxRef("Screen")}}._

- `change` {{experimental_inline}}
  - : Fired on a specific screen when any property of the screen changes — width or height, available width or available height, color depth, or orientation, screen position and available screen position, device pixel ratio, label or screen's designation.

## Examples

When {{domxref("Window.getScreenDetails()")}} is invoked, the user will be asked for permission to manage windows on all their displays (the status of this permission can be checked using {{domxref("Permissions.query()")}} to query `window-management`). Provided they grant permission, the resulting {{domxref("ScreenDetails")}} object contains `ScreenDetailed` objects representing all the screens available to the user's system.

The following example opens a window in the top-left corner of the OS primary screen:

```js
// Return ScreenDetails
const allScreens = await window.getScreenDetails();

// Return the primary screen ScreenDetailed object
const primaryScreenDetailed = allScreens.screens.find(
  (screenDetailed) => screenDetailed.isPrimary,
);

// Open a window in the top-left corner of the OS primary screen
window.open(
  "https://example.com",
  "_blank",
  `left=${primaryScreenDetailed.availLeft},
   top=${primaryScreenDetailed.availTop},
   width=200,
   height=200`,
);
```

> [!NOTE]
> See [Multi-window learning environment](https://mdn.github.io/dom-examples/window-management-api/) for a full example (see the [source code](https://github.com/mdn/dom-examples/tree/main/window-management-api) also).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Window Management API](/en-US/docs/Web/API/Window_Management_API)
# ScreenDetailed: isInternal property

{{APIRef("Window Management API")}}{{SeeCompatTable}}{{SecureContext_Header}}

The **`isInternal`** read-only property of the
{{domxref("ScreenDetailed")}} interface is a boolean indicating whether the screen is internal to the device or external. External devices are generally manufactured separately from the device they are attached to and can be connected and disconnected as needed, whereas internal screens are part of the device and not intended to be disconnected.

## Value

A boolean value — `true` if the screen is internal, and `false` if it is external.

## Examples

```js
const screenDetails = await window.getScreenDetails();

// Is the first screen internal?
const screen1Internal = screenDetails.screens[0].isInternal;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Window Management API](/en-US/docs/Web/API/Window_Management_API)
# ScreenDetailed: isPrimary property

{{APIRef("Window Management API")}}{{SeeCompatTable}}{{SecureContext_Header}}

The **`isPrimary`** read-only property of the
{{domxref("ScreenDetailed")}} interface is a boolean indicating whether the screen is set as the operating system (OS) primary screen or not.

The OS hosting the browser will have one primary screen, and one or more secondary screens. The primary screen can usually be specified by the user via OS settings, and generally contains OS UI features such as the taskbar/icon dock. The primary screen may change for a number of reasons, such as a screen being unplugged.

## Value

A boolean value — `true` if the screen is primary, and `false` if it is secondary.

## Examples

```js
const screenDetails = await window.getScreenDetails();

// Is the first screen primary?
const screen1Primary = screenDetails.screens[0].isPrimary;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Window Management API](/en-US/docs/Web/API/Window_Management_API)
# ScreenDetailed: label property

{{APIRef("Window Management API")}}{{SeeCompatTable}}{{SecureContext_Header}}

The **`label`** read-only property of the
{{domxref("ScreenDetailed")}} interface is a string providing a descriptive label for the screen, for example "Built-in Retina Display".

This is useful for constructing a list of options to display to the user if you want them to choose a screen to display content on.

## Value

A string.

## Examples

```js
const screenDetails = await window.getScreenDetails();

// Return the label of the first screen
const screen1Label = screenDetails.screens[0].label;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Window Management API](/en-US/docs/Web/API/Window_Management_API)
# ScreenDetailed: left property

{{APIRef("Window Management API")}}{{seecompattable}}{{SecureContext_Header}}

The **`left`** read-only property of the
{{domxref("ScreenDetailed")}} interface is a number representing the x-coordinate (left-hand edge) of the total screen area inside the OS virtual screen arrangement, relative to the [multi-screen origin](/en-US/docs/Web/API/Window_Management_API/Multi-screen_origin).

This is equal to the true left-hand edge, ignoring any OS UI element drawn at the left of the screen. Windows cannot be placed in those areas; to get the left-hand coordinate of the screen area that windows can be placed in, use {{domxref("ScreenDetailed.availLeft")}}.

> [!NOTE]
> In Firefox, a non-standard implementation of the `left` property is available on the `Screen` interface. See the [Non-standard example](#non-standard_example) below for usage details, and see the [`Screen`](/en-US/docs/Web/API/Screen#browser_compatibility) reference page for browser support information relating to the non-standard implementation.

## Value

A number.

## Examples

### Window Management API example

```js
// Available in browsers that support the Window Management API
const screenDetails = await window.getScreenDetails();

// Return the absolute left value of the first screen
const screen1Left = screenDetails.screens[0].left;
```

### Non-standard example

```js
// Available in Firefox
// Return the absolute left value of the current screen
const screenLeft = window.screen.left;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Window Management API](/en-US/docs/Web/API/Window_Management_API)
# ScreenDetailed: top property

{{APIRef("Window Management API")}}{{seecompattable}}{{SecureContext_Header}}

The **`top`** read-only property of the
{{domxref("ScreenDetailed")}} interface is a number representing the y-coordinate (top edge) of the total screen area inside the OS virtual screen arrangement, relative to the [multi-screen origin](/en-US/docs/Web/API/Window_Management_API/Multi-screen_origin).

This is equal to the true top edge, ignoring any OS UI element drawn at the top of the screen. Windows cannot be placed in those areas; to get the top coordinate of the screen area that windows can be placed in, use {{domxref("ScreenDetailed.availTop")}}.

> [!NOTE]
> In Firefox, a non-standard implementation of the `top` property is available on the `Screen` interface. See the [Non-standard example](#non-standard_example) below for usage details, and see the [`Screen`](/en-US/docs/Web/API/Screen#browser_compatibility) reference page for browser support information relating to the non-standard implementation.

## Value

A number.

## Examples

### Window Management API example

```js
// Available in browsers that support the Window Management API
const screenDetails = await window.getScreenDetails();

// Return the absolute top value of the first screen
const screen1Top = screenDetails.screens[0].top;
```

### Non-standard example

```js
// Available in Firefox
// Return the absolute top value of the current screen
const screenTop = window.screen.top;
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Window Management API](/en-US/docs/Web/API/Window_Management_API)
# ScreenDetails: currentScreen property

{{APIRef("Window Management API")}}{{SeeCompatTable}}{{SecureContext_Header}}

The **`currentScreen`** read-only property of the
{{domxref("ScreenDetails")}} interface contains a single {{domxref("ScreenDetailed")}} object representing detailed information about the screen that the current browser window is displayed in.

## Value

A {{domxref("ScreenDetailed")}} object.

## Examples

```js
// Utility function for opening new windows
function openWindow(left, top, width, height, url) {
  const windowFeatures = `left=${left},top=${top},width=${width},height=${height}`;
  return window.open(url, "_blank", windowFeatures);
}

// Open a new window that fills the available area of the current screen.
const currentScreen = (await window.getScreenDetails()).currentScreen;
console.log(`Opening a window to fill screen ${currentScreen.label}`);
const windowRef = openWindow(
  currentScreen.availLeft,
  currentScreen.availTop,
  currentScreen.availWidth,
  currentScreen.availHeight,
  url,
);
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Window Management API](/en-US/docs/Web/API/Window_Management_API)
# ScreenDetails: currentscreenchange event

{{APIRef("Window Management API")}}{{SeeCompatTable}}{{SecureContext_Header}}

The **`currentscreenchange`** event of the {{domxref("ScreenDetails")}} interface is fired when the {{domxref("ScreenDetails.currentScreen")}} changes in one of the following ways:

- The current screen changes to a different screen, i.e., the current browser window is moved to a different screen.
- One or more of the following properties change on the current screen:
  - {{domxref("Screen.width", "width")}}
  - {{domxref("Screen.height", "height")}}
  - {{domxref("Screen.availWidth", "availWidth")}}
  - {{domxref("Screen.availHeight", "availHeight")}}
  - {{domxref("Screen.colorDepth", "colorDepth")}}
  - {{domxref("Screen.orientation", "orientation")}}
- One or more of the following values change:
  - The screen's **position** ((x,y) coordinates of the top-left corner) inside the OS virtual screen arrangement, relative to the [multi-screen origin](/en-US/docs/Web/API/Window_Management_API/Multi-screen_origin)
  - The screen's **available position** ((x,y) coordinates of the top-left corner) inside the OS virtual screen arrangement, relative to the [multi-screen origin](/en-US/docs/Web/API/Window_Management_API/Multi-screen_origin). This is equal to the screen position, plus the width/height of any OS UI elements drawn on the top-left of the screen — windows cannot be placed in those areas
  - {{domxref("ScreenDetailed.devicePixelRatio", "devicePixelRatio")}}
  - {{domxref("ScreenDetailed.label", "label")}}
  - The screen's designation as primary or secondary (see {{domxref("ScreenDetailed.isPrimary", "isPrimary")}})
  - The screen's designation as internal or external (see {{domxref("ScreenDetailed.isInternal", "isInternal")}})

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("currentscreenchange", (event) => { })

oncurrentscreenchange = (event) => { }
```

## Event type

A generic {{domxref("Event")}}.

## Examples

```js
const screenDetails = await window.getScreenDetails();
screenDetails.addEventListener("currentscreenchange", (event) => {
  const details = screenDetails.currentScreen;
  console.log("The current screen has changed.", event, details);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Window Management API](/en-US/docs/Web/API/Window_Management_API)
# ScreenDetails

{{APIRef("Window Management API")}}{{SeeCompatTable}}{{securecontext_header}}

The **`ScreenDetails`** interface of the [Window Management API](/en-US/docs/Web/API/Window_Management_API) represents the details of all the screens available to the user's device.

This information is accessed via the {{domxref("Window.getScreenDetails()")}} method.

> [!NOTE]
> `ScreenDetails` is a live object, meaning that it updates as the available screens change. You can therefore keep querying the same object to get updated values, rather than repeatedly calling `getScreenDetails()`.

{{InheritanceDiagram}}

## Instance properties

_Inherits properties from its parent, {{DOMxRef("EventTarget")}}._

- {{domxref("ScreenDetails.currentScreen", "currentScreen")}} {{ReadOnlyInline}} {{Experimental_Inline}}
  - : A single {{domxref("ScreenDetailed")}} object representing detailed information about the screen that the current browser window is displayed in.

- {{domxref("ScreenDetails.screens", "screens")}} {{ReadOnlyInline}} {{Experimental_Inline}}
  - : An array of {{domxref("ScreenDetailed")}} objects, each one representing detailed information about one specific screen available to the user's device.

    > [!NOTE]
    > `screens` only includes "extended" displays, not those that mirror another display.

## Events

- {{domxref("ScreenDetails.currentscreenchange_event", "currentscreenchange")}} {{experimental_inline}}
  - : Fired when the window's current screen changes in some way — for example available width or height, or orientation.
- {{domxref("ScreenDetails.screenschange_event", "screenschange")}} {{experimental_inline}}
  - : Fired when screens are connected to or disconnected from the system.

## Examples

> [!NOTE]
> See [Multi-window learning environment](https://mdn.github.io/dom-examples/window-management-api/) for a full example (see the [source code](https://github.com/mdn/dom-examples/tree/main/window-management-api) also).

### Basic screen information access

When {{domxref("Window.getScreenDetails()")}} is invoked, the user will be asked for permission to manage windows on all their displays (the status of this permission can be checked using {{domxref("Permissions.query()")}} to query `window-management`). If the user grants permission, a `ScreenDetails` object is returned. This object contains details of all the screens available to the user's system.

The below example opens a full-size window on each available display.

```js
const screenDetails = await window.getScreenDetails();

// Open a window on each screen of the device
for (const screen of screenDetails.screens) {
  openWindow(
    screen.availLeft,
    screen.availTop,
    screen.availWidth,
    screen.availHeight,
    url,
  );
}
```

### Responding to changes in available screens

You could use the `screenschange` event to detect when the available screens have changed (perhaps when a screen is plugged in or unplugged), report the change, and update window arrangements to suit the new configuration:

```js
const screenDetails = await window.getScreenDetails();

// Return the number of screens
let noOfScreens = screenDetails.screens.length;

screenDetails.addEventListener("screenschange", () => {
  // If the new number of screens is different to the old number of screens,
  // report the difference
  if (screenDetails.screens.length !== noOfScreens) {
    console.log(
      `The screen count changed from ${noOfScreens} to ${screenDetails.screens.length}`,
    );

    // Update noOfScreens value
    noOfScreens = screenDetails.screens.length;
  }

  // Open, close, or rearrange windows as needed,
  // to fit the new screen configuration
  updateWindows();
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Window Management API](/en-US/docs/Web/API/Window_Management_API)
# ScreenDetails: screens property

{{APIRef("Window Management API")}}{{SeeCompatTable}}{{SecureContext_Header}}

The **`screens`** read-only property of the
{{domxref("ScreenDetails")}} interface contains an array of {{domxref("ScreenDetailed")}} objects, each one representing detailed information about one specific screen available to the user's device.

## Value

An array of {{domxref("ScreenDetailed")}} objects.

> [!NOTE]
> `screens` only includes "extended" displays, not those that mirror another display.

## Examples

See the main [`ScreenDetails`](/en-US/docs/Web/API/ScreenDetails#examples) page for example usage.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Window Management API](/en-US/docs/Web/API/Window_Management_API)
# ScreenDetails: screenschange event

{{APIRef("Window Management API")}}{{SeeCompatTable}}{{SecureContext_Header}}

The **`screenschange`** event of the {{domxref("ScreenDetails")}} interface is fired when the set of screens available to the system has changed: that is, a new screen has become available or an existing screen has become unavailable. This will be reflected in a change in the {{domxref("ScreenDetails.screens", "screens")}} array.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("screenschange", (event) => { })

onscreenschange = (event) => { }
```

## Event type

A generic {{domxref("Event")}}.

## Examples

You could use the `screenschange` event to detect when the available screens have changed, report the change, close all windows, and then reopen them all to suit the new configuration:

```js
const screenDetails = await window.getScreenDetails();

// Return the number of screens
let noOfScreens = screenDetails.screens.length;

screenDetails.addEventListener("screenschange", () => {
  // If the new number of screens is different to the old number of screens, report the difference
  if (screenDetails.screens.length !== noOfScreens) {
    console.log(
      `The screen count changed from ${noOfScreens} to ${screenDetails.screens.length}`,
    );

    // Update noOfScreens value
    noOfScreens = screenDetails.screens.length;
  }

  // Open, close, or rearrange windows as needed, to fit the new screen configuration
  updateWindows();
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Window Management API](/en-US/docs/Web/API/Window_Management_API)
# ScreenOrientation: angle property

{{APIRef("Screen Orientation")}}

The **`angle`** read-only property of the
{{domxref("ScreenOrientation")}} interface returns the document's current orientation
angle.

## Value

An unsigned short integer.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ScreenOrientation: change event

{{APIRef("Screen Orientation API")}}

The **`change`** event of the {{domxref("ScreenOrientation")}} interface fires when the orientation of the screen has changed, for example when a user rotates their mobile phone.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("change", (event) => { })

onchange = (event) => { }
```

## Event type

A generic {{domxref("Event")}}.

## Example

In the following example, the `change` callback prints the new {{DOMxRef("ScreenOrientation.type", "screen orientation type", "", "nocode")}} and {{DOMxRef("ScreenOrientation.angle", "angle", "", "nocode")}}.

```js
screen.orientation.addEventListener("change", (event) => {
  const type = event.target.type;
  const angle = event.target.angle;
  console.log(`ScreenOrientation change: ${type}, ${angle} degrees.`);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ScreenOrientation

{{APIRef("Screen Orientation API")}}

The **`ScreenOrientation`** interface of the [Screen Orientation API](/en-US/docs/Web/API/Screen_Orientation_API) provides information about the current orientation of the document.

A **`ScreenOrientation`** instance object can be retrieved using the {{domxref("screen.orientation")}} property.

{{InheritanceDiagram}}

## Instance properties

- {{DOMxRef("ScreenOrientation.type")}} {{ReadOnlyInline}}
  - : Returns the document's current orientation type, one of `portrait-primary`, `portrait-secondary`, `landscape-primary`, or `landscape-secondary`.
- {{DOMxRef("ScreenOrientation.angle")}} {{ReadOnlyInline}}
  - : Returns the document's current orientation angle.

## Instance methods

- {{DOMxRef("ScreenOrientation.lock()")}}
  - : Locks the orientation of the containing document to its default orientation and returns a {{JSxRef("Promise")}}.
- {{DOMxRef("ScreenOrientation.unlock()")}}
  - : Unlocks the orientation of the containing document from its default orientation.

## Events

Listen to these events using `addEventListener()` or by assigning an event listener to the `oneventname` property of this interface.

- {{DOMxRef("ScreenOrientation.change_event", "change")}}
  - : Fired whenever the screen changes orientation.

## Example

In the following example, we listen for an orientation {{DOMxRef("ScreenOrientation.change_event", "change")}} event and log the new {{DOMxRef("ScreenOrientation.type", "screen orientation type", "", "nocode")}} and {{DOMxRef("ScreenOrientation.angle", "angle", "", "nocode")}}.

```js
screen.orientation.addEventListener("change", (event) => {
  const type = event.target.type;
  const angle = event.target.angle;
  console.log(`ScreenOrientation change: ${type}, ${angle} degrees.`);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ScreenOrientation: lock() method

{{APIRef("Screen Orientation")}}

The **`lock()`** method of the {{domxref("ScreenOrientation")}} interface locks the orientation of the containing document to the specified orientation.

Typically orientation locking is only enabled on mobile devices, and when the browser context is full screen.
If locking is supported, then it must work for all the parameter values listed below.

## Syntax

```js-nolint
lock(orientation)
```

### Parameters

- `orientation`
  - : An orientation lock type. One of the following:
    - `"any"`
      - : Any of `portrait-primary`, `portrait-secondary`, `landscape-primary` or `landscape-secondary`.
    - `"natural"`
      - : The natural orientation of the screen from the underlying operating system: either `portrait-primary` or `landscape-primary`.
    - `"landscape"`
      - : An orientation where screen width is greater than the screen height.
        Depending on the platform convention, this may be `landscape-primary`, `landscape-secondary`, or both.
    - `"portrait"`
      - : An orientation where screen height is greater than the screen width.
        Depending on the platform convention, this may be `portrait-primary`, `portrait-secondary`, or both.
    - `"portrait-primary"`
      - : The "primary" portrait mode.
        If the natural orientation is a portrait mode (screen height is greater than width), this will be the same as the natural orientation, and correspond to an angle of 0 degrees.
        If the natural orientation is a landscape mode, then the user agent can choose either portrait orientation as the `portrait-primary` and `portrait-secondary`; one of those will be assigned the angle of 90 degrees and the other will have an angle of 270 degrees.
    - `"portrait-secondary"`
      - : The secondary portrait orientation.
        If the natural orientation is a portrait mode, this will have an angle of 180 degrees (in other words, the device is upside down relative to its natural orientation).
        If the natural orientation is a landscape mode, this can be either orientation as selected by the user agent: whichever was not selected for `portrait-primary`.
    - `"landscape-primary"`
      - : The "primary" landscape mode.
        If the natural orientation is a landscape mode (screen width is greater than height), this will be the same as the natural orientation, and correspond to an angle of 0 degrees.
        If the natural orientation is a portrait mode, then the user agent can choose either landscape orientation as the `landscape-primary` with an angle of either 90 or 270 degrees (`landscape-secondary` will be the other orientation and angle).
    - `"landscape-secondary"`
      - : The secondary landscape mode.
        If the natural orientation is a landscape mode, this orientation is upside down relative to the natural orientation, and will have an angle of 180 degrees.
        If the natural orientation is a portrait mode, this can be either orientation as selected by the user agent: whichever was not selected for `landscape-primary`.

### Return value

A {{jsxref("Promise")}} that resolves after locking succeeds.

### Exceptions

The promise may be rejected with the following exceptions:

- `InvalidStateError` {{domxref("DOMException")}}
  - : Thrown if the document is not fully active.

- `SecurityError` {{domxref("DOMException")}}
  - : Thrown if the document's visibility state is hidden or if the document is forbidden to use the feature (for example, by omitting the keyword `allow-orientation-lock` of the `sandbox` attribute of the `iframe` element).

- `NotSupportedError` {{domxref("DOMException")}}
  - : Thrown if the user agent does not support locking the screen orientation of the specific orientation.

- `AbortError` {{domxref("DOMException")}}
  - : Thrown if there is any other `lock()` method invoking or if {{domxref("ScreenOrientation/unlock","unlock()")}} is called while the lock promise is pending.

## Examples

This example shows how to lock the screen to the opposite orientation of the current one.
Note that this example will only work on mobile devices and other devices that support orientation changes.

```html
<div id="example_container">
  <button id="fullscreen_button">Fullscreen</button>
  <button id="lock_button">Lock</button>
  <button id="unlock_button">Unlock</button>
  <textarea id="log" rows="7" cols="85"></textarea>
</div>
```

```js
const log = document.getElementById("log");

// Lock button: Lock the screen to the other orientation (rotated by 90 degrees)
const rotate_btn = document.querySelector("#lock_button");
rotate_btn.addEventListener("click", () => {
  log.textContent += `Lock pressed \n`;

  const oppositeOrientation = screen.orientation.type.startsWith("portrait")
    ? "landscape"
    : "portrait";
  screen.orientation
    .lock(oppositeOrientation)
    .then(() => {
      log.textContent = `Locked to ${oppositeOrientation}\n`;
    })
    .catch((error) => {
      log.textContent += `${error}\n`;
    });
});

// Unlock button: Unlock the screen orientation (if locked)
const unlock_btn = document.querySelector("#unlock_button");
unlock_btn.addEventListener("click", () => {
  log.textContent += "Unlock pressed \n";
  screen.orientation.unlock();
});

// Full screen button: Set the example to fullscreen.
const fullscreen_btn = document.querySelector("#fullscreen_button");
fullscreen_btn.addEventListener("click", () => {
  log.textContent += "Fullscreen pressed \n";
  const container = document.querySelector("#example_container");
  container.requestFullscreen().catch((error) => {
    log.textContent += `${error}\n`;
  });
});
```

To test the example, first press the Fullscreen button.
Once the example is full screen, press the Lock button to switch the orientation, and Unlock to return to the natural orientation.

{{EmbedLiveSample('Examples')}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ScreenOrientation: type property

{{APIRef("Screen Orientation")}}

The **`type`** read-only property of the
{{domxref("ScreenOrientation")}} interface returns the document's current orientation
type, one of `portrait-primary`, `portrait-secondary`, `landscape-primary`, or
`landscape-secondary`.

## Value

A {{jsxref("String")}}.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ScreenOrientation: unlock() method

{{APIRef("Screen Orientation")}}

The **`unlock()`** method of the {{domxref("ScreenOrientation")}} interface unlocks the orientation of the containing document, effectively locking it to the default screen orientation.

## Syntax

```js-nolint
unlock()
```

### Parameters

None.

### Return value

None ({{jsxref("undefined")}}).

### Exceptions

- `InvalidStateError` {{domxref("DOMException")}}
  - : Thrown if the document is not fully active.
- `SecurityError` {{domxref("DOMException")}}
  - : Thrown if the document's visibility state is hidden or if the document is forbidden to use the feature (for example, by omitting the keyword `allow-orientation-lock` of the `sandbox` attribute of the `iframe` element).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ScriptProcessorNode: audioprocess event

{{APIRef("Web Audio API")}}{{Deprecated_Header}}

The **`audioprocess`** event of the {{domxref("ScriptProcessorNode")}} interface is fired when an input buffer of a script processor is ready to be processed.

> [!NOTE]
> This feature was replaced by [AudioWorklets](/en-US/docs/Web/API/AudioWorklet) and the {{domxref("AudioWorkletNode")}} interface.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("audioprocess", (event) => { })

onaudioprocess = (event) => { }
```

## Event type

An {{domxref("AudioProcessingEvent")}}. Inherits from {{domxref("Event")}}.

{{InheritanceDiagram("AudioProcessingEvent")}}

## Event properties

_Also implements the properties inherited from its parent, {{domxref("Event")}}._

- `playbackTime` {{ReadOnlyInline}}
  - : A double representing the time when the audio will be played,
    as defined by the time of {{domxref("BaseAudioContext/currentTime", "AudioContext.currentTime")}}.
- `inputBuffer` {{ReadOnlyInline}}
  - : An {{domxref("AudioBuffer")}} that is the buffer containing the input audio data to be processed.
    The number of channels is defined as a parameter `numberOfInputChannels`,
    of the factory method {{domxref("BaseAudioContext/createScriptProcessor", "AudioContext.createScriptProcessor()")}}.
    Note that the returned <code>AudioBuffer</code> is only valid in the scope of the event handler.
- `outputBuffer` {{ReadOnlyInline}}
  - : An {{domxref("AudioBuffer")}} that is the buffer where the output audio data should be written.
    The number of channels is defined as a parameter, <code>numberOfOutputChannels</code>,
    of the factory method {{domxref("BaseAudioContext/createScriptProcessor", "AudioContext.createScriptProcessor()")}}.
    Note that the returned <code>AudioBuffer</code> is only valid in the scope of the event handler.

## Examples

```js
scriptNode.addEventListener("audioprocess", (audioProcessingEvent) => {
  // The input buffer is a song we loaded earlier
  const inputBuffer = audioProcessingEvent.inputBuffer;

  // The output buffer contains the samples that will be modified and played
  const outputBuffer = audioProcessingEvent.outputBuffer;

  // Loop through the output channels (in this case there is only one)
  for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {
    const inputData = inputBuffer.getChannelData(channel);
    const outputData = outputBuffer.getChannelData(channel);

    // Loop through the 4096 samples
    for (let sample = 0; sample < inputBuffer.length; sample++) {
      // make output equal to the same as the input
      outputData[sample] = inputData[sample];

      // add noise to each output sample
      outputData[sample] += (Math.random() * 2 - 1) * 0.2;
    }
  }
});
```

You could also set up the event handler using the `onaudioprocess` property:

```js
scriptNode.onaudioprocess = (audioProcessingEvent) => {
  // …
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Web Audio API](/en-US/docs/Web/API/Web_Audio_API)
# ScriptProcessorNode: bufferSize property

{{APIRef("Web Audio API")}}{{Deprecated_Header}}

The `bufferSize` property of the {{domxref("ScriptProcessorNode")}} interface returns an integer representing both the input and output buffer size, in sample-frames. Its value can be a power of 2 value in the range `256` – `16384`.

> [!NOTE]
> This feature was replaced by [AudioWorklets](/en-US/docs/Web/API/AudioWorklet) and the {{domxref("AudioWorkletNode")}} interface.

## Value

An integer.

## Examples

See [`BaseAudioContext.createScriptProcessor()`](/en-US/docs/Web/API/BaseAudioContext/createScriptProcessor#examples) for example code.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Using the Web Audio API](/en-US/docs/Web/API/Web_Audio_API/Using_Web_Audio_API)
# ScriptProcessorNode

{{APIRef("Web Audio API")}}{{Deprecated_Header}}

The `ScriptProcessorNode` interface allows the generation, processing, or analyzing of audio using JavaScript.

{{InheritanceDiagram}}

> [!NOTE]
> This feature was replaced by [AudioWorklets](/en-US/docs/Web/API/AudioWorklet) and the {{domxref("AudioWorkletNode")}} interface.

The `ScriptProcessorNode` interface is an {{domxref("AudioNode")}} audio-processing module that is linked to two buffers, one containing the input audio data, one containing the processed output audio data. An event, implementing the {{domxref("AudioProcessingEvent")}} interface, is sent to the object each time the input buffer contains new data, and the event handler terminates when it has filled the output buffer with data.

![The ScriptProcessorNode stores the input in a buffer, send the audioprocess event. The EventHandler takes the input buffer and fill the output buffer which is sent to the output by the ScriptProcessorNode.](webaudioscriptprocessingnode.png)

The size of the input and output buffer are defined at the creation time, when the {{domxref("BaseAudioContext.createScriptProcessor")}} method is called (both are defined by {{domxref("BaseAudioContext.createScriptProcessor")}}'s `bufferSize` parameter). The buffer size must be a power of 2 between `256` and `16384`, that is `256`, `512`, `1024`, `2048`, `4096`, `8192` or `16384`. Small numbers lower the _latency_, but large number may be necessary to avoid audio breakup and glitches.

If the buffer size is not defined, which is recommended, the browser will pick one that its heuristic deems appropriate.

<table class="properties">
  <tbody>
    <tr>
      <th scope="row">Number of inputs</th>
      <td><code>1</code></td>
    </tr>
    <tr>
      <th scope="row">Number of outputs</th>
      <td><code>1</code></td>
    </tr>
    <tr>
      <th scope="row">Channel count mode</th>
      <td><code>"max"</code></td>
    </tr>
    <tr>
      <th scope="row">Channel count</th>
      <td><code>2</code> (not used in the default count mode)</td>
    </tr>
    <tr>
      <th scope="row">Channel interpretation</th>
      <td><code>"speakers"</code></td>
    </tr>
  </tbody>
</table>

## Instance properties

_Inherits properties from its parent, {{domxref("AudioNode")}}_.

- {{domxref("ScriptProcessorNode.bufferSize")}} {{ReadOnlyInline}} {{Deprecated_Inline}}
  - : Returns an integer representing both the input and output buffer size. Its value can be a power of 2 value in the range `256` – `16384`.

## Instance methods

_No specific methods; inherits methods from its parent, {{domxref("AudioNode")}}_.

## Events

Listen to these events using [`addEventListener()`](/en-US/docs/Web/API/EventTarget/addEventListener) or by assigning an event listener to the `oneventname` property of this interface:

- [`audioprocess`](/en-US/docs/Web/API/ScriptProcessorNode/audioprocess_event) {{Deprecated_Inline}}
  - : Fired when an input buffer of a `ScriptProcessorNode` is ready to be processed.
    Also available via the `onaudioprocess` event handler property.

## Examples

See [`BaseAudioContext.createScriptProcessor()`](/en-US/docs/Web/API/BaseAudioContext/createScriptProcessor#examples) for example code.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Using the Web Audio API](/en-US/docs/Web/API/Web_Audio_API/Using_Web_Audio_API)
# ScrollTimeline: axis property

{{APIRef("Web Animations")}}

The **`axis`** read-only property of the
{{domxref("ScrollTimeline")}} interface returns an enumerated value representing the scroll axis that is driving the progress of the timeline.

## Value

An enumerated value. Possible values are:

- `"block"`
  - : The scrollbar on the block axis of the scroll container, which is the axis in the direction perpendicular to the flow of text within a line. For horizontal writing modes, such as standard English, this is the same as `"y"`, while for vertical writing modes, it is the same as `"x"`.
- `"inline"`
  - : The scrollbar on the inline axis of the scroll container, which is the axis in the direction parallel to the flow of text in a line. For horizontal writing modes, this is the same as `"x"`, while for vertical writing modes, this is the same as `"y"`.
- `"y"`
  - : The scrollbar on the vertical axis of the scroll container.
- `"x"`
  - : The scrollbar on the horizontal axis of the scroll container.

## Examples

See the main {{domxref("ScrollTimeline")}} page for an example.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("ScrollTimeline")}}
- {{domxref("AnimationTimeline")}}, {{domxref("ViewTimeline")}}
- [Web Animations API](/en-US/docs/Web/API/Web_Animations_API)
- [CSS scroll-driven animations](/en-US/docs/Web/CSS/CSS_scroll-driven_animations)
# ScrollTimeline

{{APIRef("Web Animations")}}

The **`ScrollTimeline`** interface of the {{domxref("Web Animations API", "Web Animations API", "", "nocode")}} represents a scroll progress timeline (see [CSS scroll-driven animations](/en-US/docs/Web/CSS/CSS_scroll-driven_animations) for more details).

Pass a `ScrollTimeline` instance to the {{domxref("Animation.Animation", "Animation()")}} constructor or the {{domxref("Element.animate()", "animate()")}} method to specify it as the timeline that will control the progress of the animation.

{{InheritanceDiagram}}

## Constructor

- {{domxref("ScrollTimeline.ScrollTimeline", "ScrollTimeline()")}}
  - : Creates a new `ScrollTimeline` object instance.

## Instance properties

_This interface also inherits the properties of its parent, {{domxref("AnimationTimeline")}}._

- {{domxref("ScrollTimeline.source", "source")}} {{ReadOnlyInline}}
  - : Returns a reference to the scrollable element (_scroller_) whose scroll position is driving the progress of the timeline and therefore the animation.
- {{domxref("ScrollTimeline.axis", "axis")}} {{ReadOnlyInline}}
  - : Returns an enumerated value representing the scroll axis that is driving the progress of the timeline.

## Instance methods

_This interface inherits the methods of its parent, {{domxref("AnimationTimeline")}}._

## Examples

### Displaying the source and axis of a scroll progress timeline

In this example, we animate an element with a `class` of `box` along a view progress timeline — it animates across the screen as the document scrolls. We output the `source` element and scroll `axis` to an `output` element in the top-right corner.

#### HTML

The HTML for the example is shown below.

```html
<div class="content"></div>
<div class="box"></div>
<div class="output"></div>
```

#### CSS

The CSS for the example looks like this:

```css
.content {
  height: 2000px;
}

.box {
  width: 100px;
  height: 100px;
  border-radius: 10px;
  background-color: rebeccapurple;
  position: fixed;
  top: 20px;
  left: 0%;
}

.output {
  font-family: "Helvetica", "Arial", sans-serif;
  position: fixed;
  top: 5px;
  right: 5px;
}
```

#### JavaScript

In the JavaScript, we grab references to the `box` and `output` `<div>`s, then create a new `ScrollTimeline`, specifying that the element that will drive the scroll timeline progress is the document ({{htmlelement("html")}}) element, and the scroll axis is the `block` axis. We then animate the `box` element with the Web Animations API. Last of all, we display the source element and axis in the `output` element.

```js
const box = document.querySelector(".box");
const output = document.querySelector(".output");

const timeline = new ScrollTimeline({
  source: document.documentElement,
  axis: "block",
});

box.animate(
  {
    rotate: ["0deg", "720deg"],
    left: ["0%", "100%"],
  },
  {
    timeline,
  },
);

output.textContent = `Timeline source element: ${timeline.source.nodeName}. Timeline scroll axis: ${timeline.axis}`;
```

#### Result

Scroll to see the box being animated.

{{EmbedLiveSample("Displaying the source and axis of a scroll progress timeline", "100%", "320px")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Web Animations API](/en-US/docs/Web/API/Web_Animations_API)
- [CSS scroll-driven animations](/en-US/docs/Web/CSS/CSS_scroll-driven_animations)
- {{domxref("AnimationTimeline")}}, {{domxref("ViewTimeline")}}
# ScrollTimeline: ScrollTimeline() constructor

{{APIRef("History API")}}

The **`ScrollTimeline()`** constructor creates a new {{domxref("ScrollTimeline")}} object instance.

## Syntax

```js-nolint
new ScrollTimeline(options)
```

### Parameters

- `options`
  - : An object that can contain the following properties:
    - `source`
      - : A reference to an {{domxref("Element")}} representing the scrollable element (_scroller_) whose scroll position will drive the progress of the timeline.
    - `axis` {{optional_inline}}
      - : An enumerated value representing the scroll axis that will drive the progress of the timeline. Possible values are:
        - `"block"`: The scrollbar on the block axis of the scroll container, which is the axis in the direction perpendicular to the flow of text within a line. For horizontal writing modes, such as standard English, this is the same as `"y"`, while for vertical writing modes, it is the same as `"x"`.
        - `"inline"`: The scrollbar on the inline axis of the scroll container, which is the axis in the direction parallel to the flow of text in a line. For horizontal writing modes, this is the same as `"x"`, while for vertical writing modes, this is the same as `"y"`.
        - `"y"`: The scrollbar on the vertical axis of the scroll container.
        - `"x"`: The scrollbar on the horizontal axis of the scroll container.

        If omitted, `axis` defaults to `"block"`.

### Return value

A new {{domxref("ScrollTimeline")}} object instance.

## Examples

See the main {{domxref("ScrollTimeline")}} page for an example.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Web Animations API](/en-US/docs/Web/API/Web_Animations_API)
- [CSS scroll-driven animations](/en-US/docs/Web/CSS/CSS_scroll-driven_animations)
- {{domxref("ScrollTimeline")}}
- {{domxref("AnimationTimeline")}}, {{domxref("ViewTimeline")}}
# ScrollTimeline: source property

{{APIRef("Web Animations")}}

The **`source`** read-only property of the
{{domxref("ScrollTimeline")}} interface returns a reference to the scrollable element (_scroller_) whose scroll position is driving the progress of the timeline and therefore the animation.

## Value

An {{domxref("Element")}}.

## Examples

See the main {{domxref("ScrollTimeline")}} page for an example.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Web Animations API](/en-US/docs/Web/API/Web_Animations_API)
- [CSS scroll-driven animations](/en-US/docs/Web/CSS/CSS_scroll-driven_animations)
- {{domxref("ScrollTimeline")}}
- {{domxref("AnimationTimeline")}}, {{domxref("ViewTimeline")}}
# SecurePaymentConfirmationRequest

{{APIRef("Payment Request API")}}

The **`SecurePaymentConfirmationRequest`** dictionary describes input to the [Payment Request API](/en-US/docs/Web/API/Payment_Request_API) when used to authenticate a user during an e-commerce transaction [using SPC with Payment Request API](/en-US/docs/Web/API/Payment_Request_API/Using_secure_payment_confirmation).

An instance of this dictionary must be passed into the {{domxref("PaymentRequest.PaymentRequest()", "PaymentRequest()")}} constructor as the value of the [`data`](/en-US/docs/Web/API/PaymentRequest/PaymentRequest#data) field corresponding to a [`supportedMethods`](/en-US/docs/Web/API/PaymentRequest/PaymentRequest#supportedmethods) value of `"secure-payment-confirmation"`.

## Instance properties

- `challenge`
  - : An {{jsxref("ArrayBuffer")}}, {{jsxref("TypedArray")}}, or {{jsxref("DataView")}} provided by the relying party's server and used as a [cryptographic challenge](https://en.wikipedia.org/wiki/Challenge%E2%80%93response_authentication). This value will be signed by the authenticator and the signature will be sent back as part of {{domxref("AuthenticatorAttestationResponse.attestationObject")}}. This helps prevent replay attacks.
- `credentialIds`
  - : A list of {{jsxref("ArrayBuffer")}}, {{jsxref("TypedArray")}}, or {{jsxref("DataView")}}. These [Credential IDs](https://w3c.github.io/webauthn/#credential-id) represent Web Authentication credentials that have been registered with the relying party for authenticating during a payment with the associated `instrument`.
- `extensions` {{optional_inline}}
  - : Any [WebAuthn extensions](/en-US/docs/Web/API/Web_Authentication_API/WebAuthn_extensions) that should be used for the passed credential(s). The caller does not need to specify the [`payment` extension](/en-US/docs/Web/API/Web_Authentication_API/WebAuthn_extensions#payment); this is added automatically.
- `instrument`
  - : The description of the instrument name and icon to display during registration and to be signed along with the transaction details. This is an object with the following properties:
    - `displayName`
      - : A string containing the payment instrument's name, which will be displayed to the user.
    - `icon`
      - : A string containing the URL of the payment instrument's icon.
    - `iconMustBeShown` {{optional_inline}}
      - : A boolean value indicating whether the icon must be successfully fetched and shown for the request to succeed. Defaults to `true`.
- `locale` {{optional_inline}}
  - : An optional list of well-formed {{glossary("BCP 47 language tag", "BCP 47 language tags")}}, in descending order of priority, that identify the local preferences of the website. That is, this represents a language priority list {{RFC(4647, "Matching of Language Tags")}}, which the user agent can use to perform [language negotiation](/en-US/docs/Web/HTTP/Guides/Content_negotiation) and locale-affected formatting with the caller.
    > [!NOTE]
    > The locale is distinct from language or direction metadata associated with specific input members, in that it represents the caller's requested localized experience rather than assertion about a specific string value. See [SPC internationalization Considerations](https://w3c.github.io/secure-payment-confirmation/#sctn-i18n-considerations) for more discussion.
- `payeeName` {{optional_inline}}
  - : A string that serves as the display name of the payee that this SPC call is for (e.g., the merchant). Optional, may be provided alongside or instead of `payeeOrigin`.
- `payeeOrigin` {{optional_inline}}
  - : A string that is the origin of the payee that this SPC call is for (e.g., the merchant). Optional, may be provided alongside or instead of `payeeName`.
- `rpId`
  - : A string that specifies the relying party's identifier (for example "login.example.org").
- `showOptOut` {{optional_inline}}
  - : A boolean indicating whether the user should be given a chance to opt-out during the [transaction dialog UX](/en-US/docs/Web/API/Payment_Request_API/Using_secure_payment_confirmation#authenticating_a_payment). Defaults to `false`.
- `timeout` {{optional_inline}}
  - : The number of milliseconds before the request to sign the transaction details times out. At most 1 hour.

## Specifications

{{Specifications}}
# SecurityPolicyViolationEvent: blockedURI property

{{APIRef("Reporting API")}}{{AvailableInWorkers}}

The **`blockedURI`** read-only property of the {{domxref("SecurityPolicyViolationEvent")}} interface is a string representing the URI of the resource that was blocked because it violates a [Content Security Policy (CSP)](/en-US/docs/Web/HTTP/Guides/CSP).

## Value

A string representing the URI of the blocked resource.

## Examples

```js
document.addEventListener("securitypolicyviolation", (e) => {
  console.log(e.blockedURI);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("CSPViolationReportBody.blockedURL")}}
# SecurityPolicyViolationEvent: columnNumber property

{{APIRef("Reporting API")}}{{AvailableInWorkers}}

The **`columnNumber`** read-only property of the {{domxref("SecurityPolicyViolationEvent")}} interface is the column number in the document or worker script at which the [Content Security Policy (CSP)](/en-US/docs/Web/HTTP/Guides/CSP) violation occurred.

## Value

A number representing the column number where the violation occurred.

## Examples

```js
document.addEventListener("securitypolicyviolation", (e) => {
  console.log(e.columnNumber);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("CSPViolationReportBody.columnNumber")}}
# SecurityPolicyViolationEvent: disposition property

{{APIRef("Reporting API")}}{{AvailableInWorkers}}

The **`disposition`** read-only property of the {{domxref("SecurityPolicyViolationEvent")}} interface indicates how the violated [Content Security Policy (CSP)](/en-US/docs/Web/HTTP/Guides/CSP) is configured to be treated by the user agent.

## Value

Possible values are:

- `"enforce"`
  - : The policy is enforced and the resource request is blocked.
- `"report"`
  - : The violation is reported but the resource request is not blocked.

## Examples

```js
document.addEventListener("securitypolicyviolation", (e) => {
  console.log(e.disposition);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("CSPViolationReportBody.disposition")}}
# SecurityPolicyViolationEvent: documentURI property

{{APIRef("Reporting API")}}{{AvailableInWorkers}}

The **`documentURI`** read-only property of the {{domxref("SecurityPolicyViolationEvent")}} interface is a string representing the URI of the document or worker in which the [Content Security Policy (CSP)](/en-US/docs/Web/HTTP/Guides/CSP) violation occurred.

## Value

A string representing the URI of the document or worker in which the violation occurred.

## Examples

```js
document.addEventListener("securitypolicyviolation", (e) => {
  console.log(e.documentURI);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("CSPViolationReportBody.documentURL")}}
# SecurityPolicyViolationEvent: effectiveDirective property

{{APIRef("Reporting API")}}{{AvailableInWorkers}}

The **`effectiveDirective`** read-only property of the {{domxref("SecurityPolicyViolationEvent")}} interface is a string representing the [Content Security Policy (CSP)](/en-US/docs/Web/HTTP/Guides/CSP) directive that was violated.

This supersedes {{domxref("SecurityPolicyViolationEvent.violatedDirective")}}, its historical alias.

## Value

A string representing the particular [`Content-Security-Policy` directive](/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy#directives) that was violated.

## Examples

```js
document.addEventListener("securitypolicyviolation", (e) => {
  console.log(e.effectiveDirective);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("CSPViolationReportBody.effectiveDirective")}}
# SecurityPolicyViolationEvent

{{APIRef("Reporting API")}}{{AvailableInWorkers}}

The **`SecurityPolicyViolationEvent`** interface inherits from {{domxref("Event")}}, and represents the event object of a `securitypolicyviolation` event sent on an {{domxref("Element/securitypolicyviolation_event", "Element")}}, {{domxref("Document/securitypolicyviolation_event", "Document")}}, or {{domxref("WorkerGlobalScope/securitypolicyviolation_event", "worker","","nocode")}} when its [Content Security Policy (CSP)](/en-US/docs/Web/HTTP/Guides/CSP) is violated.

{{InheritanceDiagram}}

## Constructor

- {{domxref("SecurityPolicyViolationEvent.SecurityPolicyViolationEvent","SecurityPolicyViolationEvent()")}}
  - : Creates a new `SecurityPolicyViolationEvent` object instance.

## Instance properties

- {{domxref("SecurityPolicyViolationEvent.blockedURI")}} {{ReadOnlyInline}}
  - : A string representing the URI of the resource that was blocked because it violates a policy.
- {{domxref("SecurityPolicyViolationEvent.columnNumber")}} {{ReadOnlyInline}}
  - : The column number in the document or worker at which the violation occurred.
- {{domxref("SecurityPolicyViolationEvent.disposition")}} {{ReadOnlyInline}}
  - : A string indicating whether the user agent is configured to enforce or just report the policy violation.
- {{domxref("SecurityPolicyViolationEvent.documentURI")}} {{ReadOnlyInline}}
  - : A string representing the URI of the document or worker in which the violation occurred.
- {{domxref("SecurityPolicyViolationEvent.effectiveDirective")}} {{ReadOnlyInline}}
  - : A string representing the directive that was violated.
- {{domxref("SecurityPolicyViolationEvent.lineNumber")}} {{ReadOnlyInline}}
  - : The line number in the document or worker at which the violation occurred.
- {{domxref("SecurityPolicyViolationEvent.originalPolicy")}} {{ReadOnlyInline}}
  - : A string containing the policy whose enforcement caused the violation.
- {{domxref("SecurityPolicyViolationEvent.referrer")}} {{ReadOnlyInline}}
  - : A string representing the URL for the referrer of the resources whose policy was violated, or `null`.
- {{domxref("SecurityPolicyViolationEvent.sample")}} {{ReadOnlyInline}}
  - : A string representing a sample of the resource that caused the violation, usually the first 40 characters. This will only be populated if the resource is an inline script, event handler, or style — external resources causing a violation will not generate a sample.
- {{domxref("SecurityPolicyViolationEvent.sourceFile")}} {{ReadOnlyInline}}
  - : If the violation occurred as a result of a script, this will be the URL of the script; otherwise, it will be `null`.
    Both `columnNumber` and `lineNumber` should have non-null values if this property is not `null`.
- {{domxref("SecurityPolicyViolationEvent.statusCode")}} {{ReadOnlyInline}}
  - : A number representing the HTTP status code of the document or worker in which the violation occurred.
- {{domxref("SecurityPolicyViolationEvent.violatedDirective")}} {{ReadOnlyInline}}
  - : A string representing the directive that was violated.
    This is a historical alias of [`effectiveDirective`](/en-US/docs/Web/API/SecurityPolicyViolationEvent/effectiveDirective).

## Examples

```js
document.addEventListener("securitypolicyviolation", (e) => {
  console.log(e.blockedURI);
  console.log(e.violatedDirective);
  console.log(e.originalPolicy);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- HTTP [Content Security Policy (CSP)](/en-US/docs/Web/HTTP/Guides/CSP)
- {{domxref("CSPViolationReportBody")}}
- The {{domxref("Element/securitypolicyviolation_event", "securitypolicyviolation")}} event of the {{domxref("Element")}} interface
- The {{domxref("Document/securitypolicyviolation_event", "securitypolicyviolation")}} event of the {{domxref("Document")}} interface
- The {{domxref("WorkerGlobalScope/securitypolicyviolation_event", "securitypolicyviolation")}} event of the {{domxref("WorkerGlobalScope")}} interface
# SecurityPolicyViolationEvent: lineNumber property

{{APIRef("Reporting API")}}{{AvailableInWorkers}}

The **`lineNumber`** read-only property of the {{domxref("SecurityPolicyViolationEvent")}} interface is the line number in the document or worker script at which the [Content Security Policy (CSP)](/en-US/docs/Web/HTTP/Guides/CSP) violation occurred.

## Value

A number representing the line number at which the violation occurred.

## Examples

```js
document.addEventListener("securitypolicyviolation", (e) => {
  console.log(e.lineNumber);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("CSPViolationReportBody.lineNumber")}}
# SecurityPolicyViolationEvent: originalPolicy property

{{APIRef("Reporting API")}}{{AvailableInWorkers}}

The **`originalPolicy`** read-only property of the {{domxref("SecurityPolicyViolationEvent")}} interface is a string containing the [Content Security Policy (CSP)](/en-US/docs/Web/HTTP/Guides/CSP) whose enforcement uncovered the violation.

## Value

A string representing the policy whose enforcement uncovered the violation.

This is the string in the {{HTTPHeader("Content-Security-Policy")}} HTTP header that contains the list of [directives](/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy#directives) and their values that make the CSP policy.

## Examples

```js
document.addEventListener("securitypolicyviolation", (e) => {
  console.log(e.originalPolicy);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("CSPViolationReportBody.originalPolicy")}}
# SecurityPolicyViolationEvent: referrer property

{{APIRef("Reporting API")}}{{AvailableInWorkers}}

The **`referrer`** read-only property of the {{domxref("SecurityPolicyViolationEvent")}} interface is a string representing the referrer for the resources whose [Content Security Policy (CSP)](/en-US/docs/Web/HTTP/Guides/CSP) was violated.
This will be a URL or `null`.

## Value

A string representing the URL for the referrer of the resources whose policy was violated, or `null`.

## Examples

```js
document.addEventListener("securitypolicyviolation", (e) => {
  console.log(e.referrer);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("CSPViolationReportBody.referrer")}}
# SecurityPolicyViolationEvent: sample property

{{APIRef("Reporting API")}}{{AvailableInWorkers}}

The **`sample`** read-only property of the {{domxref("SecurityPolicyViolationEvent")}} interface is a string representing a sample of the resource that caused the [Content Security Policy (CSP)](/en-US/docs/Web/HTTP/Guides/CSP) violation.

This is only [`script-src*`](/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy/script-src) and [`style-src*`](/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy/style-src) violations, when the corresponding `Content-Security-Policy` directive contains the [`'report-sample'`](/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy#report-sample) keyword.
In addition, this will only be populated if the resource is an inline script, event handler, or style — external resources causing a violation will not generate a sample.

> [!NOTE]
> Violation reports should be considered attacker-controlled data.
> The content of this field should be sanitized before storing or rendering.

## Value

A string containing a sample of the resource that caused the violation, usually the first 40 characters, or the empty string.

## Examples

```js
document.addEventListener("securitypolicyviolation", (e) => {
  console.log(e.sample);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("CSPViolationReportBody.sample")}}
# SecurityPolicyViolationEvent: SecurityPolicyViolationEvent() constructor

{{APIRef("Reporting API")}}{{AvailableInWorkers}}

The **`SecurityPolicyViolationEvent()`** constructor creates a new {{domxref("SecurityPolicyViolationEvent")}} object.

## Syntax

```js-nolint
new SecurityPolicyViolationEvent(type)
new SecurityPolicyViolationEvent(type, options)
```

### Parameters

- `type`
  - : A string with the name of the event.
    It is case-sensitive and browsers always set it to `securitypolicyviolation`.
- `options` {{optional_inline}}
  - : An object that, _in addition of the properties defined in {{domxref("Event/Event", "Event()")}}_, can have the following properties:
    - `blockedURI` {{optional_inline}}
      - : The {{domxref("SecurityPolicyViolationEvent.blockedURI","blockedURI")}} of the `SecurityPolicyViolationEvent`.
        If not included, the default value is `""`.
    - `columnNumber` {{optional_inline}}
      - : The {{domxref("SecurityPolicyViolationEvent.columnNumber","columnNumber")}} of the `SecurityPolicyViolationEvent`.
        If not included, the default value is `0`.
    - `disposition`
      - : The {{domxref("SecurityPolicyViolationEvent.disposition","disposition")}} of the `SecurityPolicyViolationEvent`.
    - `documentURI`
      - : The {{domxref("SecurityPolicyViolationEvent.documentURI","documentURI")}} of the `SecurityPolicyViolationEvent`.
    - `effectiveDirective`
      - : The {{domxref("SecurityPolicyViolationEvent.effectiveDirective","effectiveDirective")}} of the `SecurityPolicyViolationEvent`.
    - `lineNumber` {{optional_inline}}
      - : The {{domxref("SecurityPolicyViolationEvent.lineNumber","lineNumber")}} of the `SecurityPolicyViolationEvent`.
        If not included, the default value is `0`.
    - `originalPolicy`
      - : The {{domxref("SecurityPolicyViolationEvent.originalPolicy","originalPolicy")}} of the `SecurityPolicyViolationEvent`.
    - `referrer` {{optional_inline}}
      - : The {{domxref("SecurityPolicyViolationEvent.referrer","referrer")}} of the `SecurityPolicyViolationEvent`.
        If not included, the default value is `""`.
    - `sample` {{optional_inline}}
      - : The {{domxref("SecurityPolicyViolationEvent.sample","sample")}} of the `SecurityPolicyViolationEvent`.
        If not included, the default value is `""`.
    - `sourceFile` {{optional_inline}}
      - : The {{domxref("SecurityPolicyViolationEvent.sourceFile","sourceFile")}} of the `SecurityPolicyViolationEvent`.
        If not included, the default value is `""`.
    - `statusCode`
      - : The {{domxref("SecurityPolicyViolationEvent.statusCode","statusCode")}} of the `SecurityPolicyViolationEvent`.
    - `violatedDirective`
      - : The {{domxref("SecurityPolicyViolationEvent.violatedDirective","violatedDirective")}} of the `SecurityPolicyViolationEvent`.

### Return value

A new `SecurityPolicyViolationEvent` object.

## Examples

```js
let SPVEvt = new SecurityPolicyViolationEvent("foo", {
  /* ... */
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Content Security Policy (CSP)](/en-US/docs/Web/HTTP/Guides/CSP)
# SecurityPolicyViolationEvent: sourceFile property

{{APIRef("Reporting API")}}{{AvailableInWorkers}}

The **`sourceFile`** read-only property of the {{domxref("SecurityPolicyViolationEvent")}} interface is a string representing the URL of the script in which the [Content Security Policy (CSP)](/en-US/docs/Web/HTTP/Guides/CSP) violation occurred.

## Value

A string representing the URL of the script in which the violation occurred, or `null` if the violation is not in a script.

Note that both `columnNumber` and `lineNumber` should have non-null values if this property is not `null`.

## Examples

```js
document.addEventListener("securitypolicyviolation", (e) => {
  console.log(e.sourceFile);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("CSPViolationReportBody.sourceFile")}}
# SecurityPolicyViolationEvent: statusCode property

{{APIRef("Reporting API")}}{{AvailableInWorkers}}

The **`statusCode`** read-only property of the {{domxref("SecurityPolicyViolationEvent")}} interface is a number representing the HTTP status code of the window or worker in which the [Content Security Policy (CSP)](/en-US/docs/Web/HTTP/Guides/CSP) violation occurred.

## Value

A number representing the status code of the window or worker in which the violation occurred.

## Examples

```js
document.addEventListener("securitypolicyviolation", (e) => {
  console.log(e.statusCode);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("CSPViolationReportBody.statusCode")}}
# SecurityPolicyViolationEvent: violatedDirective property

{{APIRef("Reporting API")}}{{AvailableInWorkers}}

The **`violatedDirective`** read-only property of the {{domxref("SecurityPolicyViolationEvent")}} interface is a string representing the [Content Security Policy (CSP)](/en-US/docs/Web/HTTP/Guides/CSP) directive that was violated.

This is a historical alias of {{domxref("SecurityPolicyViolationEvent.effectiveDirective")}}, and has the same value.

## Value

A string representing the [`Content-Security-Policy` directive](/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy#directives) that was violated.

## Examples

```js
document.addEventListener("securitypolicyviolation", (e) => {
  console.log(e.violatedDirective);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Selection: addRange() method

{{ ApiRef("DOM") }}

The **`Selection.addRange()`** method adds a
{{domxref("Range")}} to a {{domxref("Selection")}}.

## Syntax

```js-nolint
addRange(range)
```

### Parameters

- `range`
  - : A {{ domxref("Range") }} object that will be added to the {{domxref("Selection")}}.

### Return value

None ({{jsxref("undefined")}}).

## Examples

> [!NOTE]
> Currently only Firefox supports multiple selection ranges, other browsers will not
> add new ranges to the selection if it already contains one.

### HTML

```html
<p>
  I <strong>insist</strong> that you <strong>try</strong> selecting the
  <strong>strong words</strong>.
</p>
<button>Select strong words</button>
```

### JavaScript

```js
let button = document.querySelector("button");

button.addEventListener("click", () => {
  const selection = window.getSelection();
  const strongElems = document.getElementsByTagName("strong");

  if (selection.rangeCount > 0) {
    selection.removeAllRanges();
  }

  for (const node of strongElems) {
    const range = document.createRange();
    range.selectNode(node);
    selection.addRange(range);
  }
});
```

### Result

{{EmbedLiveSample("Examples")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}, the interface this method belongs to
# Selection: anchorNode property

{{ ApiRef("DOM") }}

The **`Selection.anchorNode`** read-only property returns the {{domxref("Node")}} in which the selection begins. It can return `null` if selection never existed in the document (e.g., an iframe that was never clicked on, or the node belongs to another document tree).

A user may make a selection from left to right (in document order) or right to left (reverse of document order). The anchor is where the user began the selection. This can be visualized by holding the <kbd>Shift</kbd> key and pressing the arrow keys on your keyboard. The selection's anchor does not move, but the selection's focus, the other end of the selection, does move.

## Value

A {{domxref("Node")}} object or `null`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}
- {{domxref("Selection.focusNode")}}
# Selection: anchorOffset property

{{ ApiRef("DOM") }}

The **`Selection.anchorOffset`** read-only property returns the
number of characters that the selection's anchor is offset within the
{{domxref("Selection.anchorNode")}} if said node is of type {{domxref("Text")}}, {{domxref("CDATASection")}} or {{domxref("Comment")}}.

In the case of {{domxref("Selection.anchorNode")}} being another type of node, **`Selection.anchorOffset`** returns the number of {{domxref("Node.childNodes")}} the selection's anchor is offset within the {{domxref("Selection.anchorNode")}}.

This number is zero-based. If the selection begins with the first character in the
{{domxref("Selection.anchorNode")}}, `0` is returned.

## Value

A number.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}, the interface it belongs to.
# Selection API

{{DefaultAPISidebar("Selection API")}}

> [!NOTE]
> This API is _not available_ in [Web Workers](/en-US/docs/Web/API/Web_Workers_API) (not exposed via {{domxref("WorkerNavigator")}}).

The **Selection API** enables developers to access and manipulate the portion of a document selected by the user.

The {{domxref("Window/getSelection()", "Window.getSelection()")}} and {{domxref("Document/getSelection()", "Document.getSelection()")}} methods return a {{domxref("Selection")}} object representing the portion of the document selected by the user. A `Selection` object provides methods to:

- access the currently selected nodes
- modify the current selection, expanding or collapsing it or selecting an entirely different part of the document
- delete parts of the current selection from the DOM.

The Selection API also provides two events, both firing on {{domxref("Document")}}:

- the {{domxref("Node/selectstart_event", "selectstart")}} event is fired when the user starts to make a new selection
- the {{domxref("Document/selectionchange_event", "selectionchange")}} event is fired when the current selection changes.

## Interfaces

- {{domxref("Selection")}}
  - : An interface which represents the part of the document selected by the user or the current position of the caret.
- {{domxref("Document/getSelection()", "Document.getSelection()")}}
  - : A method returning a `Selection` object representing the current selection or current position of the caret.
- {{domxref("Window/getSelection()", "Window.getSelection()")}}
  - : A method returning a `Selection` object representing the current selection or current position of the caret.
- {{domxref("Document/selectionchange_event", "Document.selectionchange")}}
  - : An event which is fired when the current selection is changed.
- {{domxref("Node/selectstart_event", "Node.selectstart")}}
  - : An event which is fired when a user starts a new selection.

## Specifications

{{Specifications}}
# Selection: collapse() method

{{ApiRef("DOM")}}

The **`Selection.collapse()`** method collapses the current selection to a single point. The document is not modified. If the content is focused and editable, the caret will blink there.

> [!NOTE]
> This method is an alias for the {{domxref("Selection.setPosition()")}} method.

## Syntax

```js-nolint
collapse(node)
collapse(node, offset)
```

### Parameters

- `node`
  - : The caret location will be within this node. This value can also be set to
    `null` — if `null` is specified, the method will behave like
    {{domxref("Selection.removeAllRanges()")}}, i.e., all ranges will be removed from the
    selection.
- `offset` {{optional_inline}}
  - : The offset in `node` to which the selection will be collapsed. If not
    specified, the default value `0` is used.

### Return value

None ({{jsxref("undefined")}}).

## Examples

```js
// Place the caret at the beginning of an HTML document's body.
const body = document.querySelector("body");
window.getSelection().collapse(body, 0);
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection.setPosition()")}}
# Selection: collapseToEnd() method

{{ ApiRef("DOM") }}

The **`Selection.collapseToEnd()`** method collapses the
selection to the end of the last range in the selection. If the content of the selection
is focused and editable, the caret will blink there.

## Syntax

```js-nolint
collapseToEnd()
```

### Parameters

None.

### Return value

None ({{jsxref("undefined")}}).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}, the interface it belongs to.
# Selection: collapseToStart() method

{{ ApiRef("DOM") }}

The **`Selection.collapseToStart()`** method collapses the
selection to the start of the first range in the selection. If the content of the
selection is focused and editable, the caret will blink there.

## Syntax

```js-nolint
collapseToStart()
```

### Parameters

None.

### Return value

None ({{jsxref("undefined")}}).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}, the interface it belongs to.
# Selection: containsNode() method

{{ ApiRef("DOM") }}

The **`Selection.containsNode()`** method indicates whether a
specified node is part of the selection.

## Syntax

```js-nolint
containsNode(node)
containsNode(node)
containsNode(node, partialContainment)
```

### Parameters

- `node`
  - : The node that is being looked for in the selection.
- `partialContainment` {{optional_inline}}
  - : When `true`, `containsNode()` returns `true` when a
    part of the node is part of the selection. When `false`,
    `containsNode()` only returns `true` when the entire node is
    part of the selection. If not specified, the default value `false` is used.

### Return value

Returns `true` if the given node is part of the selection, and `false` otherwise.

## Examples

### Check for selection

This snippet checks whether anything inside the body element is selected.

```js
console.log(window.getSelection().containsNode(document.body, true));
```

### Find the hidden word

In this example, a message appears when you select the secret word. It uses
{{domxref("EventTarget/addEventListener", "addEventListener()")}} to check for
{{domxref("Document/selectionchange_event", "selectionchange")}} events.

#### HTML

```html
<p>Can you find the secret word?</p>
<p>Hmm, where <span id="secret">SECRET</span> could it be?</p>
<p id="win" hidden>You found it!</p>
```

#### CSS

```css
#secret {
  color: transparent;
}
```

#### JavaScript

```js
const secret = document.getElementById("secret");
const win = document.getElementById("win");

// Listen for selection changes
document.addEventListener("selectionchange", () => {
  const selection = window.getSelection();
  const found = selection.containsNode(secret);

  win.toggleAttribute("hidden", !found);
});
```

#### Result

{{EmbedLiveSample("Find_the_hidden_word")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}, the interface it belongs to.
# Selection: deleteFromDocument() method

{{ ApiRef("DOM") }}

The **`deleteFromDocument()`** method of the
{{domxref("Selection")}} interface invokes the {{domxref("Range.deleteContents()")}} method on the selected {{domxref("Range")}}.

## Syntax

```js-nolint
deleteFromDocument()
```

### Parameters

None.

### Return value

None ({{jsxref("undefined")}}).

## Examples

This example lets you delete selected text and/or nodes by clicking a button. Upon clicking the
button, the
{{domxref("Window.getSelection()")}} method gets the selected content, and the
`deleteFromDocument()` method removes it.

### HTML

```html
<p>Try highlighting some of the elements in these paragraphs.</p>
<p>
  Once you do, you can remove the selected content by clicking the button below.
</p>
<h2>All of the selected text/nodes will be removed.</h2>
<button>Delete selected text</button>
```

### JavaScript

```js
let button = document.querySelector("button");
button.addEventListener("click", deleteSelection);

function deleteSelection() {
  let selection = window.getSelection();
  selection.deleteFromDocument();
}
```

### Result

{{EmbedLiveSample("Examples")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}, the interface defining this method
# Selection: direction property

{{APIRef("DOM")}}

The **`direction`** read-only property of the {{domxref("Selection")}} interface is a string that provides the direction of the current selection.

The value is determined by the order in which the user chooses the boundary points of the selection.
For example, a user might make a selection by clicking a starting boundary point, dragging the cursor, and releasing at an end boundary point.
If the end boundary point is later in the document than the start point, then the direction is "forwards", while the direction is "backwards" if the end point is before the start point within the document.
The value is "directionless" if no direction is implied by the user. For example, if the user made the selection by double-clicking on a word or element, or the selection was made programmatically.

The direction does not change if a selection's range is mutated, for example, using methods like {{DOMxRef("Range.selectNode()")}}.

## Value

A string describing the type of the current selection.
Possible values are:

- `backward`
  - : The selection is backwards.
- `forward`
  - : The selection is forwards.
- `none`
  - : No selection has been made, or the selection is directionless.

## Examples

This example allows you to test how the `direction` property works by logging the current direction of text selected within a paragraph.

### HTML

The HTML just displays a paragraph element with some text that you can select.

```html
<p id="text-box">
  Select text in this paragraph to see the selection direction.
</p>
```

Note that there is also a "hidden" logging box (and associated code), following the pattern in the [Display a single entry log](/en-US/docs/MDN/Writing_guidelines/Page_structures/Live_samples#displaying_a_single_entry_log) guide for writing live samples.

```css hidden
#log {
  height: 50px;
  padding: 0.5rem;
  margin: 5px;
  border: 1px solid black;
}
```

```html hidden
<pre id="log"></pre>
```

### JavaScript

```js hidden
const logElement = document.querySelector("#log");

function log(text) {
  logElement.innerText = text;
}
```

The code checks whether the `direction` property is defined, and if so, adds a listener for the [`selectionchange` event](/en-US/docs/Web/API/Document/selectionchange_event), which gets the current selection and logs its direction.
If the property is not supported, the code logs this fact and hides the text for selection.

```js
const input = document.getElementById("text-box");

if ("direction" in Selection.prototype) {
  document.addEventListener("selectionchange", () => {
    const selection = window.getSelection();
    log(`Selection direction: ${selection.direction}`);
  });
} else {
  log("direction property not defined");
  input.hidden = true;
}
```

### Result

If the property is supported, select text using double click, and select-drag-release in different directions.

{{EmbedLiveSample("Examples")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}
# Selection: empty() method

{{ ApiRef("DOM") }}

The **`Selection.empty()`** method removes all ranges from the selection, leaving the {{domxref("Selection.anchorNode", "anchorNode")}} and {{domxref("Selection.focusNode","focusNode")}} properties equal to `null` and nothing selected. When this method is called, a {{domxref("Document/selectionchange_event", "selectionchange")}} event is fired at the document.

> [!NOTE]
> This method is an alias for the {{domxref("Selection.removeAllRanges()")}} method.

## Syntax

```js-nolint
empty()
```

### Parameters

None.

### Return value

None ({{jsxref("undefined")}}).

## Examples

This example displays a message when something is selected on the page or not. It does this by listening to the {{domxref("Document/selectionchange_event", "selectionchange")}} event on the document. There also is a button that clears any selection by calling `Selection.empty()`. When this happens, the selection is changed and the message is updated.

```html
<p>
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse laoreet
  urna eget sapien venenatis, eget facilisis diam mattis.
</p>
<button>Clear selection</button>
<pre id="log"></pre>
```

```js
const log = document.getElementById("log");

// The selection object is a singleton associated with the document
const selection = document.getSelection();

// Logs if there is a selection or not
function newSelectionHandler() {
  if (selection.rangeCount !== 0) {
    log.textContent = "Some text is selected.";
  } else {
    log.textContent = "No selection on this document.";
  }
}

document.addEventListener("selectionchange", () => {
  newSelectionHandler();
});

newSelectionHandler();

// The button cancel all selection ranges
const button = document.querySelector("button");
button.addEventListener("click", () => {
  selection.empty();
});
```

{{EmbedLiveSample("Examples", "100%", "200px")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection.removeAllRanges()")}}
- {{domxref("Document/selectionchange_event", "selectionchange")}}
# Selection: extend() method

{{ ApiRef("DOM") }}

The **`Selection.extend()`** method moves the focus of the
selection to a specified point. The anchor of the selection does not move. The selection
will be from the anchor to the new focus, regardless of direction.

## Syntax

```js-nolint
extend(node)
extend(node, offset)
```

### Parameters

- `node`
  - : The node within which the focus will be moved.
- `offset` {{optional_inline}}
  - : The offset position within `node` where the focus will be moved to. If
    not specified, the default value `0` is used.

### Return value

None ({{jsxref("undefined")}}).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}, the interface it belongs to.
# Selection: focusNode property

{{ ApiRef("DOM") }}

The **`Selection.focusNode`** read-only property returns the {{domxref("Node")}} in which the selection ends. It can return `null` if selection never existed in the document (e.g., an iframe that was never clicked on, or the node belongs to another document tree).

A user may make a selection from left to right (in document order) or right to left (reverse of document order). The focus is where the user ended the selection. This can be visualized by holding the <kbd>Shift</kbd> key and pressing the arrow keys on your keyboard. The selection's focus moves, but the selection's anchor, the other end of the selection, does not move.

## Value

A {{domxref("Node")}} object or `null`.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}
- {{domxref("Selection.anchorNode")}}
# Selection: focusOffset property

{{ ApiRef("DOM") }}

The **`Selection.focusOffset`** read-only property returns the
number of characters that the selection's focus is offset within the
{{domxref("Selection.focusNode")}} if said node is of type {{domxref("Text")}}, {{domxref("CDATASection")}} or {{domxref("Comment")}}.

In the case of {{domxref("Selection.focusNode")}} being another type of node, **`Selection.focusOffset`** returns the number of {{domxref("Node.childNodes")}} the selection's focus is offset within the {{domxref("Selection.focusNode")}}.

This number is zero-based. If the selection ends with the first character in the
{{domxref("Selection.focusNode")}}, `0` is returned.

## Value

A number.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}, the interface it belongs to.
# Selection: getComposedRanges() method

{{ ApiRef("DOM") }}

The **`Selection.getComposedRanges()`** method returns an array of {{domxref("StaticRange")}} objects representing the current selection ranges, and can return ranges that potentially cross shadow boundaries.

As the selection range endpoints may be within a shadow tree, or even different shadow trees, and because these may be closed, the method cannot by default return nodes from within a shadow tree.
If the method needs to return a selection that includes nodes inside shadow trees, then the {{domxref("ShadowRoot")}} objects for these trees must be passed as arguments to the method.
If a corresponding roots are not provided and the start or endpoint of the selection are within a shadow tree, the returned range is re-scoped to include the host of the shadow root rather than some node with in the root.

The returned ranges represent the range at the time that `getComposedRanges()` was called.
If the DOM or a shadow DOM is mutated, the selected range is likely to be incorrect.
Application code might use a {{domxref("MutationObserver")}} to monitor for DOM mutations and then call {{domxref("Selection.setBaseAndExtent()")}} to update the selection.

> [!NOTE]
> This method should be used instead of {{domxref("Selection.getRangeAt()")}} when selecting ranges that can potentially cross shadow root boundaries.
> {{domxref("Selection.getRangeAt()")}} is not aware of shadow roots.
> The returned range is not specified, and varies between browsers.

## Syntax

```js-nolint
getComposedRanges()
getComposedRanges(options)
```

### Parameters

- `options` {{optional_inline}}
  - : An object with the following properties, all optional:
    - `shadowRoots` {{optional_inline}}
      - : An array of {{domxref("ShadowRoot")}} objects.
        If a selection endpoint is within one of the provided shadow roots, the range will be able to return nodes within its corresponding Shadow DOM tree.
        Otherwise, if the selection crosses a shadow boundary and the corresponding `ShadowRoot` is not provided, the returned range will be adjusted to include the entire host element for the shadow root.

> [!NOTE]
> In the original specification, shadow roots were specified as a set of [rest parameters](/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters). Some browsers may still support this legacy syntax.

### Return value

An array of {{domxref("StaticRange")}} objects that represent the selected ranges within the composed (flattened) tree of the document.
At time of writing the specification expects this array to only contain one object.

## Examples

### Selecting across inline shadow roots

This example demonstrates how `getComposedRanges()` behaves, both when shadow roots are passed and when they are not, and contrasts with {{domxref("Selection.getRangeAt()")}}.

It allows you to select text that is defined in different nodes in the DOM, and in open and closed shadow roots, copy the range for the selection using the different approaches, and then reapply the range to see how well the original selection worked.

#### HTML

The HTML defines some text nodes with some `<span>` elements to which we'll attach a shadow root using JavaScript.
We also add some buttons for copying and applying the selection using a number of different methods.

```html
<p>
  DOM Text One<span id="openHost"></span>DOM Text Two<span
    id="closedHost"></span
  >DOM Text Three
</p>
```

```html
<button id="copySelection">Copy range not passing shadow roots</button>
<button id="copySelectionWithShadowRoots">
  Copy range passing shadow roots
</button>
<button id="applySelection">Apply selection</button>
<hr />
<button id="copySelectionRangeAt">Copy range with getRangeAt()</button>
<button id="applySelectionGetRangeAt">Apply selection</button>
```

#### CSS

The CSS doesn't do anything interesting.
We're just laying out the buttons vertically so that they are easier to read.

```css
button {
  display: block;
}
```

```css hidden
#log {
  height: 20px;
  padding: 0.5rem;
  border: 1px solid black;
}
```

#### JavaScript

```js hidden
const logElement = document.querySelector("#log");
function log(text) {
  logElement.innerText = text;
}
```

Most of the work happens in the JavaScript.
First we log if the `getComposedRanges()` is not supported, though we don't actually prevent the rest of the example attempting to use it.

```js
if (!("getComposedRanges" in Selection.prototype)) {
  log("getComposedRanges() method not supported in this browser");
}
```

Then we create an open and a closed shadow root and attach them to the two `<span>` elements we created in the HTML.
These contain some simple text in bold so that we can easily identify the shadow nodes when the HTML is rendered.

```js
let openRoot = openHost.attachShadow({ mode: "open" });
openRoot.innerHTML = `<b>Open Shadow DOM Text</b>`;

let closedRoot = closedHost.attachShadow({ mode: "closed" });
closedRoot.innerHTML = `<b>Closed Shadow DOM Text</b>`;
```

Next we create code to get the selected ranges with `getComposedRanges()` when the first two buttons are clicked.
The first button calls `getComposedRanges()` without passing shadow roots, while the second passes both of the shadow roots.
In both cases the composed range is saved to a variable.

```js
const copySelectionButton = document.querySelector("#copySelection");
let composedRangeSelection = null;
copySelectionButton.addEventListener("click", () => {
  composedRangeSelection = window.getSelection().getComposedRanges()[0];
  log(`Selection copied (no shadow roots passed)`);
});

const copySelectionWithShadowRootsButton = document.querySelector(
  "#copySelectionWithShadowRoots",
);
copySelectionWithShadowRootsButton.addEventListener("click", () => {
  composedRangeSelection = window
    .getSelection()
    .getComposedRanges({ shadowRoots: [openRoot, closedRoot] })[0];
  log(`Selection has been copied (shadow roots passed)`);
});
```

The handler for the "Apply selection" button is shown below.
This calls {{domxref("Selection.setBaseAndExtent()", "setBaseAndExtent()")}} to set the current selection, passing the nodes and offsets from the saved range.

```js
const applySelectionButton = document.querySelector("#applySelection");
applySelectionButton.addEventListener("click", () => {
  if (composedRangeSelection) {
    window
      .getSelection()
      .setBaseAndExtent(
        composedRangeSelection.startContainer,
        composedRangeSelection.startOffset,
        composedRangeSelection.endContainer,
        composedRangeSelection.endOffset,
      );
    log(`Selection applied`);
  } else {
    log(`No selection to apply`);
  }
});
```

The last part of the code defines buttons to copy the current selection range using {{domxref("Selection.getRangeAt()")}} and then reapply the selection.

```js
const copySelectionRangeAtButton = document.querySelector(
  "#copySelectionRangeAt",
);
let rangeSelection = null;
copySelectionRangeAtButton.addEventListener("click", () => {
  const selection = window.getSelection();
  if (selection.rangeCount > 0) {
    log(`Selection copied using getRangeAt()`);
    rangeSelection = selection.getRangeAt(0);
  } else {
    log(`No range selected`);
  }
});

const applySelectionGetRangeAtButton = document.querySelector(
  "#applySelectionGetRangeAt",
);
applySelectionGetRangeAtButton.addEventListener("click", () => {
  if (rangeSelection) {
    window
      .getSelection()
      .setBaseAndExtent(
        rangeSelection.startContainer,
        rangeSelection.startOffset,
        rangeSelection.endContainer,
        rangeSelection.endOffset,
      );
    log(`Selection applied`);
  } else {
    log(`No selection to apply`);
  }
});
```

```html hidden
<pre id="log"></pre>
```

#### Results

The running example is shown below.
Select text in the top line starting from some normal text and ending in a bold section so that you have selected nodes from the DOM into a shadow root.
If you select "Copy range passing shadow roots" and then the "Apply selection" button, you will note that the selection doesn't change, because the code has given access to all the nodes in the shadow root, even if it is closed.
If you then select the button "Copy range not passing shadow roots" and then apply, the selection will extend to the end of the text in the shadow root.
This is because the selection is re-scoped to the end of the host node, since the `getComposedRanges()` method was not given visibility inside the shadow tree.

Also test what happens if you use the "Copy range with getRangeAt()" and "Apply selection" buttons.
You should find that the selected range is fairly arbitrary if you cross into the shadow root, and differs depending on what browser you are using.

{{EmbedLiveSample('Selecting across inline shadow roots', '100%', '240px')}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}, the interface it belongs to.
# Selection: getRangeAt() method

{{ ApiRef("DOM") }}

The **`getRangeAt()`** method of the {{domxref("Selection")}} interface returns a range object representing a currently selected range.

If the endpoints of the selected range are within a {{glossary("shadow tree")}} then JavaScript does not have visibility of the shadow nodes, and the method should re-scope the range to include the host element that contains the end point.
In practice most browsers do not yet implement this behavior, and the returned range is unpredictable.

> [!NOTE]
> When selecting within nodes that might contain a shadow root, you can use {{domxref("Selection.getComposedRanges()")}} (if supported) to get a selection range inside a shadow tree, or to reliably re-scope the selection to the host node.

## Syntax

```js-nolint
getRangeAt(index)
```

### Parameters

- `index`
  - : The zero-based index of the range to return.
    A negative number or a number greater than or equal to {{domxref("Selection.rangeCount")}} will result in an error.

### Return value

The specified {{domxref("Range")}} object.

## Examples

```js
let ranges = [];

sel = window.getSelection();

for (let i = 0; i < sel.rangeCount; i++) {
  ranges[i] = sel.getRangeAt(i);
}
/* Each item in the ranges array is now
 * a range object representing one of the
 * ranges in the current selection */
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}, the interface it belongs to.
# Selection

{{ApiRef("Selection API")}}

A **`Selection`** object represents the range of text selected by the user or the current position of the caret. Each {{domxref("document")}} is associated with a unique selection object, which can be retrieved by {{DOMxRef("document.getSelection()")}} or {{domxref("window.getSelection()")}} and then be examined and modified.

A user may make a selection from left to right (in document order) or right to left (reverse of document order). The **_anchor_** is where the user began the selection and the **_focus_** is where the user ends the selection. If you make a selection with a desktop mouse, the anchor is placed where you pressed the mouse button, and the focus is placed where you released the mouse button.

> [!NOTE]
> _Anchor_ and _focus_ should not be confused with the _start_ and _end_ positions of a selection. The anchor can be placed before the focus or vice versa, depending on the direction you made your selection.

## Instance properties

- {{DOMxRef("Selection.anchorNode")}} {{ReadOnlyInline}}
  - : Returns the {{DOMxRef("Node")}} in which the selection begins. Can return `null` if selection never existed in the document (e.g., an iframe that was never clicked on).
- {{DOMxRef("Selection.anchorOffset")}} {{ReadOnlyInline}}
  - : Returns a number representing the offset of the selection's anchor within the `anchorNode`. If `anchorNode` is a text node, this is the number of characters within anchorNode preceding the anchor. If `anchorNode` is an element, this is the number of child nodes of the `anchorNode` preceding the anchor.
- {{DOMxRef("Selection.direction")}} {{ReadOnlyInline}}
  - : A string describing the direction of the current selection.
- {{DOMxRef("Selection.focusNode")}} {{ReadOnlyInline}}
  - : Returns the {{DOMxRef("Node")}} in which the selection ends. Can return `null` if selection never existed in the document (e.g., an iframe that was never clicked on).
- {{DOMxRef("Selection.focusOffset")}} {{ReadOnlyInline}}
  - : Returns a number representing the offset of the selection's focus within the `focusNode`. If `focusNode` is a text node, this is the number of characters within `focusNode` preceding the focus. If `focusNode` is an element, this is the number of child nodes of the `focusNode` preceding the focus.
- {{DOMxRef("Selection.isCollapsed")}} {{ReadOnlyInline}}
  - : Returns a Boolean indicating whether the selection's start and end points are at the same position.
- {{DOMxRef("Selection.rangeCount")}} {{ReadOnlyInline}}
  - : Returns the number of ranges in the selection.
- {{DOMxRef("Selection.type")}} {{ReadOnlyInline}}
  - : Returns a string describing the type of the current selection.

## Instance methods

- {{DOMxRef("Selection.addRange()")}}
  - : A {{DOMxRef("Range")}} object that will be added to the selection.
- {{DOMxRef("Selection.collapse()")}}
  - : Collapses the current selection to a single point.
- {{DOMxRef("Selection.collapseToEnd()")}}
  - : Collapses the selection to the end of the last range in the selection.
- {{DOMxRef("Selection.collapseToStart()")}}
  - : Collapses the selection to the start of the first range in the selection.
- {{DOMxRef("Selection.containsNode()")}}
  - : Indicates if a certain node is part of the selection.
- {{DOMxRef("Selection.deleteFromDocument()")}}
  - : Deletes the selection's content from the document.
- {{DOMxRef("Selection.empty()")}}
  - : Removes all ranges from the selection, leaving the {{domxref("Selection.anchorNode", "anchorNode")}} and {{domxref("Selection.focusNode","focusNode")}} properties equal to `null` and nothing selected.
- {{DOMxRef("Selection.extend()")}}
  - : Moves the focus of the selection to a specified point.
- {{DOMxRef("Selection.getComposedRanges()")}}
  - : Returns an array of {{DOMxRef("StaticRange")}} objects, each that represents a selection that might cross shadow DOM boundaries.
- {{DOMxRef("Selection.getRangeAt()")}}
  - : Returns a {{DOMxRef("Range")}} object representing one of the ranges currently selected.
- {{DOMxRef("Selection.modify()")}}
  - : Changes the current selection.
- {{DOMxRef("Selection.removeRange()")}}
  - : Removes a range from the selection.
- {{DOMxRef("Selection.removeAllRanges()")}}
  - : Removes all ranges from the selection.
- {{DOMxRef("Selection.selectAllChildren()")}}
  - : Adds all the children of the specified node to the selection.
- {{DOMxRef("Selection.setBaseAndExtent()")}}
  - : Sets the selection to be a range including all or parts of two specified DOM nodes, and any content located between them.
- {{DOMxRef("Selection.setPosition()")}}
  - : Collapses the current selection to a single point.
- {{DOMxRef("Selection.toString()")}}
  - : Returns a string currently being represented by the selection object, i.e., the currently selected text.

## Notes

### String representation of a selection

Calling the {{DOMxRef("Selection.toString()")}} method returns the text contained within the selection, e.g.:

```js
const selObj = window.getSelection();
window.alert(selObj);
```

Note that using a selection object as the argument to `window.alert` will call the object's `toString` method.

### Multiple ranges in a selection

A selection object represents the {{DOMxRef("Range")}}s that the user has selected. Typically, it holds only one range, accessed as follows:

```js
const selObj = window.getSelection();
const range = selObj.getRangeAt(0);
```

- `selObj` is a Selection object
- `range` is a {{DOMxRef("Range")}} object

As the [Selection API specification notes](https://w3c.github.io/selection-api/#h-note-13), the Selection API was initially created by Netscape and allowed multiple ranges (for instance, to allow the user to select a column from a {{HTMLElement("table")}}). However, browsers other than Gecko did not implement multiple ranges, and the specification also requires the selection to always have a single range.

### Selection and input focus

Selection and input focus (indicated by {{DOMxRef("Document.activeElement")}}) have a complex relationship that varies by browser. In cross-browser compatible code, it's better to handle them separately.

Safari and Chrome (unlike Firefox) currently focus the element containing selection when modifying the selection programmatically; it's possible that this may change in the future (see [W3C bug 14383](https://www.w3.org/Bugs/Public/show_bug.cgi?id=14383) and [WebKit bug 38696](https://webkit.org/b/38696)).

### Behavior of Selection API in terms of editing host focus changes

The Selection API has a common behavior (i.e., shared between browsers) that governs how focus behavior changes for _editing hosts_ after certain methods are called.

The behavior is as follows:

1. An editing host gains focus if the previous selection was outside of it.
2. A Selection API method is called, causing a new selection to be made with the selection range inside the editing host.
3. Focus then moves to the editing host.

> [!NOTE]
> The Selection API methods may only move focus to an editing host, not to other focusable elements (e.g., {{HTMLElement("a")}}).

The above behavior applies to selections made using the following methods:

- {{DOMxRef("Selection.collapse()")}}
- {{DOMxRef("Selection.collapseToStart()")}}
- {{DOMxRef("Selection.collapseToEnd()")}}
- {{DOMxRef("Selection.extend()")}}
- {{DOMxRef("Selection.selectAllChildren()")}}
- {{DOMxRef("Selection.addRange()")}}
- {{DOMxRef("Selection.setBaseAndExtent()")}}

And when the {{DOMxRef("Range")}} is modified using the following methods:

- {{DOMxRef("Range.setStart()")}}
- {{DOMxRef("Range.setEnd()")}}
- {{DOMxRef("Range.setStartBefore()")}}
- {{DOMxRef("Range.setStartAfter()")}}
- {{DOMxRef("Range.setEndBefore()")}}
- {{DOMxRef("Range.setEndAfter()")}}
- {{DOMxRef("Range.collapse()")}}
- {{DOMxRef("Range.selectNode()")}}
- {{DOMxRef("Range.selectNodeContents()")}}

### Glossary

Other key terms used in this section.

- anchor
  - : The anchor of a selection is the beginning point of the selection. When making a selection with a mouse, the anchor is where in the document the mouse button is initially pressed. As the user changes the selection using the mouse or the keyboard, the anchor does not move.
- editing host
  - : An editable element (e.g., an HTML element with [`contenteditable`](/en-US/docs/Web/HTML/Reference/Global_attributes/contenteditable) set, or the HTML child of a document that has {{DOMxRef("Document.designMode", "designMode")}} enabled).
- focus of a selection
  - : The _focus_ of a selection is the end point of the selection. When making a selection with a mouse, the focus is where in the document the mouse button is released. As the user changes the selection using the mouse or the keyboard, the focus is the end of the selection that moves.

    > [!NOTE]
    > This is not the same as the focused _element_ of the document, as returned by {{DOMxRef("document.activeElement")}}.

- range
  - : A _range_ is a contiguous part of a document. A range can contain entire nodes as well as portions of nodes (such as a portion of a text node). A user will normally only select a single range at a time, but it's possible for a user to select multiple ranges (e.g., by using the <kbd>Control</kbd> key). A range can be retrieved from a selection as a {{DOMxRef("range")}} object. Range objects can also be created via the DOM and programmatically added or removed from a selection.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{DOMxRef("Window.getSelection")}}, {{DOMxRef("Document.getSelection")}}, {{DOMxRef("Range")}}
- Selection-related events: {{domxref("Document/selectionchange_event", "selectionchange")}} and {{domxref("Node/selectstart_event", "selectstart")}}
- HTML inputs provide simpler helper APIs for working with selection (see {{DOMxRef("HTMLInputElement.setSelectionRange()")}})
- {{DOMxRef("Document.activeElement")}}, {{DOMxRef("HTMLElement.focus")}}, and {{DOMxRef("HTMLElement.blur")}}
# Selection: isCollapsed property

{{ ApiRef("DOM") }}

The **`Selection.isCollapsed`** read-only property returns a
boolean value which indicates whether or not there is currently any text
selected. No text is selected when the selection's start and end points are at the same
position in the content.

Keep in mind that a collapsed selection may still have one (or more, in Gecko)
{{domxref("Range")}}s, so {{domxref("Selection.rangeCount")}} may not be zero. In that
scenario, calling a {{domxref("Selection")}} object's {{domxref("Selection.getRangeAt", "getRangeAt()")}}
method may return a `Range` object which is collapsed.

## Value

A boolean.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}
- {{domxref("Range")}}
# Selection: modify() method

{{APIRef("DOM")}}

The **`Selection.modify()`** method applies a change to the
current selection or cursor position, using simple textual commands.

## Syntax

```js-nolint
modify(alter, direction, granularity)
```

### Parameters

- `alter`
  - : The type of change to apply. Specify `"move"` to move the current cursor
    position or `"extend"` to extend the current selection.
- `direction`
  - : The direction in which to adjust the current selection. You can specify
    `"forward"` or `"backward"` to adjust in the appropriate
    direction based on the language at the selection point. If you want to adjust in a
    specific direction, you can specify `"left"` or `"right"`.
- `granularity`
  - : The distance to adjust the current selection or cursor position. You can move by
    `"character"`, `"word"`, `"sentence"`,
    `"line"`, `"paragraph"`, `"lineboundary"`,
    `"sentenceboundary"`, `"paragraphboundary"`, or
    `"documentboundary"`.

> [!NOTE]
> Firefox does **not** implement
> `"sentence"`, `"paragraph"`, `"sentenceboundary"`,
> `"paragraphboundary"`, or `"documentboundary"`. WebKit and Blink
> do.

> [!NOTE]
> Starting in Firefox 5, the `"word"`
> granularity no longer includes the following space, regardless of the default platform
> behavior. This makes the behavior more consistent, as well as making it work the same
> way WebKit used to work, but unfortunately they have recently changed their behavior.

### Return value

None ({{jsxref("undefined")}}).

## Examples

This example demonstrates the various `granularity` options for modifying a
selection. Click somewhere inside the example (optionally selecting some text), and then
click the button to expand the selection.

### HTML

```html
<p>
  Click somewhere in this example. Then click the button below to expand the
  selection. Watch what happens!
</p>
<p>
  Et harum quidem rerum facilis est et expedita distinctio. Nam libero tempore,
  cum soluta nobis est eligendi optio cumque nihil impedit quo minus id quod
  maxime placeat facere possimus, omnis voluptas assumenda est, omnis dolor
  repellendus.
</p>

<label for="granularity">Granularity:</label>
<select id="granularity">
  <option value="character">Character</option>
  <option value="word">Word</option>
  <option value="sentence">Sentence</option>
  <option value="line">Line</option>
  <option value="paragraph">Paragraph</option>
  <option value="lineboundary">Line Boundary</option>
  <option value="sentenceboundary">Sentence Boundary</option>
  <option value="paragraphboundary">Paragraph Boundary</option>
  <option value="documentboundary">Document Boundary</option>
</select>

<br /><br />

<button>Extend selection</button>
```

### JavaScript

```js
let select = document.querySelector("select");
let button = document.querySelector("button");

button.addEventListener("click", modify);

function modify() {
  let selection = window.getSelection();
  selection.modify("extend", "forward", select.value);
}
```

### Result

{{EmbedLiveSample("Examples", 700, 200)}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{DOMxRef("Selection")}}, the interface it belongs to.
# Selection: rangeCount property

{{ ApiRef("DOM") }}

The **`Selection.rangeCount`** read-only property returns the
number of ranges in the selection.

Before the user has clicked a freshly loaded page, the `rangeCount` is
`0`. After the user clicks on the page, `rangeCount` is
`1`, even if no selection is visible.

A user can normally only select one range at a time, so the `rangeCount`
will usually be `1`. Scripting can be used to make the selection contain more
than one range.

Gecko browsers allow multiple selections across table cells. Firefox allows to select
multiple ranges in the document by using Ctrl+click (unless the click occurs within an
element that has the `display: table-cell` CSS property assigned).

## Value

A number.

## Examples

The following example will show the `rangeCount` every second. Select text
in the browser to see it change.

### HTML

```html
<table>
  <tr>
    <td>a.1</td>
    <td>a.2</td>
  </tr>
  <tr>
    <td>b.1</td>
    <td>b.2</td>
  </tr>
  <tr>
    <td>c.1</td>
    <td>c.2</td>
  </tr>
</table>
```

### JavaScript

```js
setInterval(() => {
  console.log(window.getSelection().rangeCount);
}, 1000);
```

### Result

Open your console to see how many ranges are in the selection. In Gecko browsers, you
can select multiple ranges across table cells by holding down <kbd>Ctrl</kbd> (or <kbd>Cmd</kbd> on macOS) while
dragging with the mouse.

{{EmbedLiveSample("Examples")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}, the interface it belongs to.
# Selection: removeAllRanges() method

{{ ApiRef("DOM") }}

The **`Selection.removeAllRanges()`** method removes all ranges from the selection, leaving the {{domxref("Selection.anchorNode", "anchorNode")}} and {{domxref("Selection.focusNode","focusNode")}} properties equal to `null` and nothing selected. When this method is called, a {{domxref("Document/selectionchange_event", "selectionchange")}} event is fired at the document.

> [!NOTE]
> This method is an alias for the {{domxref("Selection.empty()")}} method.

## Syntax

```js-nolint
removeAllRanges()
```

### Parameters

None.

### Return value

None ({{jsxref("undefined")}}).

## Examples

This example displays a message when something is selected on the page or not. It does this by listening to the {{domxref("Document/selectionchange_event", "selectionchange")}} event on the document. There also is a button that clears any selection by calling `Selection.removeAllRanges()`. When this happens, the selection is changed and the message is updated.

```html
<p>
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse laoreet
  urna eget sapien venenatis, eget facilisis diam mattis.
</p>
<button>Clear selection</button>
<pre id="log"></pre>
```

```js
const log = document.getElementById("log");

// The selection object is a singleton associated with the document
const selection = document.getSelection();

// Logs if there is a selection or not
function newSelectionHandler() {
  if (selection.rangeCount !== 0) {
    log.textContent = "Some text is selected.";
  } else {
    log.textContent = "No selection on this document.";
  }
}

document.addEventListener("selectionchange", () => {
  newSelectionHandler();
});

newSelectionHandler();

// The button cancel all selection ranges
const button = document.querySelector("button");
button.addEventListener("click", () => {
  selection.removeAllRanges();
});
```

{{EmbedLiveSample("Examples", "100%", "200px")}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection.empty()")}}
- {{domxref("Document/selectionchange_event", "selectionchange")}}
# Selection: removeRange() method

{{ ApiRef("DOM") }}

The **`Selection.removeRange()`** method removes a range from a
selection.

## Syntax

```js-nolint
removeRange(range)
```

### Parameters

- `range`
  - : A range object that will be removed from the selection.

### Return value

None ({{jsxref("undefined")}}).

## Examples

```js
/* Programmatically, more than one range can be selected.
 * This will remove all ranges except the first. */
const s = window.getSelection();
if (s.rangeCount > 1) {
  for (let i = 1; i < s.rangeCount; i++) {
    s.removeRange(s.getRangeAt(i));
  }
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}, the interface it belongs to.
# Selection: selectAllChildren() method

{{ ApiRef("DOM") }}

The **`Selection.selectAllChildren()`** method adds all the
children of the specified node to the selection. Previous selection is lost.

## Syntax

```js-nolint
selectAllChildren(parentNode)
```

### Parameters

- `parentNode`
  - : All children of `parentNode` will be selected. `parentNode`
    itself is not part of the selection.

### Return value

None ({{jsxref("undefined")}}).

## Examples

### HTML

```html
<main>
  <button>Select Footer</button>
  <p>Welcome to my website.</p>
  <p>I hope you enjoy your visit.</p>
</main>
<footer>
  <address>webmaster@example.com</address>
  <p>© 2019</p>
</footer>
```

### JavaScript

```js
const button = document.querySelector("button");
const footer = document.querySelector("footer");

button.addEventListener("click", (e) => {
  window.getSelection().selectAllChildren(footer);
});
```

### Result

{{EmbedLiveSample("Examples", 700, 200)}}

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}, the interface it belongs to.
# Selection: setBaseAndExtent() method

{{ ApiRef("DOM") }}

The **`setBaseAndExtent()`** method of the {{domxref("Selection")}} interface sets the selection to be a range including all or parts of two specified DOM nodes, and any content located between them.

The anchor and focus nodes can be located in a {{glossary("shadow tree")}}, if supported by the browser.

## Syntax

```js-nolint
setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset)
```

### Parameters

- `anchorNode`
  - : The node at the start of the selection.
- `anchorOffset`
  - : The number of child nodes from the start of the anchor node that should be excluded from the selection.
    So for example, if the value is 0 the whole node is included.
    If the value is 1, the whole node minus the first child node is included.
    And so on.

    If `anchorNode` is a {{domxref("Text")}} node, the offset refers to the number of characters from the start of the {{domxref("Node.textContent")}} that should be excluded from the selection.

- `focusNode`
  - : The node at the end of the selection.
- `focusOffset`
  - : The number of child nodes from the start of the focus node that should be included in the selection.
    So for example, if the value is 0 the whole node is excluded.
    If the value is 1, the first child node is included. And so on.

    If `focusNode` is a {{domxref("Text")}} node, the offset refers to the number of characters from the start of the {{domxref("Node.textContent")}} that should be included in the selection.

> [!NOTE]
> If the focus position appears before the anchor position in the document, the direction of the selection is reversed — the caret is placed at the beginning of the text rather the end, which matters for any keyboard command that might follow.
> For example, <kbd>Shift</kbd> + <kbd>➡︎</kbd> would cause the selection to narrow from the beginning rather than grow at the end.

### Return value

None ({{jsxref("undefined")}}).

### Exceptions

- `IndexSizeError` {{domxref("DOMException")}}
  - : Thrown if `anchorOffset` is larger than the number of child nodes inside `anchorNode`, or if `focusOffset` is larger than the number of child nodes inside `focusNode`.

## Examples

In this example, we have two paragraphs containing spans, each one containing a single word.
The first one is set as the `anchorNode` and the second is set as the `focusNode`.
We also have an additional paragraph that sits in between the two nodes.

Next, we have two form inputs that allow you to set the `anchorOffset` and `focusOffset` — they both have a default value of 0.

We also have a button that when pressed invokes a function that runs the `setBaseAndExtent()` method with the specified offsets, and copies the selection into the output paragraph at the very bottom of the HTML.

```html
<h1>setBaseAndExtent example</h1>
<div>
  <p class="one">
    <span>Fish</span><span>Dog</span><span>Cat</span><span>Bird</span>
  </p>
  <p>MIDDLE</p>
  <p class="two">
    <span>Car</span><span>Bike</span><span>Boat</span><span>Plane</span>
  </p>
</div>

<div>
  <p>
    <label for="aOffset">Anchor offset</label>
    <input id="aOffset" name="aOffset" type="number" value="0" />
  </p>
  <p>
    <label for="fOffset">Focus offset</label>
    <input id="fOffset" name="fOffset" type="number" value="0" />
  </p>
  <p><button>Capture selection</button></p>
</div>

<p><strong>Output</strong>: <span class="output"></span></p>
```

> [!NOTE]
> There is intentionally no [whitespace](/en-US/docs/Web/CSS/CSS_text/Whitespace#working_with_whitespace_in_the_dom) between the `<p class="one">` and `<p class="two">` start tags and the `<span>` start tags which follow them — to avoid the presence of text nodes that would affect the number of child nodes expected. (Even though those text nodes would be whitespace-only, they would still be additional child nodes; find out more from the [`Node.firstChild` example](/en-US/docs/Web/API/Node/firstChild#example)).

The JavaScript looks like so:

```js
const one = document.querySelector(".one");
const two = document.querySelector(".two");

const aOffset = document.getElementById("aOffset");
const fOffset = document.getElementById("fOffset");

const button = document.querySelector("button");

const output = document.querySelector(".output");

let selection;

button.onclick = () => {
  try {
    selection = document.getSelection();
    selection.setBaseAndExtent(one, aOffset.value, two, fOffset.value);
    const text = selection.toString();
    output.textContent = text;
  } catch (e) {
    output.textContent = e.message;
  }
};
```

Play with the live example below, setting different offset values to see how this affects the selection.

{{ EmbedLiveSample('Examples', '100%', 370) }}

> [!NOTE]
> You can find this [example on GitHub](https://github.com/chrisdavidmills/selection-api-examples/blob/master/setBaseAndExtent.html) ([see it live also](https://chrisdavidmills.github.io/selection-api-examples/setBaseAndExtent.html).)

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}
# Selection: setPosition() method

{{ApiRef("DOM")}}

The **`Selection.setPosition()`** method collapses the current selection to a single point. The document is not modified. If the content is focused and editable, the caret will blink there.

> [!NOTE]
> This method is an alias for the {{domxref("Selection.collapse()")}} method.

## Syntax

```js-nolint
setPosition(node)
setPosition(node, offset)
```

### Parameters

- `node`
  - : The caret location will be within this node. This value can also be set to
    `null` — if `null` is specified, the method will behave like
    {{domxref("Selection.removeAllRanges()")}}, i.e., all ranges will be removed from the
    selection.
- `offset` {{optional_inline}}
  - : The offset in `node` to which the selection will be collapsed. If not
    specified, the default value `0` is used.

### Return value

None ({{jsxref("undefined")}}).

## Examples

```js
// Place the caret at the beginning of an HTML document's body.
const body = document.querySelector("body");
window.getSelection().setPosition(body, 0);
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection.collapse()")}}
# Selection: toString() method

{{ ApiRef("DOM") }}

The **`Selection.toString()`** method returns a string
currently being represented by the selection object, i.e., the currently selected text.

## Syntax

```js-nolint
toString()
```

### Parameters

None.

### Return value

A string representing the selection.

## Description

This method returns the currently selected text.

In [JavaScript](/en-US/docs/Web/JavaScript), this method is called automatically when
a function the selection object is passed to requires a string:

```js
alert(window.getSelection()); // What is called
alert(window.getSelection().toString()); // What is actually being effectively called.
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}, the interface it belongs to.
# Selection: type property

{{APIRef("DOM")}}

The **`type`** read-only property of the
{{domxref("Selection")}} interface returns a string describing the
type of the current selection.

## Value

A string describing the type of the current selection. Possible
values are:

- `None`
  - : No selection has currently been made.
- `Caret`
  - : The selection is collapsed (i.e., the caret is placed on some
    text, but no range has been selected).
- `Range`
  - : A range has been selected.

## Examples

In this example, the event handler will fire each time a new selection is made.
`console.log(selection.type)` will return `Caret` or
`Range` depending on whether the caret is placed at a single point in the
text, or a range has been selected.

```js
let selection;

document.onselectionchange = () => {
  console.log("New selection made");
  selection = document.getSelection();
  console.log(selection.type);
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("Selection")}}
# Sensor: activate event

{{securecontext_header}}{{APIRef("Sensor API")}}

The **`activate`** event is fired when a sensor becomes activated. It means that it will start obtaining readings.

The {{domxref('Sensor')}} interface is a base class, `onactivate` and the `activate` event may only be used
on one of the [derived classes](/en-US/docs/Web/API/Sensor#interfaces_based_on_sensor).

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("activate", (event) => { })

onactivate = (event) => { }
```

## Event type

A generic {{domxref("Event")}} with no added properties.

## Examples

### Log when an accelerometer is ready to measure

This example adds an event listener to log the activation of an {{domxref("Accelerometer")}}.

```js
const acl = new Accelerometer({ frequency: 60 });
acl.addEventListener("activate", () => console.log("Ready to measure."));
acl.start();
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- Sensor {{domxref('Sensor.error_event', 'error')}} event
- Sensor {{domxref('Sensor.reading_event', 'reading')}} event
# Sensor: activated property

{{securecontext_header}}{{APIRef("Sensor API")}}

The **`activated`** read-only property
of the {{domxref("Sensor")}} interface returns a boolean value indicating
whether the sensor is active.

Because {{domxref('Sensor')}} is a base class, `activated` may only be read
from one of its derived classes.

## Value

A boolean value.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sensor APIs

{{securecontext_header}}{{DefaultAPISidebar("Sensor API")}}

The **Sensor APIs** are a set of interfaces built to a common design that expose device sensors in a consistent way to the web platform.

## Concepts and usage

Although the Generic Sensor API specification defines a {{domxref('Sensor')}} interface, as a web developer you will never use it. Instead you'll use one of its subclasses to retrieve specific kinds of sensor data. For example, the {{domxref('Accelerometer')}} interface returns the acceleration of the device along all three axes at the time it is read.

Sensors may or may not correspond exactly to a physical device sensor. For example, the {{domxref('Gyroscope')}} interface corresponds exactly to a physical device interface. Alternatively, the {{domxref('AbsoluteOrientationSensor')}} interface provides information that is algorithmically aggregated from two or more device sensors. These sensor types are referred to as _low-level_ and _high-level_ respectively. The latter type of sensor is also called a fusion sensor (alternatively, virtual or synthetic sensors).

### Feature detection

Sensor interfaces are only proxies for the underlying device sensors. Consequently, feature detection is more complicated for sensors than it is for other APIs. The presence of a sensor API does not tell you whether that API is connected to a real hardware sensor, whether that sensor works, if it's still connected, or even whether the user has granted access to it. Making all this information consistently available is costly to performance and battery life.

Therefore, feature detection for sensor APIs must include both detection of the APIs themselves and [defensive programming strategies (see below)](#defensive_programming).

The examples below show three methods for detecting sensor APIs. Additionally you can put object instantiation inside a {{jsxref('statements/try...catch', 'try...catch')}} block. Notice that detection through the {{domxref('Navigator')}} interface is not one of the available options.

```js
if (typeof Gyroscope === "function") {
  // run in circles…
}

if ("ProximitySensor" in window) {
  // watch out!
}

if (window.AmbientLightSensor) {
  // go dark…
}
```

### Defensive programming

As stated in Feature Detection, checking for a particular sensor API is insufficient for feature detection. The existence of an actual sensor must be confirmed as well. This is where defensive programming is needed. Defensive programming requires three strategies.

- Checking for thrown errors when instantiating a sensor object.
- Listening for errors thrown during its use.
- Handling the errors gracefully so that the user experience is enhanced rather than degraded.

The code example below illustrates these principles. The {{jsxref('statements/try...catch', 'try...catch')}} block catches errors thrown during sensor instantiation. It listens for {{domxref('Sensor.error_event', 'error')}} events to catch errors thrown during use. The only time anything is shown to the user is when [permissions](/en-US/docs/Web/API/Permissions_API) need to be requested and when the sensor type isn't supported by the device.

In addition, this feature may be blocked by a [Permissions Policy](/en-US/docs/Web/HTTP/Guides/Permissions_Policy) set on your server.

```js
let accelerometer = null;
try {
  accelerometer = new Accelerometer({ referenceFrame: "device" });
  accelerometer.addEventListener("error", (event) => {
    // Handle runtime errors.
    if (event.error.name === "NotAllowedError") {
      // Branch to code for requesting permission.
    } else if (event.error.name === "NotReadableError") {
      console.log("Cannot connect to the sensor.");
    }
  });
  accelerometer.addEventListener("reading", () => reloadOnShake(accelerometer));
  accelerometer.start();
} catch (error) {
  // Handle construction errors.
  if (error.name === "SecurityError") {
    // See the note above about permissions policy.
    console.log("Sensor construction was blocked by a permissions policy.");
  } else if (error.name === "ReferenceError") {
    console.log("Sensor is not supported by the User Agent.");
  } else {
    throw error;
  }
}
```

### Permissions and Permissions Policy

Sensor readings may not be taken unless the user grants permission to a specific sensor type using the [Permissions API](/en-US/docs/Web/API/Permissions_API) and/or if access is not blocked by the server {{httpheader('Permissions-Policy')}}.

The example below shows how to request user-permission before attempting to use the sensor.

```js
navigator.permissions.query({ name: "accelerometer" }).then((result) => {
  if (result.state === "denied") {
    console.log("Permission to use accelerometer sensor is denied.");
    return;
  }
  // Use the sensor.
});
```

An alternative approach is to attempt to use the sensor and listen for the `SecurityError`.

```js
const sensor = new AbsoluteOrientationSensor();
sensor.start();
sensor.addEventListener("error", (error) => {
  if (event.error.name === "SecurityError")
    console.log("No permissions to use AbsoluteOrientationSensor.");
});
```

The following table describes for each sensor type, the name required for the Permissions API, the {{HTMLElement('iframe')}} element's `allow` attribute and the {{httpheader('Permissions-Policy')}} directive.

| Sensor                      | Permission Policy Name                                 |
| --------------------------- | ------------------------------------------------------ |
| `AbsoluteOrientationSensor` | `'accelerometer'`, `'gyroscope'`, and `'magnetometer'` |
| `Accelerometer`             | `'accelerometer'`                                      |
| `AmbientLightSensor`        | `'ambient-light-sensor'`                               |
| `GravitySensor`             | `'accelerometer'`                                      |
| `Gyroscope`                 | `'gyroscope'`                                          |
| `LinearAccelerationSensor`  | `'accelerometer'`                                      |
| `Magnetometer`              | `'magnetometer'`                                       |
| `RelativeOrientationSensor` | `'accelerometer'`, and `'gyroscope'`                   |

### Readings

Sensor readings are received through the {{domxref('Sensor.reading_event', 'reading')}} event callback which is inherited by all sensor types. Reading frequency is decided by you, accomplished with an option passed to a sensor's constructor. The option is a number that specifies the number of readings per second. A whole number or decimal may be used, the latter for frequencies less than a second. The actual reading frequency depends on device hardware and consequently may be less than requested.

The following example illustrates this using the {{domxref('Magnetometer')}} sensor.

```js
let magSensor = new Magnetometer({ frequency: 60 });

magSensor.addEventListener("reading", (e) => {
  console.log(`Magnetic field along the X-axis ${magSensor.x}`);
  console.log(`Magnetic field along the Y-axis ${magSensor.y}`);
  console.log(`Magnetic field along the Z-axis ${magSensor.z}`);
});
magSensor.addEventListener("error", (event) => {
  console.log(event.error.name, event.error.message);
});
magSensor.start();
```

## Interfaces

- {{domxref('AbsoluteOrientationSensor')}}
  - : Describes the device's physical orientation in relation to the Earth's reference coordinate system.
- {{domxref('Accelerometer')}}
  - : Provides the acceleration applied to the device along all three axes.
- {{domxref('AmbientLightSensor')}}
  - : Returns the current light level or illuminance of the ambient light around the hosting device.
- {{domxref('GravitySensor')}}
  - : Provides the gravity applied to the device along all three axes.
- {{domxref('Gyroscope')}}
  - : Provides the angular velocity of the device along all three axes.
- {{domxref('LinearAccelerationSensor')}}
  - : Provides the acceleration applied to the device along all three axes, but without the contribution of gravity.
- {{domxref('Magnetometer')}}
  - : Provides information about the magnetic field as detected by the device's primary magnetometer sensor.
- {{domxref('OrientationSensor')}}
  - : The base class for the {{domxref('AbsoluteOrientationSensor')}}. This interface cannot be used directly, instead it provides properties and methods accessed by interfaces that inherit from it.
- {{domxref('RelativeOrientationSensor')}}
  - : Describes the device's physical orientation without regard to the Earth's reference coordinate system.
- {{domxref('Sensor')}}
  - : The base class for all the other sensor interfaces. This interface cannot be used directly. Instead, it provides properties, event handlers, and methods accessed by interfaces that inherit from it.
- {{domxref('SensorErrorEvent')}}
  - : Provides information about errors thrown by a {{domxref('Sensor')}} or related interface.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sensor: error event

{{securecontext_header}}{{APIRef("Sensor API")}}

The **`error`** event is fired when an exception occurs on a sensor.

The {{domxref('Sensor')}} interface is a base class, `onerror` and the `error` event may only be used
on one of the [derived classes](/en-US/docs/Web/API/Sensor#interfaces_based_on_sensor).

After this event has occurred, the {{domxref('Sensor')}} object becomes idle. If the sensor was reading values, it will stop until it restarts.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("error", (event) => { })

onerror = (event) => { }
```

## Event type

A {{domxref("SensorErrorEvent")}}. Inherits from {{domxref("Event")}}.

{{InheritanceDiagram("SensorErrorEvent")}}

## Event properties

_In addition to the properties listed below, properties from the parent interface, {{domxref("Event")}}, are available._

- {{domxref('SensorErrorEvent.error', 'error')}} {{ReadOnlyInline}}
  - : Returns the {{domxref('DOMException')}} that has been thrown.

## Examples

### Log accelerometer exceptions

This example adds an event listener to log errors occurred on an {{domxref("Accelerometer")}}.

```js
const acl = new Accelerometer({ frequency: 60 });
acl.addEventListener("error", (error) => console.log(`Error: ${error.name}`));
acl.start();
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- Sensor {{domxref('Sensor.activate_event', 'activate')}} event
- Sensor {{domxref('Sensor.reading_event', 'reading')}} event
# Sensor: hasReading property

{{securecontext_header}}{{APIRef("Sensor API")}}

The **`hasReading`** read-only
property of the {{domxref("Sensor")}} interface returns a boolean value
indicating whether the sensor has a reading.

Because {{domxref('Sensor')}} is a base class, `hasReading` may only be read
from one of its derived classes.

## Value

A boolean value.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sensor

{{securecontext_header}}{{APIRef("Sensor API")}}

The **`Sensor`** interface of the [Sensor APIs](/en-US/docs/Web/API/Sensor_APIs) is the base class for all the other sensor interfaces. This interface cannot be used directly. Instead it provides properties, event handlers, and methods accessed by interfaces that inherit from it.

This feature may be blocked by a [Permissions Policy](/en-US/docs/Web/HTTP/Guides/Permissions_Policy) set on your server.

{{InheritanceDiagram}}

When initially created, the `Sensor` object is _idle_, meaning it does not take measures. Once the {{domxref("Sensor.start()", "start()")}} method is called, it prepares itself to read data and, once ready, the {{domxref("Sensor/activate_event", "activate")}} event is sent and the sensor becomes _activated_. It then sends a {{domxref("Sensor/reading_event", "reading")}} event each time new data is available.

In case of an error, the {{domxref("Sensor/error_event", "error")}} event is sent, reading stops, and the `Sensor` object becomes _idle_ again. The {{domxref("Sensor.start()", "start()")}} method needs to be called again before it can read further data.

## Interfaces based on `Sensor`

Below is a list of interfaces based on the `Sensor` interface.

- {{domxref('Accelerometer')}}
- {{domxref('AmbientLightSensor')}}
- {{domxref('GravitySensor')}}
- {{domxref('Gyroscope')}}
- {{domxref('LinearAccelerationSensor')}}
- {{domxref('Magnetometer')}}
- {{domxref('OrientationSensor')}}

## Instance properties

- {{domxref('Sensor.activated')}} {{ReadOnlyInline}}
  - : Returns a boolean value indicating whether the sensor is active.
- {{domxref('Sensor.hasReading')}} {{ReadOnlyInline}}
  - : Returns a boolean value indicating whether the sensor has a reading.
- {{domxref('Sensor.timestamp')}} {{ReadOnlyInline}}
  - : Returns the timestamp of the latest sensor reading.

## Instance methods

- {{domxref('Sensor.start()')}}
  - : Activates one of the sensors based on `Sensor`.
- {{domxref('Sensor.stop()')}}
  - : Deactivates one of the sensors based on `Sensor`.

## Events

- {{domxref('Sensor.activate_event', 'activate')}}
  - : Fired when a sensor becomes activated.
- {{domxref('Sensor.error_event', 'error')}}
  - : Fired when an exception occurs on a sensor.
- {{domxref('Sensor.reading_event', 'reading')}}
  - : Fired when a new reading is available on a sensor.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sensor: reading event

{{securecontext_header}}{{APIRef("Sensor API")}}

The **`reading`** event is fired when a new reading is available on a sensor.

The {{domxref('Sensor')}} interface is a base class, `onreading` and the `reading` event may only be used
on one of the [derived classes](/en-US/docs/Web/API/Sensor#interfaces_based_on_sensor).

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("reading", (event) => { })

onreading = (event) => { }
```

## Event type

A generic {{domxref("Event")}} with no added properties.

## Examples

### Reading acceleration

This example adds an event listener to read acceleration values of an {{domxref("Accelerometer")}}. It reads sixty times a second.

```js
const acl = new Accelerometer({ frequency: 60 });
acl.addEventListener("reading", () => {
  console.log(`Acceleration along the X-axis ${acl.x}`);
  console.log(`Acceleration along the Y-axis ${acl.y}`);
  console.log(`Acceleration along the Z-axis ${acl.z}`);
});
acl.start();
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- Sensor {{domxref('Sensor.activate_event', 'activate')}} event
- Sensor {{domxref('Sensor.error_event', 'error')}} event
# Sensor: start() method

{{securecontext_header}}{{APIRef("Sensor API")}}

The **`start()`** method of the {{domxref("Sensor")}} interface activates one of the sensors based on `Sensor`.

## Syntax

```js-nolint
start()
```

### Parameters

None.

### Return value

None ({{jsxref("undefined")}}).

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sensor: stop() method

{{securecontext_header}}{{APIRef("Sensor API")}}

The **`stop()`** method of the {{domxref("Sensor")}} interface deactivates the current sensor.

## Syntax

```js-nolint
stop()
```

### Parameters

None.

### Return value

None ({{jsxref("undefined")}}).

## Examples

```js
// TBD
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Sensor: timestamp property

{{securecontext_header}}{{APIRef("Sensor API")}}

The **`timestamp`** read-only property
of the {{domxref("Sensor")}} interface returns the timestamp of the latest sensor
reading.

Because {{domxref('Sensor')}} is a base class, `timestamp` may only be read
from one of its derived classes.

## Value

A {{domxref("DOMHighResTimeStamp")}}.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# SensorErrorEvent: error property

{{securecontext_header}}{{APIRef("Sensor API")}}

The **`error`** read-only property of
the {{domxref("SensorErrorEvent")}} interface returns the {{domxref('DOMException')}}
object passed in the event's constructor.

## Value

A {{domxref('DOMException')}}.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# SensorErrorEvent

{{securecontext_header}}{{APIRef("Sensor API")}}

The **`SensorErrorEvent`** interface of the [Sensor APIs](/en-US/docs/Web/API/Sensor_APIs) provides information about errors thrown by a {{domxref('Sensor')}} or derived interface.

{{InheritanceDiagram}}

## Constructor

- {{domxref("SensorErrorEvent.SensorErrorEvent", "SensorErrorEvent()")}}
  - : Creates a new `SensorErrorEvent` object.

## Instance properties

- {{domxref('SensorErrorEvent.error')}} {{ReadOnlyInline}}
  - : Returns the {{domxref('DOMException')}} object passed in the event's constructor.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# SensorErrorEvent: SensorErrorEvent() constructor

{{securecontext_header}}{{APIRef("Sensor API")}}

The **`SensorErrorEvent()`** constructor
creates a new {{domxref("SensorErrorEvent")}} object which provides information about
errors thrown by any of the interfaces based on {{domxref('Sensor')}}.

## Syntax

```js-nolint
new SensorErrorEvent(type, options)
```

### Parameters

- `type`
  - : A string with the name of the event.
    It is case-sensitive and browsers always set it to `error`.
- `options`
  - : An object that, _in addition of the properties defined in {{domxref("Event/Event", "Event()")}}_, can have the following properties:
    - `error`
      - : A {{domxref('DOMException')}} object describing the error.

### Return value

A new {{domxref("SensorErrorEvent")}} object.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Serial: getPorts() method

{{APIRef("Web Serial API")}}{{SecureContext_Header}}{{SeeCompatTable}}{{AvailableInWorkers("window_and_dedicated")}}

The **`getPorts()`** method of the {{domxref("Serial")}} interface returns a {{jsxref("Promise")}} that resolves with an array of {{domxref("SerialPort")}} objects representing serial ports connected to the host which the origin has permission to access.

## Syntax

```js-nolint
getPorts()
```

### Parameters

None.

### Return value

A {{jsxref("Promise")}} that resolves with an array of {{domxref("SerialPort")}} objects.

### Exceptions

- `SecurityError` {{domxref("DOMException")}}
  - : The returned `Promise` rejects with this error in either of the following situations:
    - A {{httpheader('Permissions-Policy/serial','serial')}} [Permissions Policy](/en-US/docs/Web/HTTP/Guides/Permissions_Policy) blocks the use of this feature.
    - A user permission prompt was denied.

## Examples

The following example uses `getPorts()` to initialize a list of available ports.

```js
navigator.serial.getPorts().then((ports) => {
  // Initialize the list of available ports with `ports` on page load.
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Serial

{{securecontext_header}}{{APIRef("Web Serial API")}}{{SeeCompatTable}}{{AvailableInWorkers("window_and_dedicated")}}

The `Serial` interface of the [Web Serial API](/en-US/docs/Web/API/Web_Serial_API) provides attributes and methods for finding and connecting to serial ports from a web page.

{{InheritanceDiagram}}

## Instance methods

- {{domxref("Serial.requestPort()")}} {{Experimental_Inline}}
  - : Returns a {{jsxref("Promise")}} that resolves with an instance of {{domxref("SerialPort")}} representing the device chosen by the user. This method must be called via [transient activation](/en-US/docs/Glossary/Transient_activation).

- {{domxref("Serial.getPorts()")}} {{Experimental_Inline}}
  - : Returns a {{jsxref("Promise")}} that resolves with an array of {{domxref("SerialPort")}} objects representing serial ports connected to
    the host which the origin has permission to access.

## Events

The following events are available to `Serial` via event bubbling from {{domxref("SerialPort")}}:

- `SerialPort` {{domxref("SerialPort.connect_event", "connect")}} event
  - : An event fired when a port has been connected to the device.
- `SerialPort` {{domxref("SerialPort.disconnect_event", "disconnect")}} event
  - : An event fired when a port has been disconnected from the device.

## Examples

The following example shows how a site can check for available ports and allow the user to grant it permission to access additional ports.

On load event listeners are added for the {{domxref("SerialPort.connect_event", "connect")}} and {{domxref("SerialPort.disconnect_event", "disconnect")}} events so that the site can react when a device is connected or disconnected from the system. The {{domxref("Serial.getPorts()","getPorts()")}} method is then called to see which ports are connected that the site already has access to.

If the site doesn't have access to any connected ports it has to wait until it has user activation to proceed. In this example we use a {{domxref("Element.click_event", "click")}} event handler on a button for this task. A filter is passed to {{domxref("Serial.requestPort()","requestPort()")}} with a USB vendor ID in order to limit the set of devices shown to the user to only USB devices built by a particular manufacturer.

```js
navigator.serial.addEventListener("connect", (e) => {
  // Connect to `e.target` or add it to a list of available ports.
});

navigator.serial.addEventListener("disconnect", (e) => {
  // Remove `e.target` from the list of available ports.
});

navigator.serial.getPorts().then((ports) => {
  // Initialize the list of available ports with `ports` on page load.
});

button.addEventListener("click", () => {
  const usbVendorId = 0xabcd;
  navigator.serial
    .requestPort({ filters: [{ usbVendorId }] })
    .then((port) => {
      // Connect to `port` or add it to the list of available ports.
    })
    .catch((e) => {
      // The user didn't select a port.
    });
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Serial: requestPort() method

{{APIRef("Web Serial API")}}{{SecureContext_Header}}{{SeeCompatTable}}

The **`Serial.requestPort()`** method of the {{domxref("Serial")}} interface presents the user with a dialog asking them to select a serial device to connect to. It returns a {{jsxref("Promise")}} that resolves with an instance of {{domxref("SerialPort")}} representing the device chosen by the user.

## Description

When the user first visits a site it will not have permission to access any serial devices. A site must first call `requestPort()` to prompt the user to select which device the site should be allowed to control.

This method must be called via [transient activation](/en-US/docs/Glossary/Transient_activation). The user has to interact with the page or a UI element in order for this feature to work.

## Syntax

```js-nolint
requestPort()
requestPort(options)
```

### Parameters

- `options` {{optional_inline}}
  - : An object with the following properties:
    - `filters` {{optional_inline}}
      - : A list of objects containing vendor, product, or Bluetooth service class IDs used to filter the specific device types made available for the user to request a connection to. If no filters are specified, the user is presented with a list of every available device to choose from. Filters can contain the following values:
        - `bluetoothServiceClassId` {{optional_inline}}
          - : An unsigned long integer or string representing a Bluetooth service class ID. This can be a 16- or 32-bit UUID alias, any valid UUID, or a valid name from a [GATT assigned services key](https://github.com/WebBluetoothCG/registries/blob/master/gatt_assigned_services.txt).
        - `usbVendorId` {{optional_inline}}
          - : An unsigned short integer that identifies a USB device vendor. The [USB Implementors Forum](https://www.usb.org/) assigns IDs to specific vendors.
        - `usbProductId` {{optional_inline}}
          - : An unsigned short integer that identifies a USB device. Each vendor assigns IDs to its products.
    - `allowedBluetoothServiceClassIds` {{optional_inline}}
      - : A list of unsigned long integers and/or strings representing Bluetooth service class IDs. Bluetooth ports with custom service class IDs are excluded from the list of ports presented to the user unless the service class ID is included in this list. This is true whether you filter the list or not.

### Return value

A {{jsxref("Promise")}} that resolves with an instance of {{domxref("SerialPort")}}.

### Exceptions

- `SecurityError` {{domxref("DOMException")}}
  - : The returned `Promise` rejects with this error in either of the following situations:
    - A {{httpheader('Permissions-Policy/serial','serial')}} [Permissions Policy](/en-US/docs/Web/HTTP/Guides/Permissions_Policy) blocks the use of this feature.
    - A user permission prompt was denied.
- `NotFoundError` {{domxref("DOMException")}}
  - : The returned `Promise` rejects with this exception if the user does not select a port when prompted.

## Examples

### Allow the user to select any device

This example prompts the user to select a device via `requestPort()` when a `<button>` is pressed. It does not include a filter, which means that the selection list will include all available devices:

```html
<button id="connect">Connect</button>
```

```js
const connectBtn = document.getElementById("connect");
connectBtn.addEventListener("click", () => {
  try {
    const port = await navigator.serial.requestPort();
    // Connect to port or add it to the list of available ports
  } catch (e) {
    // The user didn't select a device
  }
});
```

### Allow the user to select a specific vendor's device

In this case, a filter is passed to `requestPort()` with a USB vendor ID to limit the set of devices shown to the user to only USB devices built by a particular manufacturer.

```js
connectBtn.addEventListener("click", () => {
  const usbVendorId = 0xabcd;
  try {
    const port = await navigator.serial.requestPort({ filters: [{ usbVendorId }] });
    // Connect to port or add it to the list of available ports
  } catch (e) {
    // The user didn't select a device
  }
});
```

### Allow the user to select custom RFCOMM-based services

Although most devices expose SPP-based communication through the standardized Bluetooth Classic Serial Port Profile, some use custom radio frequency communication (RFCOMM) based services. These devices have a Service Class ID that is not in the standard Bluetooth UUID range.

You need to pass the `allowedBluetoothServiceClassIds` list to `requestPort()` to access these custom RFCOMM-based services:

```js
const myBluetoothServiceUuid = "01234567-89ab-cdef-0123-456789abcdef";

// Prompt user to select any serial port
// Access to the custom Bluetooth RFCOMM service above will be allowed
const port = await navigator.serial.requestPort({
  allowedBluetoothServiceClassIds: [myBluetoothServiceUuid],
});
```

You can also use the `bluetoothServiceClassId` filter key when calling `requestPort()` to prompt the user with a list of filtered Bluetooth serial ports identified by Service Class IDs:

```js
const myBluetoothServiceUuid = "01234567-89ab-cdef-0123-456789abcdef";

// Prompt the user to select Bluetooth serial ports with
// the custom Bluetooth RFCOMM service above.
const port = await navigator.serial.requestPort({
  allowedBluetoothServiceClassIds: [myBluetoothServiceUuid],
  filters: [{ bluetoothServiceClassId: myBluetoothServiceUuid }],
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# SerialPort: close() method

{{APIRef("Web Serial API")}}{{SecureContext_Header}}{{SeeCompatTable}}{{AvailableInWorkers("window_and_dedicated")}}

The **`SerialPort.close()`** method of the {{domxref("SerialPort")}} interface returns a {{jsxref("Promise")}} that resolves when the port closes.

## Syntax

```js-nolint
close()
```

### Parameters

None.

### Return value

A {{jsxref("Promise")}}.

## Description

`close()` closes the serial port if previously-locked {{domxref("SerialPort.readable")}} and {{domxref("SerialPort.writable")}} members are unlocked, meaning the `releaseLock()` methods have been called for their respective reader and writer.

However, when continuously reading data from a serial device using a loop, the associated [readable stream](/en-US/docs/Web/API/ReadableStream) will always be locked until the [reader](/en-US/docs/Web/API/ReadableStreamDefaultReader) encounters an error. In this case, calling [`reader.cancel()`](/en-US/docs/Web/API/ReadableStreamDefaultReader/cancel) will force [`reader.read()`](/en-US/docs/Web/API/ReadableStreamDefaultReader/read) to resolve immediately with `{ value: undefined, done: true }` allowing the loop to call [`reader.releaseLock()`](/en-US/docs/Web/API/ReadableStreamDefaultReader/releaseLock).

```js
// Without transform streams.

let keepReading = true;
let reader;

async function readUntilClosed() {
  while (port.readable && keepReading) {
    reader = port.readable.getReader();
    try {
      while (true) {
        const { value, done } = await reader.read();
        if (done) {
          // reader.cancel() has been called.
          break;
        }
        // value is a Uint8Array.
        console.log(value);
      }
    } catch (error) {
      // Handle error...
    } finally {
      // Allow the serial port to be closed later.
      reader.releaseLock();
    }
  }

  await port.close();
}

const closedPromise = readUntilClosed();

document.querySelector("button").addEventListener("click", async () => {
  // User clicked a button to close the serial port.
  keepReading = false;
  // Force reader.read() to resolve immediately and subsequently
  // call reader.releaseLock() in the loop example above.
  reader.cancel();
  await closedPromise;
});
```

Closing a serial port is more complicated when using [transform streams](/en-US/docs/Web/API/TransformStream). See [Close a serial port](https://developer.chrome.com/docs/capabilities/serial#close-port) for guidance.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# SerialPort: connect event

{{APIRef("Web Serial API")}}{{SecureContext_Header}}{{SeeCompatTable}}{{AvailableInWorkers("window_and_dedicated")}}

The **`connect`** event of the {{domxref("SerialPort")}} interface is fired when the port connects to the device.

## Description

More specifically, the `connect` event fires when the port becomes **logically connected** to the device after a user grants permission for a site to access the port following a {{domxref("Serial.requestPort()")}} call:

- In the case of a wired serial port, this occurs when the port is physically connected to the device, for example via USB.
- In the case of a wireless serial port (for example, Bluetooth RFCOMM), this occurs when the port makes one or more active connections to the device (for example via Bluetooth L2CAP channels).

### Bubbling

This event bubbles to the instance of {{domxref("Serial")}} that returned this interface. The `event.target` property refers to the {{domxref('SerialPort')}} object that bubbles up.

For more information, see [Event bubbling](/en-US/docs/Learn_web_development/Core/Scripting/Event_bubbling).

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("connect", (event) => { })

onconnect = (event) => { }
```

## Event type

A generic {{domxref("Event")}}.

## Examples

### Notify when a specific port connects

The {{domxref("Serial.requestPort()")}} method returns a {{jsxref("Promise")}} that resolves with a {{domxref("SerialPort")}} chosen by the user.

```js
// Prompt user to choose a serial port
const port = await navigator.serial.requestPort();

port.addEventListener("connect", (event) => {
  // notify that the chosen port is connected
});
```

### Listening for any newly-connected ports

The `connect` event bubbles up to the {{domxref("Serial")}} object where you can listen for any newly-connected ports.

```js
navigator.serial.addEventListener("connect", (event) => {
  // notify that a new port is available
  // use `event.target` to refer to the newly-added port
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("SerialPort.disconnect_event", "disconnect")}} event
# SerialPort: connected property

{{SecureContext_Header}}{{APIRef("Web Serial API")}}{{SeeCompatTable}}{{AvailableInWorkers("window_and_dedicated")}}

The **`connected`** read-only property of the {{domxref("SerialPort")}} interface returns a boolean value that indicates whether the port is [logically connected](/en-US/docs/Web/API/SerialPort/connect_event#description) to the device.

## Description

When a wireless device goes out of range of the host, any wireless serial port opened by a web app automatically closes, even though it stays logically connected. In such cases, the web app could attempt to reopen the port using {{domxref("SerialPort.open()")}}.

However, if the wireless device was intentionally disconnected (for example, if the user chose to disconnect it using the operating system control panel), the web app should refrain from reopening the port to prevent reconnecting to the wireless device.

The following snippet shows how the `connected` property can be used to distinguish between these two cases:

```js
const ports = await navigator.serial.getPorts();
for (const port of ports) {
  if (port.connected) {
    // The port is logically connected
    // automatically try to reopen the port
    await port.open({ baudRate: 9600 });
  } else {
    // The port is not logically connected; at this point you could
    // prompt the user to make sure the Bluetooth device is available, and
    // Show a "connect" button to allow them to try opening the port if desired
  }
}
```

## Value

A boolean — `true` if the port is logically connected, and `false` if not.

## Examples

### Logging when a port is connected

The following snippet invokes {{domxref("Serial.requestPort()")}} when the user presses a {{htmlelement("button")}}, prompting them to choose a serial port to connect to, then logs a message to the console reporting the connection status:

```js
requestPortButton.addEventListener("click", async () => {
  const port = await navigator.serial.requestPort();
  console.log(`Requested serial port. Connected: ${port.connected}`);
});
```

### Logging connection status on connect and disconnect

You can use the following snippet to log the connection status when the {{domxref("SerialPort.connect_event", "connect")}} and {{domxref("SerialPort.disconnect_event", "disconnect")}} events fire:

```js
navigator.serial.addEventListener("connect", ({ target: port }) => {
  console.log(`Connect event fired. Connected: ${port.connected}`);
});

navigator.serial.addEventListener("disconnect", ({ target: port }) => {
  console.log(`Disconnect event fired. Connected: ${port.connected}`);
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# SerialPort: disconnect event

{{SecureContext_Header}}{{APIRef("Web Serial API")}}{{SeeCompatTable}}{{AvailableInWorkers("window_and_dedicated")}}

The **`disconnect`** event of the {{domxref("SerialPort")}} interface is fired when the port disconnects from the device.

## Description

More specifically, the `disconnect` event fires when a port that was previously [logically connected](/en-US/docs/Web/API/SerialPort/connect_event#description) after a user granted permission for a site to access it (following a {{domxref("Serial.requestPort()")}} call) is no longer connected.

### Bubbling

This event bubbles to the instance of {{domxref("Serial")}} that returned this interface. The `event.target` property refers to the {{domxref('SerialPort')}} object that bubbles up.

For more information, see [Event bubbling](/en-US/docs/Learn_web_development/Core/Scripting/Event_bubbling).

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("disconnect", (event) => { })

ondisconnect = (event) => { }
```

## Event type

A generic {{domxref("Event")}}.

## Examples

### Notify when a specific port disconnects

Here the event listener is installed on a specific {{domxref("SerialPort")}} object.

```js
port.addEventListener("disconnect", (event) => {
  // notify that the port has become unavailable
});
```

### Listening for any ports that become unavailable

The `disconnect` event bubbles up to the {{domxref("Serial")}} object where you can listen for any ports that become unavailable.

```js
navigator.serial.addEventListener("disconnect", (event) => {
  // notify that a port has become unavailable
  // use `event.target` to refer to the unavailable port
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("SerialPort.connect_event", "connect")}} event
# SerialPort: forget() method

{{securecontext_header}}{{APIRef("Web Serial API")}}{{SeeCompatTable}}{{AvailableInWorkers("window_and_dedicated")}}

The **`SerialPort.forget()`** method of the {{domxref("SerialPort")}} interface returns a {{jsxref("Promise")}} that resolves when access to the serial port is revoked.

## Description

A website can clean up permissions to access a serial port it is no longer interested in retaining by calling `SerialPort.forget()`. Calling this "forgets" the device, resetting any previously-set permissions so the calling site can no longer communicate with the port.

For example, for an educational web application used on a shared computer with many devices, a large number of accumulated user-generated permissions creates a poor user experience.

## Syntax

```js-nolint
forget()
```

### Parameters

None.

### Return value

A {{jsxref("Promise")}} that resolves with `undefined` once the connection is revoked.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# SerialPort: getInfo() method

{{SecureContext_Header}}{{APIRef("Web Serial API")}}{{SeeCompatTable}}{{AvailableInWorkers("window_and_dedicated")}}

The **`getInfo()`** method of the {{domxref("SerialPort")}} interface returns an object containing identifying information for the device available via the port.

## Syntax

```js-nolint
getInfo()
```

### Parameters

None.

### Return value

An object containing the following properties:

- `usbVendorId`
  - : If the port is part of a USB device, this property is an unsigned short integer that identifies the device's vendor. If not, it is `undefined`.
- `usbProductId`
  - : If the port is part of a USB device, this property is an unsigned short integer that identifies the USB device. If not, it is `undefined`.
- `bluetoothServiceClassId` {{experimental_inline}}
  - : If the port is a Bluetooth RFCOMM service, this property is an unsigned long integer or string representing the device's Bluetooth service class ID. If not, it is `undefined`.

## Example

This snippet calls the {{domxref("Serial.requestPort()")}} method when a `<button>` is pressed. We pass a filter to `requestPort()` to filter for Arduino Uno USB devices. Once a port is requested, we call `getInfo()` to return the device's `usbProductId` and `usbVendorId`.

```html
<button id="connect">Connect</button>
```

```js
const connectBtn = document.getElementById("connect");

// Filter for devices with the Arduino Uno USB Vendor/Product IDs
const filters = [
  { usbVendorId: 0x2341, usbProductId: 0x0043 },
  { usbVendorId: 0x2341, usbProductId: 0x0001 }
];

connectBtn.addEventListener("click", () => {
  try {
    // Prompt the user to select an Arduino Uno device
    const port = await navigator.serial.requestPort({ filters });

    // Return the device's identifying info
    const { usbProductId, usbVendorId } = port.getInfo();
  } catch (e) {
    // The user didn't select a device
  }
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# SerialPort: getSignals() method

{{SecureContext_Header}}{{APIRef("Web Serial API")}}{{SeeCompatTable}}{{AvailableInWorkers("window_and_dedicated")}}

The **`SerialPort.getSignals()`** method of the {{domxref("SerialPort")}} interface returns a {{jsxref("Promise")}} that resolves with an object containing the current state of the port's control signals.

## Syntax

```js-nolint
getSignals()
```

### Parameters

None.

### Return value

Returns a {{jsxref("Promise")}} that resolves with an object containing the following members:

- `clearToSend`
  - : A boolean indicating to the other end of a serial connection that is clear to send data.
- `dataCarrierDetect`
  - : A boolean that toggles the control signal needed to communicate over a serial connection.
- `dataSetReady`
  - : A boolean indicating whether the device is ready to send and receive data.
- `ringIndicator`
  - : A boolean indicating whether a ring signal should be sent down the serial connection.

### Exceptions

- `InvalidStateError` {{domxref("DOMException")}}
  - : Returned if the port is not open. Call {{domxref("SerialPort.open()")}} to avoid this error.
- `NetworkError` {{domxref("DOMException")}}
  - : Returned if the signals on the device could not be read.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# SerialPort

{{securecontext_header}}{{APIRef("Web Serial API")}}{{SeeCompatTable}}{{AvailableInWorkers("window_and_dedicated")}}

The `SerialPort` interface of the [Web Serial API](/en-US/docs/Web/API/Web_Serial_API) provides access to a serial port on the host device.

{{InheritanceDiagram}}

## Constructor

Instances of this interface may be obtained by calling methods of the {{domxref("Serial")}} interface, therefore it has no constructor of its own.

## Instance properties

- {{domxref("SerialPort.connected")}} {{ReadOnlyInline}} {{Experimental_Inline}}
  - : Returns a boolean value that indicates whether the port is logically connected to the device.
- {{domxref("SerialPort.readable")}} {{ReadOnlyInline}} {{Experimental_Inline}}
  - : Returns a {{domxref("ReadableStream")}} for receiving data from the device connected to the port.
- {{domxref("SerialPort.writable")}} {{ReadOnlyInline}} {{Experimental_Inline}}
  - : Returns a {{domxref("WritableStream")}} for sending data to the device connected to the port.

## Instance methods

- {{domxref("SerialPort.forget()")}} {{Experimental_Inline}}
  - : Returns a {{jsxref("Promise")}} that resolves when access to the serial port is revoked. Calling this "forgets" the device, resetting any previously-set permissions so the calling site can no longer communicate with the port.
- {{domxref("SerialPort.getInfo()")}} {{Experimental_Inline}}
  - : Returns an object containing identifying information for the device available via the port.
- {{domxref("SerialPort.open()")}} {{Experimental_Inline}}
  - : Returns a {{jsxref("Promise")}} that resolves when the port is opened. By default the port is opened with 8 data bits, 1 stop bit and no parity checking.
- {{domxref("SerialPort.setSignals()")}} {{Experimental_Inline}}
  - : Sets control signals on the port and returns a {{jsxref("Promise")}} that resolves when they are set.
- {{domxref("SerialPort.getSignals()")}} {{Experimental_Inline}}
  - : Returns a {{jsxref("Promise")}} that resolves with an object containing the current state of the port's control signals.
- {{domxref("SerialPort.close()")}} {{Experimental_Inline}}
  - : Returns a {{jsxref("Promise")}} that resolves when the port closes.

## Events

- {{domxref("SerialPort.connect_event", "connect")}} {{Experimental_Inline}}
  - : Fired when the port connects to the device.
- {{domxref("SerialPort.disconnect_event", "disconnect")}} {{Experimental_Inline}}
  - : Fired when the port disconnects from the device.

## Examples

### Opening a port

Before communicating on a serial port it must be opened. Opening the port allows the site to specify the necessary parameters that control how data is transmitted and received. Developers should check the documentation for the device they are connecting to for the appropriate parameters.

```js
await port.open({ baudRate: 9600 /* pick your baud rate */ });
```

Once the `Promise` returned by `open()` resolves the `readable` and `writable` attributes can be accessed to get the {{domxref("ReadableStream")}} and {{domxref("WritableStream")}} instances for receiving data from and sending data to the connected device.

### Reading data from a port

The following example shows how to read data from a port. The outer loop handles non-fatal errors, creating a new reader until a fatal error is encountered and `readable` becomes `null`.

```js
while (port.readable) {
  const reader = port.readable.getReader();
  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) {
        // |reader| has been canceled.
        break;
      }
      // Do something with |value|…
    }
  } catch (error) {
    // Handle |error|…
  } finally {
    reader.releaseLock();
  }
}
```

### Writing data to a port

The following example shows how to write a string to a port. A {{domxref("TextEncoder")}} converts the string to a `Uint8Array` before transmission.

```js
const encoder = new TextEncoder();
const writer = port.writable.getWriter();
await writer.write(encoder.encode("PING"));
writer.releaseLock();
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# SerialPort: open() method

{{SecureContext_Header}}{{APIRef("Web Serial API")}}{{SeeCompatTable}}{{AvailableInWorkers("window_and_dedicated")}}

The **`open()`** method of the {{domxref("SerialPort")}} interface returns a {{jsxref("Promise")}} that resolves when the port is opened. By default the port is opened with 8 data bits, 1 stop bit and no parity checking. The `baudRate` parameter is required.

## Syntax

```js-nolint
open(options)
```

### Parameters

- `options`
  - : An object with any of the following values:
    - `baudRate`
      - : A positive, non-zero value indicating the baud rate at which serial communication should be established.
    - `bufferSize` {{Optional_Inline}}
      - : An unsigned long integer indicating the size of the read and write buffers that are to be established. If not passed, defaults to 255.
    - `dataBits` {{Optional_Inline}}
      - : An integer value of 7 or 8 indicating the number of data bits per frame. If not passed, defaults to 8.
    - `flowControl` {{Optional_Inline}}
      - : The flow control type, either `"none"` or `"hardware"`. The default value is `"none"`.
    - `parity` {{Optional_Inline}}
      - : The parity mode, either `"none"`, `"even"`, or `"odd"`. The default value is `"none"`.
    - `stopBits` {{Optional_Inline}}
      - : An integer value of 1 or 2 indicating the number of stop bits at the end of the frame. If not passed, defaults to 1.

### Return value

A {{jsxref("Promise")}}.

### Exceptions

- `InvalidStateError` {{domxref("DOMException")}}
  - : Returned if the port is already open.
- `NetworkError` {{domxref("DOMException")}}
  - : Returned if the attempt to open the port failed.

## Examples

Before communicating on a serial port it must be opened. Opening the port allows the site to specify the necessary parameters that control how data is transmitted and received. Developers should check the documentation for the device they are connecting to for the appropriate parameters.

```js
await port.open({ baudRate: 9600 /* pick your baud rate */ });
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# SerialPort: readable property

{{SecureContext_Header}}{{APIRef("Web Serial API")}}{{SeeCompatTable}}{{AvailableInWorkers("window_and_dedicated")}}

The **`readable`** read-only property of the {{domxref("SerialPort")}} interface returns a {{domxref("ReadableStream")}} for receiving data from the device connected to the port. Chunks read from this stream are instances of {{jsxref("Uint8Array")}}. This property is non-null as long as the port is open and has not encountered a fatal error.

## Value

A {{domxref("ReadableStream")}}.

## Examples

The following example shows how to read data from a port. The outer loop handles non-fatal errors, creating a new reader until a fatal error is encountered and `readable` becomes `null`.

```js
while (port.readable) {
  const reader = port.readable.getReader();
  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) {
        // |reader| has been canceled.
        break;
      }
      // Do something with |value|…
    }
  } catch (error) {
    // Handle |error|…
  } finally {
    reader.releaseLock();
  }
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# SerialPort: setSignals() method

{{SecureContext_Header}}{{APIRef("Web Serial API")}}{{SeeCompatTable}}{{AvailableInWorkers("window_and_dedicated")}}

The **`setSignals()`** method of the {{domxref("SerialPort")}} interface sets control signals on the port and returns a {{jsxref("Promise")}} that resolves when they are set.

## Syntax

```js-nolint
setSignals()
setSignals(options)
```

### Parameters

- `options` {{Optional_Inline}}
  - : An object with any of the following values:
    - `dataTerminalReady`
      - : A boolean indicating whether to invoke the operating system to either assert (if true) or de-assert (if false) the "data terminal ready" or "DTR" signal on the serial port.
    - `requestToSend`
      - : A boolean indicating whether to invoke the operating system to either assert (if true) or de-assert (if false) the "request to send" or "RTS" signal on the serial port.
    - `break`
      - : A boolean indicating whether to invoke the operating system to either assert (if true) or de-assert (if false) the "break" signal on the serial port.

### Return value

A {{jsxref("Promise")}}.

### Exceptions

- `InvalidStateError` {{domxref("DOMException")}}
  - : Returned if the port is not open. Call {{domxref("SerialPort.open()")}} to avoid this error.
- `NetworkError` {{domxref("DOMException")}}
  - : Returned if the signals on the device could not be set.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# SerialPort: writable property

{{SecureContext_Header}}{{APIRef("Web Serial API")}}{{SeeCompatTable}}{{AvailableInWorkers("window_and_dedicated")}}

The **`writable`** read-only property of the {{domxref("SerialPort")}} interface returns a {{domxref("WritableStream")}} for sending data to the device connected to the port. Chunks written to this stream must be instances of {{jsxref("ArrayBuffer")}}, {{jsxref("TypedArray")}}, or {{jsxref("DataView")}}. This property is non-null as long as the port is open and has not encountered a fatal error.

## Value

A {{domxref("WritableStream")}}

## Examples

The following example shows how to write a string to a port. A {{domxref("TextEncoder")}} converts the string to a `Uint8Array` before transmission.

```js
const encoder = new TextEncoder();
const writer = port.writable.getWriter();
await writer.write(encoder.encode("PING"));
writer.releaseLock();
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# Server-sent events

{{DefaultAPISidebar("Server Sent Events")}}{{AvailableInWorkers}}

Traditionally, a web page has to send a request to the server to receive new data; that is, the page requests data from the server. With server-sent events, it's possible for a server to send new data to a web page at any time, by pushing messages to the web page. These incoming messages can be treated as _[Events](/en-US/docs/Web/API/Event) + data_ inside the web page.

## Concepts and usage

To learn how to use server-sent events, see our article [Using server-sent events](/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events).

## Interfaces

- {{domxref("EventSource")}}
  - : Defines all the features that handle connecting to a server, receiving events/data, errors, closing a connection, etc.

## Examples

- [Simple SSE demo using PHP](https://github.com/mdn/dom-examples/tree/main/server-sent-events)

## Specifications

{{Specifications}}

## See also

### Tools

- [Mercure: a real-time communication protocol (publish-subscribe) built on top of SSE](https://mercure.rocks/)
- [Transmit: a native opinionated Server-Sent-Event (SSE) module built for AdonisJS](https://docs.adonisjs.com/guides/digging-deeper/transmit)
- [EventSource polyfill for Node.js](https://github.com/EventSource/eventsource)
- Remy Sharp's [EventSource polyfill](https://github.com/remy/polyfills/blob/master/EventSource.js)
- Yaffle's [EventSource polyfill](https://github.com/Yaffle/EventSource)
- Rick Waldron's [jquery plugin](https://github.com/rwaldron/jquery.eventsource)
- intercooler.js [declarative SSE support](https://intercoolerjs.org/docs.html#sse)

### Related Topics

- [Learn: Making network requests with JavaScript](/en-US/docs/Learn_web_development/Core/Scripting/Network_requests)
- [JavaScript](/en-US/docs/Web/JavaScript)
- [WebSockets](/en-US/docs/Web/API/WebSockets_API)

### Other resources

- [Creating a wall/feed social application](https://hacks.mozilla.org/2011/06/a-wall-powered-by-eventsource-and-server-sent-events/) powered by server-sent events and [its code on GitHub](https://github.com/mozilla/webowonder-demos/tree/master/demos/friends%20timeline).
# Using server-sent events

{{DefaultAPISidebar("Server Sent Events")}}

Developing a web application that uses [server-sent events](/en-US/docs/Web/API/Server-sent_events) is straightforward. You'll need a bit of code on the server to stream events to the front-end, but the client side code works almost identically to [websockets](/en-US/docs/Web/API/WebSockets_API) in part of handling incoming events. This is a one-way connection, so you can't send events from a client to a server.

## Receiving events from the server

The server-sent event API is contained in the {{domxref("EventSource")}} interface.

### Creating an `EventSource` instance

To open a connection to the server to begin receiving events from it, create a new `EventSource` object with the URL of a script that generates the events. For example:

```js
const evtSource = new EventSource("sse-demo.php");
```

If the event generator script is hosted on a different origin, a new `EventSource` object should be created with both the URL and an options dictionary. For example, assuming the client script is on `example.com`:

```js
const evtSource = new EventSource("//api.example.com/sse-demo.php", {
  withCredentials: true,
});
```

### Listening for `message` events

Messages sent from the server that don't have an [`event`](#event) field are received as `message` events. To receive message events, attach a handler for the {{domxref("EventSource.message_event", "message")}} event:

```js
evtSource.onmessage = (event) => {
  const newElement = document.createElement("li");
  const eventList = document.getElementById("list");

  newElement.textContent = `message: ${event.data}`;
  eventList.appendChild(newElement);
};
```

This code listens for incoming message events and appends the message text to a list in the document's HTML.

### Listening for custom events

Messages from the server that do have an `event` field defined are received as events with the name given in `event`. For example:

```js
evtSource.addEventListener("ping", (event) => {
  const newElement = document.createElement("li");
  const eventList = document.getElementById("list");
  const time = JSON.parse(event.data).time;
  newElement.textContent = `ping at ${time}`;
  eventList.appendChild(newElement);
});
```

This code will be called whenever the server sends a message with the `event` field set to `ping`; it then parses the JSON in the `data` field and outputs that information.

> [!WARNING]
> When **not used over HTTP/2**, SSE suffers from a limitation to the maximum number of open connections, which can be especially painful when opening multiple tabs, as the limit is _per browser_ and is set to a very low number (6). The issue has been marked as "Won't fix" in [Chrome](https://crbug.com/275955) and [Firefox](https://bugzil.la/906896). This limit is per browser + domain, which means that you can open 6 SSE connections across all of the tabs to `www.example1.com` and another 6 SSE connections to `www.example2.com` (per [Stack Overflow](https://stackoverflow.com/questions/5195452/websockets-vs-server-sent-events-eventsource/5326159)). When using HTTP/2, the maximum number of simultaneous _HTTP streams_ is negotiated between the server and the client (defaults to 100).

## Sending events from the server

The server-side script that sends events needs to respond using the MIME type `text/event-stream`. Each notification is sent as a block of text terminated by a pair of newlines. For details on the format of the event stream, see [Event stream format](#event_stream_format).

The {{Glossary("PHP")}} code for the example we're using here follows:

```php
date_default_timezone_set("America/New_York");
header("X-Accel-Buffering: no");
header("Content-Type: text/event-stream");
header("Cache-Control: no-cache");

$counter = rand(1, 10);
while (true) {
  // Every second, send a "ping" event.

  echo "event: ping\n";
  $curDate = date(DATE_ISO8601);
  echo 'data: {"time": "' . $curDate . '"}';
  echo "\n\n";

  // Send a simple message at random intervals.

  $counter--;

  if (!$counter) {
    echo 'data: This is a message at time ' . $curDate . "\n\n";
    $counter = rand(1, 10);
  }

  if (ob_get_contents()) {
      ob_end_flush();
  }
  flush();

  // Break the loop if the client aborted the connection (closed the page)

  if (connection_aborted()) break;

  sleep(1);
}
```

The code above generates an event every second, with the event type "ping". Each event's data is a JSON object containing the ISO 8601 timestamp corresponding to the time at which the event was generated. At random intervals, a simple message (with no event type) is sent.
The loop will keep running independent of the connection status, so a check is included
to break the loop if the connection has been closed (e.g., client closes the page).

> [!NOTE]
> You can find a full example that uses the code shown in this article on GitHub — see [Simple SSE demo using PHP](https://github.com/mdn/dom-examples/tree/main/server-sent-events).

## Error handling

If the server responds with an `error` key (e.g., `JSON.parse(event.data.error)` or another problem occurs (such as a network timeout or issues pertaining to [access control](/en-US/docs/Web/HTTP/Guides/CORS)), an error event is generated. You can take action on this programmatically by implementing the `onerror` callback on the `EventSource` object:

```js
evtSource.onerror = (err) => {
  console.error("EventSource failed:", err);
};
```

## Closing event streams

By default, if the connection between the client and server closes, the connection is restarted. The connection is terminated with the `.close()` method.

```js
evtSource.close();
```

## Event stream format

The event stream is a simple stream of text data which must be encoded using [UTF-8](/en-US/docs/Glossary/UTF-8). Messages in the event stream are separated by a pair of newline characters. A colon as the first character of a line is in essence a comment, and is ignored.

> [!NOTE]
> The comment line can be used to prevent connections from timing out; a server can send a comment periodically to keep the connection alive.

Each message consists of one or more lines of text listing the fields for that message. Each field is represented by the field name, followed by a colon, followed by the text data for that field's value.

### Fields

Each message received has some combination of the following fields, one per line:

- `event`
  - : A string identifying the type of event described. If this is specified, an event will be dispatched on the browser to the listener for the specified event name; the website source code should use `addEventListener()` to listen for named events. The `onmessage` handler is called if no event name is specified for a message.
- `data`
  - : The data field for the message. When the `EventSource` receives multiple consecutive lines that begin with `data:`, [it concatenates them](https://html.spec.whatwg.org/multipage/#dispatchMessage), inserting a newline character between each one. Trailing newlines are removed.
- `id`
  - : The event ID to set the [`EventSource`](/en-US/docs/Web/API/EventSource) object's last event ID value.
- `retry`
  - : The reconnection time. If the connection to the server is lost, the browser will wait for the specified time before attempting to reconnect. This must be an integer, specifying the reconnection time in milliseconds. If a non-integer value is specified, the field is ignored.

All other field names are ignored.

> [!NOTE]
> If a line doesn't contain a colon, the entire line is treated as the field name with an empty value string.

### Examples

#### Data-only messages

In the following example, there are three messages sent. The first is just a comment, since it starts with a colon character. As mentioned previously, this can be useful as a keep-alive mechanism if messages might not be sent regularly.

The second message contains a data field with the value "some text". The third message contains a data field with the value "another message\nwith two lines". Note the newline special character in the value.

```bash
: this is a test stream

data: some text

data: another message
data: with two lines
```

#### Named events

This example sends named events. Each has an event name specified by the `event` field, and a `data` field whose value is an appropriate JSON string with the data needed for the client to act on the event. The `data` field could, of course, have any string data; it doesn't have to be JSON.

```bash
event: userconnect
data: {"username": "bobby", "time": "02:33:48"}

event: usermessage
data: {"username": "bobby", "time": "02:34:11", "text": "Hi everyone."}

event: userdisconnect
data: {"username": "bobby", "time": "02:34:23"}

event: usermessage
data: {"username": "sean", "time": "02:34:36", "text": "Bye, bobby."}
```

#### Mixing and matching

You don't have to use just unnamed messages or typed events; you can mix them together in a single event stream.

```bash
event: userconnect
data: {"username": "bobby", "time": "02:33:48"}

data: Here's a system message of some kind that will get used
data: to accomplish some task.

event: usermessage
data: {"username": "bobby", "time": "02:34:11", "text": "Hi everyone."}
```

## Browser compatibility

{{Compat}}
# Service Worker API

{{DefaultAPISidebar("Service Workers API")}}{{AvailableInWorkers}}

Service workers essentially act as proxy servers that sit between web applications, the browser, and the network (when available). They are intended, among other things, to enable the creation of effective offline experiences, intercept network requests, and take appropriate action based on whether the network is available, and update assets residing on the server. They will also allow access to push notifications and background sync APIs.

> [!NOTE]
> Service workers are a type of web worker. See [Web workers](/en-US/docs/Web/API/Web_Workers_API) for general information about worker types and use cases.

## Service worker concepts and usage

A service worker is an event-driven [worker](/en-US/docs/Web/API/Worker) registered against an origin and a path. It takes the form of a JavaScript file that can control the web page/site that it is associated with, intercepting and modifying navigation and resource requests, and caching resources in a very granular fashion to give you complete control over how your app behaves in certain situations (the most obvious one being when the network is not available).

Service workers run in a worker context: they therefore have no DOM access and run on a different thread to the main JavaScript that powers your app. They are non-blocking and designed to be fully asynchronous. As a consequence, APIs such as synchronous [XHR](/en-US/docs/Web/API/XMLHttpRequest) and [Web Storage](/en-US/docs/Web/API/Web_Storage_API) can't be used inside a service worker.

Service workers can't import JavaScript modules dynamically, and [`import()`](/en-US/docs/Web/JavaScript/Reference/Operators/import) will throw an error if it is called in a service worker global scope. Static imports using the [`import`](/en-US/docs/Web/JavaScript/Reference/Statements/import) statement are allowed.

Service workers are only available in [secure contexts](/en-US/docs/Web/Security/Secure_Contexts): this means that their document is served over HTTPS, although browsers also treat `http://localhost` as a secure context, to facilitate local development. HTTP connections are susceptible to malicious code injection by {{Glossary("MitM", "man in the middle")}} attacks, and such attacks could be worse if allowed access to these powerful APIs.

> [!NOTE]
> On Firefox, for testing you can run service workers over HTTP (insecurely); simply check the **Enable Service Workers over HTTP (when toolbox is open)** option in the Firefox DevTools options/gear menu.

> [!NOTE]
> Unlike previous attempts in this area such as [AppCache](https://alistapart.com/article/application-cache-is-a-douchebag/), service workers don't make assumptions about what you are trying to do, but then break when those assumptions are not exactly right. Instead, service workers give you much more granular control.

> [!NOTE]
> Service workers make heavy use of [promises](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise), as generally they will wait for responses to come through, after which they will respond with a success or failure action. The promises architecture is ideal for this.

### Registration

A service worker is first registered using the {{DOMxRef("ServiceWorkerContainer.register()")}} method. If successful, your service worker will be downloaded to the client and attempt installation/activation (see below) for URLs accessed by the user inside the whole origin, or a subset specified by you.

### Download, install and activate

At this point, your service worker will observe the following lifecycle:

1. Download
2. Install
3. Activate

The service worker is immediately downloaded when a user first accesses a service worker–controlled site/page.

After that, it is updated when:

- A navigation to an in-scope page occurs.
- An event is fired on the service worker and it hasn't been downloaded in the last 24 hours.

Installation is attempted when the downloaded file is found to be new — either different to an existing service worker (byte-wise compared), or the first service worker encountered for this page/site.

If this is the first time a service worker has been made available, installation is attempted, then after a successful installation, it is activated.

If there is an existing service worker available, the new version is installed in the background, but not yet activated — at this point it is called the _worker in waiting_. It is only activated when there are no longer any pages loaded that are still using the old service worker. As soon as there are no more pages to be loaded, the new service worker activates (becoming the _active worker_). Activation can happen sooner using {{DOMxRef("ServiceWorkerGlobalScope.skipWaiting()")}} and existing pages can be claimed by the active worker using {{DOMxRef("Clients.claim()")}}.

You can listen for the {{domxref("ServiceWorkerGlobalScope/install_event", "install")}} event; a standard action is to prepare your service worker for usage when this fires, for example by creating a cache using the built-in storage API, and placing assets inside it that you'll want for running your app offline.

There is also an {{domxref("ServiceWorkerGlobalScope/activate_event", "activate")}} event. The point where this event fires is generally a good time to clean up old caches and other things associated with the previous version of your service worker.

Your service worker can respond to requests using the {{DOMxRef("FetchEvent")}} event. You can modify the response to these requests in any way you want, using the {{DOMxRef("FetchEvent.respondWith()")}} method.

> [!NOTE]
> Because `install`/`activate` events could take a while to complete, the service worker spec provides a {{domxref("ExtendableEvent.waitUntil", "waitUntil()")}} method. Once it is called on `install` or `activate` events with a promise, functional events such as `fetch` and `push` will wait until the promise is successfully resolved.

For a complete tutorial to show how to build up your first basic example, read [Using Service Workers](/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers).

### Using static routing to control how resources are fetched

Service workers can incur an unnecessary performance cost — when a page is loaded for the first time in a while, the browser has to wait for the service worker to start up and run to know what content to load and whether it should come from a cache or the network.

If you already know ahead of time where certain content should be fetched from, you can bypass the service worker altogether and fetch resources immediately. The {{domxref("InstallEvent.addRoutes()")}} method can be used to implement this use case and more.

## Other use case ideas

Service workers are also intended to be used for such things as:

- Background data synchronization.
- Responding to resource requests from other origins.
- Receiving centralized updates to expensive-to-calculate data such as geolocation or gyroscope, so multiple pages can make use of one set of data.
- Client-side compiling and dependency management of CoffeeScript, less, CJS/AMD modules, etc. for development purposes.
- Hooks for background services.
- Custom templating based on certain URL patterns.
- Performance enhancements, for example, pre-fetching resources that the user is likely to need soon, such as the next few pictures in a photo album.
- API mocking.

In the future, service workers will be able to do several other useful things for the web platform that will bring it closer to native app viability. Interestingly, other specifications can and will start to make use of the service worker context, for example:

- [Background synchronization](https://github.com/WICG/background-sync): Start up a service worker even when no users are at the site, so caches can be updated, etc.
- [Reacting to push messages](/en-US/docs/Web/API/Push_API): Start up a service worker to send users a message to tell them new content is available.
- Reacting to a particular time & date.
- Entering a geo-fence.

## Interfaces

- {{DOMxRef("Cache")}}
  - : Represents the storage for {{DOMxRef("Request")}} / {{DOMxRef("Response")}} object pairs that are cached as part of the {{DOMxRef("ServiceWorker")}} life cycle.
- {{DOMxRef("CacheStorage")}}
  - : Represents the storage for {{DOMxRef("Cache")}} objects. It provides a master directory of all the named caches that a {{DOMxRef("ServiceWorker")}} can access, and maintains a mapping of string names to corresponding {{DOMxRef("Cache")}} objects.
- {{DOMxRef("Client")}}
  - : Represents the scope of a service worker client. A service worker client is either a document in a browser context or a {{DOMxRef("SharedWorker")}}, which is controlled by an active worker.
- {{DOMxRef("Clients")}}
  - : Represents a container for a list of {{DOMxRef("Client")}} objects; the main way to access the active service worker clients at the current origin.
- {{DOMxRef("ExtendableEvent")}}
  - : Extends the lifetime of the `install` and `activate` events dispatched on the {{DOMxRef("ServiceWorkerGlobalScope")}}, as part of the service worker lifecycle. This ensures that any functional events (like {{DOMxRef("FetchEvent")}}) are not dispatched to the {{DOMxRef("ServiceWorker")}}, until it upgrades database schemas, and deletes outdated cache entries, etc.
- {{DOMxRef("ExtendableMessageEvent")}}
  - : The event object of a {{domxref("ServiceWorkerGlobalScope/message_event", "message")}} event fired on a service worker (when a channel message is received on the {{DOMxRef("ServiceWorkerGlobalScope")}} from another context) — extends the lifetime of such events.
- {{DOMxRef("FetchEvent")}}
  - : The parameter passed into the {{DOMxRef("ServiceWorkerGlobalScope.fetch_event", "onfetch")}} handler, `FetchEvent` represents a fetch action that is dispatched on the {{DOMxRef("ServiceWorkerGlobalScope")}} of a {{DOMxRef("ServiceWorker")}}. It contains information about the request and resulting response, and provides the {{DOMxRef("FetchEvent.respondWith", "FetchEvent.respondWith()")}} method, which allows us to provide an arbitrary response back to the controlled page.
- {{DOMxRef("InstallEvent")}}
  - : The parameter passed into an {{DOMxRef("ServiceWorkerGlobalScope.install_event", "install")}} event handler function, the `InstallEvent` interface represents an install action that is dispatched on the {{DOMxRef("ServiceWorkerGlobalScope")}} of a {{DOMxRef("ServiceWorker")}}. As a child of {{DOMxRef("ExtendableEvent")}}, it ensures that functional events such as {{DOMxRef("FetchEvent")}} are not dispatched during installation.
- {{DOMxRef("NavigationPreloadManager")}}
  - : Provides methods for managing the preloading of resources with a service worker.
- {{DOMxRef("ServiceWorker")}}
  - : Represents a service worker. Multiple browsing contexts (e.g., pages, workers, etc.) can be associated with the same `ServiceWorker` object.
- {{DOMxRef("ServiceWorkerContainer")}}
  - : Provides an object representing the service worker as an overall unit in the network ecosystem, including facilities to register, unregister, and update service workers, and access the state of service workers and their registrations.
- {{DOMxRef("ServiceWorkerGlobalScope")}}
  - : Represents the global execution context of a service worker.
- {{DOMxRef("ServiceWorkerRegistration")}}
  - : Represents a service worker registration.
- {{DOMxRef("WindowClient")}}
  - : Represents the scope of a service worker client that is a document in a browser context, controlled by an active worker. This is a special type of {{DOMxRef("Client")}} object, with some additional methods and properties available.

### Extensions to other interfaces

- {{DOMxRef("Window.caches")}} and {{domxref("WorkerGlobalScope.caches")}}
  - : Returns the {{domxref("CacheStorage")}} object associated with the current context.
- {{DOMxRef("Navigator.serviceWorker")}} and {{DOMxRef("WorkerNavigator.serviceWorker")}}
  - : Returns a {{DOMxRef("ServiceWorkerContainer")}} object, which provides access to registration, removal, upgrade, and communication with the {{DOMxRef("ServiceWorker")}} objects for the [associated document](https://html.spec.whatwg.org/multipage/browsers.html#concept-document-window).

## Specifications

{{Specifications}}

## See also

- [Using Service Workers](/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers)
- [Service Worker Lifecycle](https://web.dev/articles/service-worker-lifecycle)
- [Service workers basic code example](https://github.com/mdn/dom-examples/tree/main/service-worker/simple-service-worker)
- Web APIs that are related to the Service Worker API:
  - {{domxref("Background Fetch API", "", "", "nocode")}}
  - {{domxref("Background Synchronization API", "", "", "nocode")}}
  - {{domxref("Content Index API", "", "", "nocode")}}
  - {{domxref("Cookie Store API", "", "", "nocode")}}
  - {{domxref("Notifications API", "", "", "nocode")}}
  - {{domxref("Payment Handler API", "", "", "nocode")}}
  - {{domxref("Push API", "", "", "nocode")}}
  - {{domxref("Web Periodic Background Synchronization API", "", "", "nocode")}}
# Using Service Workers

{{DefaultAPISidebar("Service Workers API")}}

This article provides information on getting started with service workers, including basic architecture, registering a service worker, the installation and activation process for a new service worker, updating your service worker, cache control and custom responses, all in the context of an app with offline functionality.

## The premise of service workers

One overriding problem that web users have suffered with for years is loss of connectivity. The best web app in the world will provide a terrible user experience if you can't download it. There have been various attempts to create technologies to solve this problem, and some of the issues have been solved. But the overriding problem is that there wasn't a good overall control mechanism for asset caching and custom network requests.

Service workers fix these issues. Using a service worker you can set an app up to use cached assets first, thus providing a default experience even when offline, before then getting more data from the network (commonly known as "offline first"). This is already available with native apps, which is one of the main reasons native apps are often chosen over web apps.

A service worker functions like a proxy server, allowing you to modify requests and responses replacing them with items from its own cache.

## Setting up to play with service workers

Service workers are enabled by default in all modern browsers. To run code using service workers, you'll need to serve your code via HTTPS — Service workers are restricted to running across HTTPS for security reasons. A server supporting HTTPS is necessary. To host experiments, you can use a service such as GitHub, Netlify, Vercel, etc. In order to facilitate local development, `localhost` is considered a secure origin by browsers as well.

## Basic architecture

With service workers, the following steps are generally observed for basic setup:

1. The service worker code is fetched and then registered using [`serviceWorkerContainer.register()`](/en-US/docs/Web/API/ServiceWorkerContainer/register). If successful, the service worker is executed in a [`ServiceWorkerGlobalScope`](/en-US/docs/Web/API/ServiceWorkerGlobalScope); this is basically a special kind of worker context, running off the main script execution thread, with no DOM access. The service worker is now ready to process events.
2. Installation takes place. An `install` event is always the first one sent to a service worker (this can be used to start the process of populating an IndexedDB, and caching site assets). During this step, the application is preparing to make everything available for use offline.
3. When the `install` handler completes, the service worker is considered installed. At this point a previous version of the service worker may be active and controlling open pages. Because we don't want two different versions of the same service worker running at the same time, the new version is not yet active.
4. Once all pages controlled by the old version of the service worker have closed, it's safe to retire the old version, and the newly installed service worker receives an `activate` event. The primary use of `activate` is to clean up resources used in previous versions of the service worker. The new service worker can call [`skipWaiting()`](/en-US/docs/Web/API/ServiceWorkerGlobalScope/skipWaiting) to ask to be activated immediately without waiting for open pages to be closed. The new service worker will then receive `activate` immediately, and will take over any open pages.
5. After activation, the service worker will now control pages, but only those that were opened after the `register()` is successful. In other words, documents will have to be reloaded to actually be controlled, because a document starts life with or without a service worker and maintains that for its lifetime. To override this default behavior and adopt open pages, a service worker can call [`clients.claim()`](/en-US/docs/Web/API/Clients/claim).
6. Whenever a new version of a service worker is fetched, this cycle happens again and the remains of the previous version are cleaned during the new version's activation.

![lifecycle diagram](sw-lifecycle.svg)

Here is a summary of the available service worker events:

- [`install`](/en-US/docs/Web/API/ServiceWorkerGlobalScope/install_event)
- [`activate`](/en-US/docs/Web/API/ServiceWorkerGlobalScope/activate_event)
- [`message`](/en-US/docs/Web/API/ServiceWorkerGlobalScope/message_event)
- Functional events
  - [`fetch`](/en-US/docs/Web/API/ServiceWorkerGlobalScope/fetch_event)
  - [`sync`](/en-US/docs/Web/API/ServiceWorkerGlobalScope/sync_event)
  - [`push`](/en-US/docs/Web/API/ServiceWorkerGlobalScope/push_event)

## Demo

To demonstrate just the very basics of registering and installing a service worker, we have created a demo called [simple service worker](https://github.com/mdn/dom-examples/tree/main/service-worker/simple-service-worker), which is a simple Star Wars Lego image gallery. It uses a promise-powered function to read image data from a JSON object and load the images using [`fetch()`](/en-US/docs/Web/API/Fetch_API/Using_Fetch), before displaying the images in a line down the page. We've kept things static for now. It also registers, installs, and activates a service worker.

![The words Star Wars followed by an image of a Lego version of the Darth Vader character](demo-screenshot.png)

You can see the [source code on GitHub](https://github.com/mdn/dom-examples/tree/main/service-worker/simple-service-worker), and the [simple service worker running live](https://bncb2v.csb.app/).

### Registering your worker

The first block of code in our app's JavaScript file — `app.js` — is as follows. This is our entry point into using service workers.

```js
const registerServiceWorker = async () => {
  if ("serviceWorker" in navigator) {
    try {
      const registration = await navigator.serviceWorker.register("/sw.js", {
        scope: "/",
      });
      if (registration.installing) {
        console.log("Service worker installing");
      } else if (registration.waiting) {
        console.log("Service worker installed");
      } else if (registration.active) {
        console.log("Service worker active");
      }
    } catch (error) {
      console.error(`Registration failed with ${error}`);
    }
  }
};

// …

registerServiceWorker();
```

1. The `if`-block performs a feature detection test to make sure service workers are supported before trying to register one.
2. Next, we use the [`ServiceWorkerContainer.register()`](/en-US/docs/Web/API/ServiceWorkerContainer/register) function to register the service worker for this site. The service worker code is in a JavaScript file residing inside our app (note this is the file's URL relative to the origin, not the JS file that references it.)
3. The `scope` parameter is optional, and can be used to specify the subset of your content that you want the service worker to control. In this case, we have specified `'/'`, which means all content under the app's origin. If you leave it out, it will default to this value anyway, but we specified it here for illustration purposes.

This registers a service worker, which runs in a worker context, and therefore has no DOM access.

A single service worker can control many pages. Each time a page within your scope is loaded, the service worker is installed against that page and operates on it. Bear in mind therefore that you need to be careful with global variables in the service worker script: each page doesn't get its own unique worker.

> [!NOTE]
> One great thing about service workers is that if you use feature detection like we've shown above, browsers that don't support service workers can just use your app online in the normal expected fashion.

#### Why is my service worker failing to register?

A service worker fails to register for one of the following reasons:

- You are not running your application in a [secure context](/en-US/docs/Web/Security/Secure_Contexts) (over HTTPS).
- The path of the service worker file is incorrect.
  The path must be relative to the origin, not an app's root directory.
  In our example, the worker is at `https://bncb2v.csb.app/sw.js`, and the app's root is `https://bncb2v.csb.app/`, so the service worker must be specified as `/sw.js`.
- The path to your service worker points to a service worker of a different origin to your app.
- The service worker registration contains a `scope` option broader than permitted by the worker path.
  The default scope for a service worker is the directory where the worker is located.
  In other words, if the script `sw.js` is located in `/js/sw.js`, it can only control URLs in (or nested within) the `/js/` path by default.
  The scope for a service worker can be broadened (or narrowed) with the {{HTTPHeader("Service-Worker-Allowed")}} header.
- Browser-specific settings are enabled, such as blocking all cookies, private browsing mode, automatic cookie deletion on close, etc.
  See [`serviceWorker.register()` browser compatibility](/en-US/docs/Web/API/ServiceWorkerContainer/register#browser_compatibility) for more information.

### Install and activate: populating your cache

After your service worker is registered, the browser will attempt to install then activate the service worker for your page/site.

The `install` event is the first event that is fired on service worker installation or update.
It is emitted just once, immediately after registration is successfully completed, and is generally used to populate your browser's offline caching capabilities with the assets you need to run your app offline. To do this, we use Service Worker's storage API — [`cache`](/en-US/docs/Web/API/Cache) — a global object on the service worker that allows us to store assets delivered by responses, and keyed by their requests. This API works in a similar way to the browser's standard cache, but it is specific to your domain. The contents of the cache are kept until you clear them.

Here's how our service worker handles the `install` event:

```js
const addResourcesToCache = async (resources) => {
  const cache = await caches.open("v1");
  await cache.addAll(resources);
};

self.addEventListener("install", (event) => {
  event.waitUntil(
    addResourcesToCache([
      "/",
      "/index.html",
      "/style.css",
      "/app.js",
      "/image-list.js",
      "/star-wars-logo.jpg",
      "/gallery/bountyHunters.jpg",
      "/gallery/myLittleVader.jpg",
      "/gallery/snowTroopers.jpg",
    ]),
  );
});
```

1. Here we add an `install` event listener to the service worker (hence `self`), and then chain a [`ExtendableEvent.waitUntil()`](/en-US/docs/Web/API/ExtendableEvent/waitUntil) method onto the event — this ensures that the service worker will not install until the code inside `waitUntil()` has successfully occurred.
2. Inside `addResourcesToCache()` we use the [`caches.open()`](/en-US/docs/Web/API/CacheStorage/open) method to create a new cache called `v1`, which will be version 1 of our site resources cache. Then we call a function `addAll()` on the created cache, which for its parameter takes an array of URLs to all the resources you want to cache. The URLs are relative to the worker's {{domxref("WorkerGlobalScope.location", "location", "", 1)}}.
3. If the promise is rejected, the installation fails, and the worker won't do anything. This is OK, as you can fix your code and then try again the next time registration occurs.
4. After a successful installation, the service worker activates. This doesn't have much of a distinct use the first time your service worker is installed/activated, but it means more when the service worker is updated (see the [Updating your service worker](#updating_your_service_worker) section later on.)

> [!NOTE]
> [The Web Storage API (`localStorage`)](/en-US/docs/Web/API/Web_Storage_API) works in a similar way to service worker cache, but it is synchronous, so not allowed in service workers.

> [!NOTE]
> [IndexedDB](/en-US/docs/Web/API/IndexedDB_API) can be used inside a service worker for data storage if you require it.

### Custom responses to requests

Now you've got your site assets cached, you need to tell service workers to do something with the cached content. This is done with the `fetch` event.

1. A `fetch` event fires every time any resource controlled by a service worker is fetched, which includes the documents inside the specified scope, and any resources referenced in those documents (for example if `index.html` makes a cross-origin request to embed an image, that still goes through its service worker.)

2. You can attach a `fetch` event listener to the service worker, then call the `respondWith()` method on the event to hijack our HTTP responses and update them with your own content.

   ```js
   self.addEventListener("fetch", (event) => {
     event.respondWith(/* custom content goes here */);
   });
   ```

3. We could start by responding with the resource whose URL matches that of the network request, in each case:

   ```js
   self.addEventListener("fetch", (event) => {
     event.respondWith(caches.match(event.request));
   });
   ```

   `caches.match(event.request)` allows us to match each resource requested from the network with the equivalent resource available in the cache, if there is a matching one available. The matching is done via URL and various headers, just like with normal HTTP requests.

![Fetch event diagram](sw-fetch.svg)

## Recovering failed requests

So `caches.match(event.request)` is great when there is a match in the service worker cache, but what about cases when there isn't a match? If we didn't provide any kind of failure handling, our promise would resolve with `undefined` and we wouldn't get anything returned.

After testing the response from the cache, we can fall back on a regular network request:

```js
const cacheFirst = async (request) => {
  const responseFromCache = await caches.match(request);
  if (responseFromCache) {
    return responseFromCache;
  }
  return fetch(request);
};

self.addEventListener("fetch", (event) => {
  event.respondWith(cacheFirst(event.request));
});
```

If the resources aren't in the cache, they are requested from the network.

Using a more elaborate strategy, we could not only request the resource from the network, but also save it into the cache so that later requests for that resource could be retrieved offline too. This would mean that if extra images were added to the Star Wars gallery, our app could automatically grab them and cache them. The following snippet implements such a strategy:

```js
const putInCache = async (request, response) => {
  const cache = await caches.open("v1");
  await cache.put(request, response);
};

const cacheFirst = async (request, event) => {
  const responseFromCache = await caches.match(request);
  if (responseFromCache) {
    return responseFromCache;
  }
  const responseFromNetwork = await fetch(request);
  event.waitUntil(putInCache(request, responseFromNetwork.clone()));
  return responseFromNetwork;
};

self.addEventListener("fetch", (event) => {
  event.respondWith(cacheFirst(event.request, event));
});
```

If the request URL is not available in the cache, we request the resource from the network request with `await fetch(request)`. After that, we put a clone of the response into the cache. The `putInCache()` function uses `caches.open('v1')` and `cache.put()` to add the resource to the cache. The original response is returned to the browser to be given to the page that called it.

Cloning the response is necessary because request and response streams can only be read once. In order to return the response to the browser and put it in the cache we have to clone it. So the original gets returned to the browser and the clone gets sent to the cache. They are each read once.

What might look a bit weird is that the promise returned by `putInCache()` is not awaited. The reason is that we don't want to wait until the response clone has been added to the cache before returning a response. However, we do need to call `event.waitUntil()` on the promise, to make sure the service worker doesn't terminate before the cache is populated.

The only trouble we have now is that if the request doesn't match anything in the cache, and the network is not available, our request will still fail. Let's provide a default fallback so that whatever happens, the user will at least get something:

```js
const putInCache = async (request, response) => {
  const cache = await caches.open("v1");
  await cache.put(request, response);
};

const cacheFirst = async ({ request, fallbackUrl, event }) => {
  // First try to get the resource from the cache
  const responseFromCache = await caches.match(request);
  if (responseFromCache) {
    return responseFromCache;
  }

  // Next try to get the resource from the network
  try {
    const responseFromNetwork = await fetch(request);
    // response may be used only once
    // we need to save clone to put one copy in cache
    // and serve second one
    event.waitUntil(putInCache(request, responseFromNetwork.clone()));
    return responseFromNetwork;
  } catch (error) {
    const fallbackResponse = await caches.match(fallbackUrl);
    if (fallbackResponse) {
      return fallbackResponse;
    }
    // when even the fallback response is not available,
    // there is nothing we can do, but we must always
    // return a Response object
    return new Response("Network error happened", {
      status: 408,
      headers: { "Content-Type": "text/plain" },
    });
  }
};

self.addEventListener("fetch", (event) => {
  event.respondWith(
    cacheFirst({
      request: event.request,
      fallbackUrl: "/gallery/myLittleVader.jpg",
      event,
    }),
  );
});
```

We have opted for this fallback image because the only updates that are likely to fail are new images, as everything else is depended on for installation in the `install` event listener we saw earlier.

## Service Worker navigation preload

If enabled, the [navigation preload](/en-US/docs/Web/API/NavigationPreloadManager) feature starts downloading resources as soon as the fetch request is made, and in parallel with service worker activation. This ensures that download starts immediately on navigation to a page, rather than having to wait until the service worker is activated. That delay happens relatively rarely, but is unavoidable when it does happen, and may be significant.

First the feature must be enabled during service worker activation, using [`registration.navigationPreload.enable()`](/en-US/docs/Web/API/NavigationPreloadManager/enable):

```js
self.addEventListener("activate", (event) => {
  event.waitUntil(self.registration?.navigationPreload.enable());
});
```

Then use [`event.preloadResponse`](/en-US/docs/Web/API/FetchEvent/preloadResponse) to wait for the preloaded resource to finish downloading in the `fetch` event handler.

Continuing the example from the previous sections, we insert the code to wait for the preloaded resource after the cache check, and before fetching from the network if that doesn't succeed.

The new process is:

1. Check cache
2. Wait on `event.preloadResponse`, which is passed as `preloadResponsePromise` to the `cacheFirst()` function. Cache the result if it returns.
3. If neither of these are defined then we go to the network.

```js
const addResourcesToCache = async (resources) => {
  const cache = await caches.open("v1");
  await cache.addAll(resources);
};

const putInCache = async (request, response) => {
  const cache = await caches.open("v1");
  await cache.put(request, response);
};

const cacheFirst = async ({
  request,
  preloadResponsePromise,
  fallbackUrl,
  event,
}) => {
  // First try to get the resource from the cache
  const responseFromCache = await caches.match(request);
  if (responseFromCache) {
    return responseFromCache;
  }

  // Next try to use (and cache) the preloaded response, if it's there
  const preloadResponse = await preloadResponsePromise;
  if (preloadResponse) {
    console.info("using preload response", preloadResponse);
    event.waitUntil(putInCache(request, preloadResponse.clone()));
    return preloadResponse;
  }

  // Next try to get the resource from the network
  try {
    const responseFromNetwork = await fetch(request);
    // response may be used only once
    // we need to save clone to put one copy in cache
    // and serve second one
    event.waitUntil(putInCache(request, responseFromNetwork.clone()));
    return responseFromNetwork;
  } catch (error) {
    const fallbackResponse = await caches.match(fallbackUrl);
    if (fallbackResponse) {
      return fallbackResponse;
    }
    // when even the fallback response is not available,
    // there is nothing we can do, but we must always
    // return a Response object
    return new Response("Network error happened", {
      status: 408,
      headers: { "Content-Type": "text/plain" },
    });
  }
};

// Enable navigation preload
const enableNavigationPreload = async () => {
  if (self.registration.navigationPreload) {
    await self.registration.navigationPreload.enable();
  }
};

self.addEventListener("activate", (event) => {
  event.waitUntil(enableNavigationPreload());
});

self.addEventListener("install", (event) => {
  event.waitUntil(
    addResourcesToCache([
      "/",
      "/index.html",
      "/style.css",
      "/app.js",
      "/image-list.js",
      "/star-wars-logo.jpg",
      "/gallery/bountyHunters.jpg",
      "/gallery/myLittleVader.jpg",
      "/gallery/snowTroopers.jpg",
    ]),
  );
});

self.addEventListener("fetch", (event) => {
  event.respondWith(
    cacheFirst({
      request: event.request,
      preloadResponsePromise: event.preloadResponse,
      fallbackUrl: "/gallery/myLittleVader.jpg",
      event,
    }),
  );
});
```

Note that in this example we download and cache the same data for the resource whether it is downloaded "normally" or preloaded. You can instead choose to download and cache a different resource on preload. For more information see [`NavigationPreloadManager` > Custom responses](/en-US/docs/Web/API/NavigationPreloadManager#custom_responses).

## Updating your service worker

If your service worker has previously been installed, but then a new version of the worker is available on refresh or page load, the new version is installed in the background, but not yet activated. It is only activated when there are no longer any pages loaded that are still using the old service worker. As soon as there are no more such pages still loaded, the new service worker activates.

> [!NOTE]
> It is possible to bypass this by using [`Clients.claim()`](/en-US/docs/Web/API/Clients/claim).

You'll want to update your `install` event listener in the new service worker to something like this (notice the new version number):

```js
const addResourcesToCache = async (resources) => {
  const cache = await caches.open("v2");
  await cache.addAll(resources);
};

self.addEventListener("install", (event) => {
  event.waitUntil(
    addResourcesToCache([
      "/",
      "/index.html",
      "/style.css",
      "/app.js",
      "/image-list.js",

      // …

      // include other new resources for the new version…
    ]),
  );
});
```

While the service worker is being installed, the previous version is still responsible for fetches. The new version is installing in the background. We are calling the new cache `v2`, so the previous `v1` cache isn't disturbed.

When no pages are using the previous version, the new worker activates and becomes responsible for fetches.

### Deleting old caches

As we saw in the last section, when you update a service worker to a new version, you'll create a new cache in its `install` event handler. While there are open pages that are controlled by the previous version of the worker, you need to keep both caches, because the previous version needs its version of the cache. You can use the `activate` event to remove data from the previous caches.

Promises passed into `waitUntil()` will block other events until completion, so you can rest assured that your clean-up operation will have completed by the time you get your first `fetch` event on the new service worker.

```js
const deleteCache = async (key) => {
  await caches.delete(key);
};

const deleteOldCaches = async () => {
  const cacheKeepList = ["v2"];
  const keyList = await caches.keys();
  const cachesToDelete = keyList.filter((key) => !cacheKeepList.includes(key));
  await Promise.all(cachesToDelete.map(deleteCache));
};

self.addEventListener("activate", (event) => {
  event.waitUntil(deleteOldCaches());
});
```

## Developer tools

- [Chrome](https://www.chromium.org/blink/serviceworker/service-worker-faq/)
- [Firefox](https://firefox-source-docs.mozilla.org/devtools-user/application/service_workers/index.html)
  - The "Forget about this site" button, available in [Firefox's toolbar customization options](https://support.mozilla.org/en-US/kb/customize-firefox-controls-buttons-and-toolbars), can be used to clear service workers and their caches.
- [Edge](https://learn.microsoft.com/en-us/microsoft-edge/devtools/service-workers/)

## See also

- [Promises](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
- [Using web workers](/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)
- {{HTTPHeader("Service-Worker-Allowed")}} HTTP header
# ServiceWorker: error event

{{APIRef("Service Workers API")}}{{SecureContext_Header}}{{AvailableInWorkers}}

The `error` event fires whenever an error occurs in the service worker.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("error", (event) => { })

onerror = (event) => { }
```

## Event type

A generic {{domxref("Event")}}.

## Example

The following code snippet gets a handle to the {{domxref("ServiceWorker")}} object via {{domxref("ServiceWorkerRegistration.active")}} and sets up an `onerror` handler on the resulting object:

```js
// in the page being controlled
if (navigator.serviceWorker) {
  navigator.serviceWorker.register("service-worker.js");

  navigator.serviceWorker.ready.then((registration) => {
    registration.active.onerror = (event) => {
      console.log("An error occurred in the service worker!");
    };
  });
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ServiceWorker

{{securecontext_header}}{{APIRef("Service Workers API")}}{{AvailableInWorkers}}

The **`ServiceWorker`** interface of the [Service Worker API](/en-US/docs/Web/API/Service_Worker_API) provides a reference to a service worker. Multiple {{glossary("browsing context", "browsing contexts")}} (e.g., pages, workers, etc.) can be associated with the same service worker, each through a unique `ServiceWorker` object.

A `ServiceWorker` object is available via a number of properties:

- {{domxref("ServiceWorkerRegistration.active")}}
- {{domxref("ServiceWorkerGlobalScope.serviceWorker")}}
- {{domxref("ServiceWorkerContainer.controller")}} — when the service worker is in `activating` or `activated` state
- {{domxref("ServiceWorkerRegistration.installing")}} — when the service worker is in `installing` state
- {{domxref("ServiceWorkerRegistration.waiting")}} — when the service worker is in `installed` state

The {{domxref("ServiceWorker.state")}} property and [`statechange` event](/en-US/docs/Web/API/ServiceWorker/statechange_event) can be used to check and observe changes in the lifecycle-state of the object's associated service worker.
Related lifecycle events, such as [`install`](/en-US/docs/Web/API/ServiceWorkerGlobalScope/install_event) and [`activate`](/en-US/docs/Web/API/ServiceWorkerGlobalScope/activate_event) are fired at the service worker itself.

Service workers allow static import of [ECMAScript modules](/en-US/docs/Web/JavaScript/Guide/Modules), if supported, using [`import`](/en-US/docs/Web/JavaScript/Reference/Statements/import).
Dynamic import is disallowed by the specification — calling [`import()`](/en-US/docs/Web/JavaScript/Reference/Operators/import) will throw.

Service workers can only be registered in the Window scope in some or all browsers, because the `ServiceWorker` object is not exposed to {{domxref("DedicatedWorkerGlobalScope")}} and {{domxref("SharedWorkerGlobalScope")}}.
Check the [browser compatibility](#browser_compatibility) for information.

{{InheritanceDiagram}}

## Instance properties

_The `ServiceWorker` interface inherits properties from its parent, {{domxref("EventTarget")}}._

- {{domxref("ServiceWorker.scriptURL")}} {{ReadOnlyInline}}
  - : Returns the `ServiceWorker` serialized script URL defined as part of {{domxref("ServiceWorkerRegistration")}}. The URL must be on the same origin as the document that registers the `ServiceWorker`.
- {{domxref("ServiceWorker.state")}} {{ReadOnlyInline}}
  - : Returns the state of the service worker. It returns one of the following values: `parsed`, `installing`, `installed`, `activating`, `activated`, or `redundant`.

## Instance methods

_The `ServiceWorker` interface inherits methods from its parent, {{domxref("EventTarget")}}._

- {{domxref("ServiceWorker.postMessage()")}}
  - : Sends a message — consisting of any [structured-cloneable](/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm) JavaScript object — to the service worker. The message is transmitted to the service worker using a {{domxref("ServiceWorkerGlobalScope.message_event", "message")}} event on its global scope.

## Events

- {{domxref("ServiceWorker.statechange_event", "statechange")}}
  - : Fired when {{domxref("ServiceWorker.state")}} changes.

- {{domxref("ServiceWorker.error_event", "error")}}
  - : Fired when an error happens inside the `ServiceWorker` object.

## Examples

This code snippet is from the [service worker registration-events sample](https://github.com/GoogleChrome/samples/blob/gh-pages/service-worker/registration-events/index.html) ([live demo](https://googlechrome.github.io/samples/service-worker/registration-events/)). The code listens for any change in the {{domxref("ServiceWorker.state")}} and returns its value.

```js
if ("serviceWorker" in navigator) {
  navigator.serviceWorker
    .register("service-worker.js", {
      scope: "./",
    })
    .then((registration) => {
      let serviceWorker;
      if (registration.installing) {
        serviceWorker = registration.installing;
        document.querySelector("#kind").textContent = "installing";
      } else if (registration.waiting) {
        serviceWorker = registration.waiting;
        document.querySelector("#kind").textContent = "waiting";
      } else if (registration.active) {
        serviceWorker = registration.active;
        document.querySelector("#kind").textContent = "active";
      }
      if (serviceWorker) {
        // logState(serviceWorker.state);
        serviceWorker.addEventListener("statechange", (e) => {
          // logState(e.target.state);
        });
      }
    })
    .catch((error) => {
      // Something went wrong during registration. The service-worker.js file
      // might be unavailable or contain a syntax error.
    });
} else {
  // The current browser doesn't support service workers.
  // Perhaps it is too old or we are not in a Secure Context.
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [The Offline Cookbook](https://web.dev/articles/offline-cookbook) (service workers)
- [Using Service Workers](/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers)
- [Service worker basic code example](https://github.com/mdn/dom-examples/tree/main/service-worker/simple-service-worker)
- [Using web workers](/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)
# ServiceWorker: postMessage() method

{{APIRef("Service Workers API")}}{{securecontext_header}}{{AvailableInWorkers}}

The **`postMessage()`** method of the {{domxref("ServiceWorker")}} interface sends a message to the worker. The first parameter is the data to send to the worker. The data may be any JavaScript object which can be handled by the [structured clone algorithm](/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).

The service worker can send back information to its clients by using the {{domxref("Client.postMessage", "postMessage()")}} method. The message will not be sent back to this `ServiceWorker` object but to the associated {{domxref("ServiceWorkerContainer")}} available via {{domxref("navigator.serviceWorker")}}.

## Syntax

```js-nolint
postMessage(message)
postMessage(message, transfer)
postMessage(message, options)
```

### Parameters

- `message`
  - : The object to deliver to the worker; this will be in the `data` field in the event delivered to the {{domxref("ServiceWorkerGlobalScope.message_event", "message")}} event. This may be any JavaScript object handled by the [structured clone algorithm](/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).

    The `message` parameter is mandatory. If the data to be passed to the worker is unimportant, `null` or `undefined` must be passed explicitly.

    > [!NOTE]
    > A service worker is not in the same [agent cluster](/en-US/docs/Web/JavaScript/Reference/Execution_model#agent_clusters_and_memory_sharing) as its client, and therefore cannot share memory. {{jsxref("SharedArrayBuffer")}} objects, or buffer views backed by one, cannot be posted across agent clusters. Trying to do so will generate a {{domxref("BroadcastChannel/messageerror_event", "messageerror")}} event containing a `DataCloneError` {{domxref("DOMException")}} on the receiving end.

- `transfer` {{optional_inline}}
  - : An optional [array](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) of [transferable objects](/en-US/docs/Web/API/Web_Workers_API/Transferable_objects) to transfer ownership of. The ownership of these objects is given to the destination side and they are no longer usable on the sending side. These transferable objects should be attached to the message; otherwise they would be moved but not actually accessible on the receiving end.
- `options` {{optional_inline}}
  - : An optional object containing the following properties:
    - `transfer` {{optional_inline}}
      - : Has the same meaning as the `transfer` parameter.

### Return value

None ({{jsxref("undefined")}}).

### Exceptions

- {{jsxref("SyntaxError")}}
  - : Thrown if the `message` parameter is not provided.

## Examples

In this example a {{domxref("ServiceWorker")}} is created and a message is immediately sent:

```js
navigator.serviceWorker.register("service-worker.js");

navigator.serviceWorker.ready.then((registration) => {
  registration.active.postMessage(
    "Test message sent immediately after creation",
  );
});
```

In order to receive the message, the service worker, in `service-worker.js` has to listen to the {{domxref("ServiceWorkerGlobalScope.message_event", "message")}} event on its global scope.

```js
// This must be in `service-worker.js`
addEventListener("message", (event) => {
  console.log(`Message received: ${event.data}`);
});
```

Note that the service worker can send back messages to the main thread using the {{domxref("Client.postMessage()", "postMessage()")}} method. To receive it, the main thread needs to listen for a {{domxref("ServiceWorkerContainer.message_event", "message")}} event on the {{domxref("ServiceWorkerContainer")}} object.

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- The {{domxref("ServiceWorker")}} interface it belongs to.
- Its counterpart, the {{domxref("Client.postMessage()", "postMessage()")}} method that a service worker must use to send a message back to the associated {{domxref("ServiceWorkerContainer")}}.
# ServiceWorker: scriptURL property

{{APIRef("Service Workers API")}}{{SecureContext_Header}}{{AvailableInWorkers}}

Returns the `ServiceWorker` serialized script URL defined as part of [`ServiceWorkerRegistration`](/en-US/docs/Web/API/ServiceWorkerRegistration).
Must be on the same origin as the document that registers the
`ServiceWorker`.

## Value

A string.

## Examples

```js
const sw = navigator.serviceWorker.controller;
console.log(sw.scriptURL);
// https://example.com/scripts/service-worker.js
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ServiceWorker: state property

{{APIRef("Service Workers API")}}{{SecureContext_Header}}{{AvailableInWorkers}}

The **`state`** read-only property of the
{{domxref("ServiceWorker")}} interface returns a string representing the current state
of the service worker. It can be one of the following values: `parsed`, `installing`,
`installed`, `activating`, `activated`, or
`redundant`.

## Value

A {{jsxref("String")}} that can take one of the following values:

- `"parsed"`
  - : The initial state of a service worker after it is downloaded and confirmed to be runnable.
    A service worker is never updated to this state, so this will never be the value of the {{DOMxRef("ServiceWorker.statechange_event", "statechange")}} event.
- `"installing"`
  - : The service worker in this state is considered an installing worker. During this state, {{DOMxRef("ExtendableEvent.waitUntil()")}} can be called inside the `install` event handler to extend the life of the installing worker until the passed promise resolves successfully. This is primarily used to ensure that the service worker is not active until all of the core caches are populated.
- `"installed"`
  - : The service worker in this state is considered a waiting worker.
- `"activating"`
  - : The service worker in this state is considered an active worker. During this state, {{DOMxRef("ExtendableEvent.waitUntil()")}} can be called inside the `onactivate` event handler to extend the life of the active worker until the passed promise resolves successfully. No functional events are dispatched until the state becomes activated.
- `"activated"`
  - : The service worker in this state is considered an active worker ready to handle functional events.
- `"redundant"`
  - : A new service worker is replacing the current service worker, or the current service worker is being discarded due to an install failure.

## Examples

This code snippet is from the [service worker registration-events sample](https://github.com/GoogleChrome/samples/blob/gh-pages/service-worker/registration-events/index.html) ([live demo](https://googlechrome.github.io/samples/service-worker/registration-events/)). The code listens for any change in the `ServiceWorker.state`
and returns its value.

```js
let serviceWorker;
if (registration.installing) {
  serviceWorker = registration.installing;
  document.querySelector("#kind").textContent = "installing";
} else if (registration.waiting) {
  serviceWorker = registration.waiting;
  document.querySelector("#kind").textContent = "waiting";
} else if (registration.active) {
  serviceWorker = registration.active;
  document.querySelector("#kind").textContent = "active";
}

if (serviceWorker) {
  logState(serviceWorker.state);
  serviceWorker.addEventListener("statechange", (e) => {
    logState(e.target.state);
  });
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ServiceWorker: statechange event

{{APIRef("Service Workers API")}}{{SecureContext_Header}}{{AvailableInWorkers}}

The `statechange` event fires anytime the {{domxref("ServiceWorker.state")}} changes.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("statechange", (event) => { })

onstatechange = (event) => { }
```

## Event type

A generic {{domxref("Event")}}.

## Examples

This code snippet is from the [service worker registration-events sample](https://github.com/GoogleChrome/samples/blob/gh-pages/service-worker/registration-events/index.html) ([live demo](https://googlechrome.github.io/samples/service-worker/registration-events/)). The code listens for any change in the {{domxref("ServiceWorker.state")}}
and returns its value.

```js
let serviceWorker;
if (registration.installing) {
  serviceWorker = registration.installing;
  document.querySelector("#kind").textContent = "installing";
} else if (registration.waiting) {
  serviceWorker = registration.waiting;
  document.querySelector("#kind").textContent = "waiting";
} else if (registration.active) {
  serviceWorker = registration.active;
  document.querySelector("#kind").textContent = "active";
}

if (serviceWorker) {
  logState(serviceWorker.state);
  serviceWorker.addEventListener("statechange", (e) => {
    logState(e.target.state);
  });
}
```

Note that when `statechange` fires, the service worker's references may have
changed. For example:

```js
navigator.serviceWorker.register("/sw.js").then((swr) => {
  swr.installing.state = "installing";
  swr.installing.onstatechange = () => {
    swr.installing = null;
    // At this point, swr.waiting OR swr.active might be true. This is because the statechange
    // event gets queued, meanwhile the underlying worker may have gone into the waiting
    // state and will be immediately activated if possible.
  };
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ServiceWorkerContainer: controller property

{{APIRef("Service Workers API")}}{{SecureContext_Header}}{{AvailableInWorkers}}

The **`controller`** read-only property of the {{domxref("ServiceWorkerContainer")}} interface represents the active {{domxref("ServiceWorker","service worker","","nocode")}} controlling the current page (associated with this `ServiceWorkerContainer`), or `null` if the page has no active or activating service worker.

This is the same object returned by {{domxref("ServiceWorkerRegistration.active")}}.

## Value

A {{domxref("ServiceWorker")}} object if its state is `activating` or `activated`, or `null` if there is no active worker.

The property also returns `null` if the request is a force refresh (<kbd>Shift</kbd> + refresh)

## Examples

### Test if a page is controlled by a service worker

```js
if ("serviceWorker" in navigator) {
  // Do a one-off check to see if a service worker's in control.
  if (navigator.serviceWorker.controller) {
    console.log(
      `This page is currently controlled by: ${navigator.serviceWorker.controller}`,
    );
  } else {
    console.log("This page is not currently controlled by a service worker.");
  }
} else {
  console.log("Service workers are not supported.");
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ServiceWorkerContainer: controllerchange event

{{APIRef("Service Workers API")}}{{SecureContext_Header}}{{AvailableInWorkers}}

The **`controllerchange`** event of the {{domxref("ServiceWorkerContainer")}} interface fires when the document's associated {{domxref("ServiceWorkerRegistration")}} acquires a new {{domxref("ServiceWorkerRegistration.active","active")}} worker.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("controllerchange", (event) => { })

oncontrollerchange = (event) => { }
```

## Event type

A generic {{domxref("Event")}}.

## Example

```js
navigator.serviceWorker.addEventListener("controllerchange", () => {
  console.log("The controller of current browsing context has changed.");
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ServiceWorkerContainer: getRegistration() method

{{APIRef("Service Workers API")}}{{SecureContext_Header}}{{AvailableInWorkers}}

The **`getRegistration()`** method of the
{{domxref("ServiceWorkerContainer")}} interface gets a
{{domxref("ServiceWorkerRegistration")}} object whose scope URL matches the provided
client URL. The method returns a {{jsxref("Promise")}} that resolves to
a {{domxref("ServiceWorkerRegistration")}} or `undefined`.

## Syntax

```js-nolint
getRegistration()
getRegistration(clientURL)
```

### Parameters

- `clientURL` {{optional_inline}}
  - : The registration whose scope matches this URL will be returned. Relative URLs are resolved with the current client as the base. If this parameter is not provided, the current client's URL will be used by default.

### Return value

A {{jsxref("Promise")}} that resolves to a {{domxref("ServiceWorkerRegistration")}}
object or `undefined`.

## Examples

```js
navigator.serviceWorker.getRegistration("/app").then((registration) => {
  if (registration) {
    document.querySelector("#status").textContent =
      "ServiceWorkerRegistration found.";
  }
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ServiceWorkerContainer: getRegistrations() method

{{APIRef("Service Workers API")}}{{SecureContext_Header}}{{AvailableInWorkers}}

The **`getRegistrations()`** method of the
{{domxref("ServiceWorkerContainer")}} interface gets all
{{domxref("ServiceWorkerRegistration")}}s associated with a
`ServiceWorkerContainer`, in an array. The method returns a
{{jsxref("Promise")}} that resolves to an array of
{{domxref("ServiceWorkerRegistration")}}.

## Syntax

```js-nolint
getRegistrations()
```

### Parameters

None.

### Return value

A {{jsxref("Promise")}} that resolves to an array of
{{domxref("ServiceWorkerRegistration")}} objects.

## Examples

```js
navigator.serviceWorker.getRegistrations().then((registrations) => {
  document.querySelector("#status").textContent =
    "ServiceWorkerRegistrations found.";
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ServiceWorkerContainer

{{APIRef("Service Workers API")}}{{SecureContext_Header}}{{AvailableInWorkers}}

The **`ServiceWorkerContainer`** interface of the [Service Worker API](/en-US/docs/Web/API/Service_Worker_API) provides an object representing the service worker as an overall unit in the network ecosystem, including facilities to register, unregister and update service workers, and access the state of service workers and their registrations.

Most importantly, it exposes the {{domxref("ServiceWorkerContainer.register()")}} method used to register service workers, and the {{domxref("ServiceWorkerContainer.controller")}} property used to determine whether or not the current page is actively controlled.

`ServiceWorkerContainer` objects are exposed in the Window scope through {{domxref("Navigator.serviceWorker")}} and in workers using {{domxref("WorkerNavigator.serviceWorker")}} (if supported — check [browser compatibility](#browser_compatibility)).

{{InheritanceDiagram}}

## Instance properties

- {{domxref("ServiceWorkerContainer.controller")}} {{ReadOnlyInline}}
  - : A {{domxref("ServiceWorker")}} object that represents the active service worker controlling the current page or `null` if the page has no active or activating service worker.
- {{domxref("ServiceWorkerContainer.ready")}} {{ReadOnlyInline}}
  - : Returns a {{jsxref('Promise')}} that resolves with the {{domxref("ServiceWorkerRegistration")}} associated with the current page, but only when there is an active service worker.
    This provides a mechanism to defer code execution until a service worker is active.

## Instance methods

- {{domxref("ServiceWorkerContainer.getRegistration()")}}
  - : Gets a {{domxref("ServiceWorkerRegistration")}} object whose scope matches the provided document URL. The method returns a {{jsxref("Promise")}} that resolves to a {{domxref("ServiceWorkerRegistration")}} or `undefined`.
- {{domxref("ServiceWorkerContainer.getRegistrations()")}}
  - : Returns all {{domxref("ServiceWorkerRegistration")}} objects associated with a `ServiceWorkerContainer` in an array. The method returns a {{jsxref("Promise")}} that resolves to an array of {{domxref("ServiceWorkerRegistration")}}.
- {{domxref("ServiceWorkerContainer.register()")}}
  - : Creates or updates a {{domxref("ServiceWorkerRegistration")}} for the given `scriptURL`.
- {{domxref("ServiceWorkerContainer.startMessages()")}}
  - : Explicitly starts the flow of messages being dispatched from a service worker to pages under its control (e.g., sent via {{domxref("Client.postMessage()")}}). This can be used to react to sent messages earlier, even before that page's content has finished loading.

## Events

- {{domxref("ServiceWorkerContainer/controllerchange_event", "controllerchange")}}
  - : Fired when the document's associated {{domxref("ServiceWorkerRegistration")}} acquires a new {{domxref("ServiceWorkerRegistration.active","active")}} worker.
- {{domxref("ServiceWorkerContainer/message_event", "message")}}
  - : Fired when incoming messages are received by the `ServiceWorkerContainer` object (e.g., via a {{domxref("MessagePort.postMessage()")}} call).
- {{domxref("ServiceWorkerContainer/messageerror_event", "messageerror")}}
  - : Fired when incoming messages can not deserialized by the `ServiceWorkerContainer` object (e.g., via a {{domxref("MessagePort.postMessage()")}} call).

## Examples

The example below first checks to see if the browser supports service workers. If supported, the code registers the service worker and determines if the page is actively controlled by the service worker. If it isn't, it prompts the user to reload the page so the service worker can take control. The code also reports any registration failures.

```js
if ("serviceWorker" in navigator) {
  // Register a service worker hosted at the root of the
  // site using the default scope.
  navigator.serviceWorker
    .register("/sw.js")
    .then((registration) => {
      console.log("Service worker registration succeeded:", registration);

      // At this point, you can optionally do something
      // with registration. See https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration
    })
    .catch((error) => {
      console.error(`Service worker registration failed: ${error}`);
    });

  // Independent of the registration, let's also display
  // information about whether the current page is controlled
  // by an existing service worker, and when that
  // controller changes.

  // First, do a one-off check if there's currently a
  // service worker in control.
  if (navigator.serviceWorker.controller) {
    console.log(
      "This page is currently controlled by:",
      navigator.serviceWorker.controller,
    );
  }

  // Then, register a handler to detect when a new or
  // updated service worker takes control.
  navigator.serviceWorker.oncontrollerchange = () => {
    console.log(
      "This page is now controlled by",
      navigator.serviceWorker.controller,
    );
  };
} else {
  console.log("Service workers are not supported.");
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Using Service Workers](/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers)
- [Service workers basic code example](https://github.com/mdn/dom-examples/tree/main/service-worker/simple-service-worker)
- [Using web workers](/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)
# ServiceWorkerContainer: message event

{{APIRef("Service Workers API")}}{{SecureContext_Header}}{{AvailableInWorkers}}

The **`message`** event is used in a page controlled by a service worker to receive messages from the service worker.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("message", (event) => { })

onmessage = (event) => { }
```

## Event type

A {{domxref("MessageEvent")}}. Inherits from {{domxref("Event")}}.

{{InheritanceDiagram("MessageEvent")}}

## Event properties

_This interface also inherits properties from its parent, {{domxref("Event")}}._

- {{domxref("MessageEvent.data")}} {{ReadOnlyInline}}
  - : The data sent by the message emitter.
- {{domxref("MessageEvent.origin")}} {{ReadOnlyInline}}
  - : A string representing the origin of the message emitter.
- {{domxref("MessageEvent.lastEventId")}} {{ReadOnlyInline}}
  - : A string representing a unique ID for the event.
- {{domxref("MessageEvent.source")}} {{ReadOnlyInline}}
  - : A `MessageEventSource` (which can be a {{glossary("WindowProxy")}}, {{domxref("MessagePort")}}, or {{domxref("ServiceWorker")}} object) representing the message emitter.
- {{domxref("MessageEvent.ports")}} {{ReadOnlyInline}}
  - : An array of {{domxref("MessagePort")}} objects representing the ports associated with the channel the message is being sent through (where appropriate, e.g., in channel messaging or when sending a message to a shared worker).

## Examples

In this example the service worker get the client's ID from a [`fetch`](/en-US/docs/Web/API/ServiceWorkerGlobalScope/fetch_event) event and then sends it a message using [`Client.postMessage`](/en-US/docs/Web/API/Client/postMessage):

```js
// service-worker.js
async function messageClient(clientId) {
  const client = await clients.get(clientId);
  client.postMessage("Hi client!");
}

addEventListener("fetch", (event) => {
  messageClient(event.clientId);
  event.respondWith(() => {
    // …
  });
});
```

The client can receive the message by listening to the `message` event:

```js
// main.js
navigator.serviceWorker.addEventListener("message", (message) => {
  console.log(message);
});
```

Alternatively, the client can receive the message with the `onmessage` event handler:

```js
// main.js
navigator.serviceWorker.onmessage = (message) => {
  console.log(message);
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Using Service Workers](/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers)
- [Service workers basic code example](https://github.com/mdn/dom-examples/tree/main/service-worker/simple-service-worker)
- [Using web workers](/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)
# ServiceWorkerContainer: messageerror event

{{APIRef("Service Workers API")}}{{SecureContext_Header}}{{AvailableInWorkers}}

The **`messageerror`** event is fired to the {{domxref("ServiceWorkerContainer")}} when an incoming message sent to the associated worker can't be deserialized.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("messageerror", (event) => { })

onmessageerror = (event) => { }
```

## Event type

A {{domxref("MessageEvent")}}. Inherits from {{domxref("Event")}}.

{{InheritanceDiagram("MessageEvent")}}

## Event properties

_This interface also inherits properties from its parent, {{domxref("Event")}}._

- {{domxref("MessageEvent.data")}} {{ReadOnlyInline}}
  - : The data sent by the message emitter.
- {{domxref("MessageEvent.origin")}} {{ReadOnlyInline}}
  - : A string representing the origin of the message emitter.
- {{domxref("MessageEvent.lastEventId")}} {{ReadOnlyInline}}
  - : A string representing a unique ID for the event.
- {{domxref("MessageEvent.source")}} {{ReadOnlyInline}}
  - : A `MessageEventSource` (which can be a {{glossary("WindowProxy")}}, {{domxref("MessagePort")}}, or {{domxref("ServiceWorker")}} object) representing the message emitter.
- {{domxref("MessageEvent.ports")}} {{ReadOnlyInline}}
  - : An array of {{domxref("MessagePort")}} objects representing the ports associated with the channel the message is being sent through (where appropriate, e.g., in channel messaging or when sending a message to a shared worker).

## Examples

In this example the service worker get the client's ID from a {{domxref("ServiceWorkerGlobalScope/fetch_event", "fetch")}} event and then sends it a message using {{domxref("Client.postMessage")}}:

```js
// service-worker.js
async function messageClient(clientId) {
  const client = await self.clients.get(clientId);
  client.postMessage("Hi client!");
}

self.addEventListener("fetch", (event) => {
  messageClient(event.clientId);
  event.respondWith(() => {
    // …
  });
});
```

The service worker can listen for the message deserialization error by listening to the `messageerror` event:

```js
// main.js
navigator.serviceWorker.addEventListener("messageerror", (event) => {
  console.error("Receive message from service worker failed!");
});
```

Alternatively, the script can listen for the message deserialization error using `onmessageerror`:

```js
// main.js
navigator.serviceWorker.onmessageerror = (event) => {
  console.error("Receive message from service worker failed!");
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("ServiceWorkerContainer/message_event", "message")}}
- {{domxref("Client.postMessage()")}}
- [Using Service Workers](/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers)
- [Service workers basic code example](https://github.com/mdn/dom-examples/tree/main/service-worker/simple-service-worker)
- [Using Web Workers](/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)
# ServiceWorkerContainer: ready property

{{APIRef("Service Workers API")}}{{SecureContext_Header}}{{AvailableInWorkers}}

The **`ready`** read-only property of the {{domxref("ServiceWorkerContainer")}} interface provides a way of delaying code execution until a service worker is active.

The property returns a {{jsxref("Promise")}} that will never reject, and which waits indefinitely until the {{domxref("ServiceWorkerRegistration")}} associated with the current page has an {{domxref("ServiceWorkerRegistration.active","active")}} worker.
Once that condition is met, it resolves with the {{domxref("ServiceWorkerRegistration")}}.

## Value

A {{jsxref("Promise")}} that will never reject, and which may eventually resolve with a {{domxref("ServiceWorkerRegistration")}} when there is an active service worker.

## Examples

### Deferring code until there is an active service worker

```js
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.ready.then((registration) => {
    console.log(`A service worker is active: ${registration.active}`);

    // At this point, you can call methods that require an active
    // service worker, like registration.pushManager.subscribe()
  });
} else {
  console.error("Service workers are not supported.");
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ServiceWorkerContainer: register() method

{{APIRef("Service Workers API")}}{{SecureContext_Header}}{{AvailableInWorkers}}

The **`register()`** method of the {{domxref("ServiceWorkerContainer")}} interface creates or updates a {{domxref("ServiceWorkerRegistration")}} for the given scope.
If successful, the registration associates the provided script URL to a _scope_, which is subsequently used for matching documents to a specific service worker.

A single registration is created for each unique scope.
If `register()` is called for a scope that has an existing registration, the registration is updated with any changes to the scriptURL or options.
If there are no changes, then the existing registration is returned.
Calling `register()` with the same scope and `scriptURL` does not restart the installation process, so it is generally safe to call this method unconditionally from a controlled page.
However, it does send a network request for the service worker script, which may put more load on the server.
If this is a concern, you can first check for an existing registration using {{domxref("ServiceWorkerContainer.getRegistration()")}}.

A document can potentially be within the scope of several registrations with different service workers and options.
The browser will associate the document with the matching registration that has the most specific scope.
This ensures that only one service worker runs for each document.

> [!NOTE]
> It is generally safer not to define registrations that have overlapping scopes.

## Syntax

```js-nolint
register(scriptURL)
register(scriptURL, options)
```

### Parameters

- `scriptURL`
  - : The URL of the service worker script.
    The registered service worker file needs to have a valid [JavaScript MIME type](/en-US/docs/Web/HTTP/Guides/MIME_types#textjavascript).
- `options` {{optional_inline}}
  - : An object containing registration options. Currently available options are:
    - `scope`
      - : A string representing a URL that defines a service worker's registration scope; that is, what range of URLs a service worker can control.

        This is usually specified as a URL that is relative to the base URL of the site (e.g., `/some/path/`), so that the resolved scope is the same irrespective of what page the registration code is called from.
        The default `scope` for a service worker registration is the directory where the service worker script is located (resolving `./` against `scriptURL`).

        The scope should be used to specify documents that are in the same directory or more deeply nested than the service worker.
        If you need a broader scope, this can be permitted via the HTTP {{HTTPHeader("Service-Worker-Allowed")}} header.
        See the [Examples](#examples) section for information on broadening the default scope of a service worker.

    - `type`
      - : A string specifying the type of worker to create.
        Valid values are:
        - `'classic'`
          - : The loaded service worker is in a standard script.
            This is the default.
        - `'module'`
          - : The loaded service worker is in an [ES module](/en-US/docs/Web/JavaScript/Guide/Modules) and the import statement is available on worker contexts.
            For ES module compatibility info, see the [browser compatibility data table for the `ServiceWorker` interface](/en-US/docs/Web/API/ServiceWorker#browser_compatibility).

    - `updateViaCache`
      - : A string indicating how the HTTP cache is used for service worker scripts resources during updates.
        Note: This only refers to the service worker script and its imports, not other resources fetched by these scripts.
        - `'all'`
          - : The HTTP cache will be queried for the main script, and all imported scripts. If no fresh entry is found in the HTTP cache, then the scripts are fetched from the network.
        - `'imports'`
          - : The HTTP cache will be queried for imports, but the main script will always be updated from the network. If no fresh entry is found in the HTTP cache for the imports, they're fetched from the network.
        - `'none'`
          - : The HTTP cache will not be used for the main script or its imports. All service worker script resources will be updated from the network.

### Return value

A {{jsxref("Promise")}} that resolves with a {{domxref("ServiceWorkerRegistration")}} object.

### Exceptions

- `TypeError`
  - : The `scriptURL` or `scope URL` is a failure.
    This can happen if the URL can't be resolved to a valid URL or uses a scheme that is not `http:` or `https`.
    It may also happen if `scriptURL` is not a {{domxref("TrustedScriptURL")}}, and this is a requirement of the site's [Trusted Types Policy](/en-US/docs/Web/API/Trusted_Types_API).

    The exception is also raised if the `scriptURL` or `scope URL` path contains the case-insensitive ASCII "%2f" (`*`) or "%5c" (`=`)

- `SecurityError` {{domxref("DOMException")}}
  - : The `scriptURL` is not a potentially trustworthy origin, such as `localhost` or an `https` URL.
    The `scriptURL` and scope are not same-origin with the registering page.

## Examples

The examples below should be read together to understand how service worker scope applies to a page.

### Register a service worker with default scope

The following example uses the default value of `scope` by omitting it, which sets it to be the same location as the script URL.

Suppose the service worker code is at `example.com/sw.js`, and the registration code at `example.com/index.html`.
The service worker code will control `example.com/index.html`, as well as pages underneath it, like `example.com/product/description.html`.

```js
if ("serviceWorker" in navigator) {
  // Register a service worker hosted at the root of the
  // site using the default scope.
  navigator.serviceWorker.register("/sw.js").then(
    (registration) => {
      console.log("Service worker registration succeeded:", registration);
    },
    (error) => {
      console.error(`Service worker registration failed: ${error}`);
    },
  );
} else {
  console.error("Service workers are not supported.");
}
```

Note that we have registered the `scriptURL` relative to the site root rather than the current page.
This allows the same registration code to be used from any page.

### Register a service worker with an explicit default scope

The code below is almost identical, except we have specified the scope explicitly using `{ scope: "/" }`.
We've specified the scope as site-relative so the same registration code can be used from anywhere in the site.

```js
if ("serviceWorker" in navigator) {
  // declaring scope manually
  navigator.serviceWorker.register("./sw.js", { scope: "/" }).then(
    (registration) => {
      console.log("Service worker registration succeeded:", registration);
    },
    (error) => {
      console.error(`Service worker registration failed: ${error}`);
    },
  );
} else {
  console.error("Service workers are not supported.");
}
```

This scope is the same as the default scope, so the registration applies to exactly the same pages as the previous example.
Note that if we were to run this code after the previous example, browsers should recognize that we're updating an existing registration rather than a new one.

### Register a service worker using page-relative URLs

There is nothing to stop you from using page-relative URLs except that this makes it harder to move your pages around, and it is easy to accidentally create unwanted registrations if you do so.

In this example the service worker code is at `example.com/product/sw.js`, and the registration code at `example.com/product/description.html`.
We're using URLs that are relative to the current directory for the `scriptURL` and the `scope`, where the current directory is the base URL of the page that is calling `register()` (`example.com/product/`).
The service worker applies to resources under `example.com/product/`.

```js
if ("serviceWorker" in navigator) {
  // declaring scope manually
  navigator.serviceWorker.register("./sw.js", { scope: "./" }).then(
    (registration) => {
      console.log("Service worker registration succeeded:", registration);
    },
    (error) => {
      console.error(`Service worker registration failed: ${error}`);
    },
  );
} else {
  console.error("Service workers are not supported.");
}
```

### Using Service-Worker-Allowed to increase service worker scope

A service worker can't have a scope broader than its own location, unless the server specifies a broader maximum scope in a {{HTTPHeader("Service-Worker-Allowed")}} header on the service worker script.
Use the `scope` option when you need a _narrower_ scope than the default.

The following code, if included in `example.com/index.html`, at the root of a site, would only apply to resources under `example.com/product`.

```js
if ("serviceWorker" in navigator) {
  // declaring scope manually
  navigator.serviceWorker.register("./sw.js", { scope: "/product/" }).then(
    (registration) => {
      console.log("Service worker registration succeeded:", registration);
    },
    (error) => {
      console.error(`Service worker registration failed: ${error}`);
    },
  );
} else {
  console.error("Service workers are not supported.");
}
```

As noted above, servers can change the default scope by setting the `Service-Worker-Allowed` header on the service worker script.
This allows the `scope` option to be set outside the path defined by the service worker's location.

The following code, if included in `example.com/product/index.html`, would apply to all resources under `example.com` if the server set the `Service-Worker-Allowed` header to `/` or `https://example.com/` when serving `sw.js`. If the server doesn't set the header, the service worker registration will fail, as the requested `scope` is too broad.

```js
if ("serviceWorker" in navigator) {
  // Declaring a broadened scope
  navigator.serviceWorker.register("./sw.js", { scope: "/" }).then(
    (registration) => {
      // The registration succeeded because the Service-Worker-Allowed header
      // had set a broadened maximum scope for the service worker script
      console.log("Service worker registration succeeded:", registration);
    },
    (error) => {
      // This happens if the Service-Worker-Allowed header doesn't broaden the scope
      console.error(`Service worker registration failed: ${error}`);
    },
  );
} else {
  console.error("Service workers are not supported.");
}
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [ServiceWorkerRegistration: `unregister()` method](/en-US/docs/Web/API/ServiceWorkerRegistration/unregister)
- [Service worker API](/en-US/docs/Web/API/Service_Worker_API)
- [Using service workers](/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers)
- {{HTTPHeader("Service-Worker-Allowed")}} HTTP header
# ServiceWorkerContainer: startMessages() method

{{APIRef("Service Workers API")}}{{SecureContext_Header}}{{AvailableInWorkers}}

The **`startMessages()`** method of
the {{domxref("ServiceWorkerContainer")}} interface explicitly starts the flow of
messages being dispatched from a service worker to pages under its control (e.g., sent
via {{domxref("Client.postMessage()")}}). This can be used to react to sent messages
earlier, even before that page's content has finished loading.

## Explanation

By default, all messages sent from a page's controlling service worker to the page
(using {{domxref("Client.postMessage()")}}) are queued while the page is loading, and
get dispatched once the page's HTML document has been loaded and parsed (i.e., after the
{{domxref("Document/DOMContentLoaded_event", "DOMContentLoaded")}} event fires). It's possible to start dispatching these
messages earlier by calling `ServiceWorkerContainer.startMessages()`, for
example if you've invoked a message handler using
{{domxref("EventTarget.addEventListener()")}} before the page has finished loading, but
want to start processing the messages right away.

> [!NOTE]
> The messages start being sent automatically when setting the
> handler directly using {{domxref("ServiceWorkerContainer.message_event", "onmessage")}}. In this you
> don't need `startMessages()`.

## Syntax

```js-nolint
startMessages()
```

### Parameters

None.

### Return value

`undefined`.

## Examples

```js
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("/sw.js").then(() => {
    console.log("Service Worker Registered");
  });
}

// …

navigator.serviceWorker.addEventListener("message", (e) => {
  // …
});

navigator.serviceWorker.startMessages();
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}
# ServiceWorkerGlobalScope: activate event

{{APIRef("Service Workers API")}}{{SecureContext_Header}}{{AvailableInWorkers("service")}}

The **`activate`** event of the {{domxref("ServiceWorkerGlobalScope")}} interface is fired when a {{domxref("ServiceWorkerRegistration")}} acquires a new {{domxref("ServiceWorkerRegistration.active")}} worker.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("activate", (event) => { })

onactivate = (event) => { }
```

## Event type

An {{domxref("ExtendableEvent")}}. Inherits from {{domxref("Event")}}.

{{InheritanceDiagram("ExtendableEvent")}}

## Event properties

_Doesn't implement any specific properties, but inherits properties from its parent, {{domxref("Event")}}._

## Examples

The following snippet shows how you could use an `activate` event handler to upgrade a cache.

```js
self.addEventListener("activate", (event) => {
  const cacheAllowlist = ["v2"];

  event.waitUntil(
    caches.keys().then((cacheNames) =>
      Promise.all(
        cacheNames.map((cacheName) => {
          if (!cacheAllowlist.includes(cacheName)) {
            return caches.delete(cacheName);
          }
          return undefined;
        }),
      ),
    ),
  );
});
```

You can also set up the event handler using the `onactivate` property:

```js
self.onactivate = (event) => {
  // …
};
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- {{domxref("ServiceWorkerGlobalScope/install_event", "install")}} event
- {{domxref("ServiceWorkerGlobalScope")}}
- [Service Worker API](/en-US/docs/Web/API/Service_Worker_API)
# ServiceWorkerGlobalScope: backgroundfetchabort event

{{APIRef("Background Fetch API")}}{{SeeCompatTable}}{{SecureContext_Header}}{{AvailableInWorkers("service")}}

The **`backgroundfetchabort`** event of the {{domxref("ServiceWorkerGlobalScope")}} interface is fired when the user or the app itself cancels a [background fetch](/en-US/docs/Web/API/Background_Fetch_API) operation.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("backgroundfetchabort", (event) => { })

onbackgroundfetchabort = (event) => { }
```

## Event type

A {{domxref("BackgroundFetchEvent")}}.

{{InheritanceDiagram("BackgroundFetchEvent")}}

## Event properties

_Inherits properties from its parent, {{domxref("ExtendableEvent")}}._

- {{domxref("BackgroundFetchEvent.registration")}}
  - : Returns the {{domxref("BackgroundFetchRegistration")}} for the aborted fetch.

## Description

In the background fetch API, the browser shows a UI element to the user to indicate the progress of the operation. This element also enables the user to cancel the fetch. The app itself can also cancel the fetch by calling {{domxref("BackgroundFetchRegistration.abort()")}}.

If the fetch is canceled, the browser aborts the fetch, starts the service worker, if necessary, and fires the `backgroundfetchabort` event in the service worker's global scope.

In the handler for this event, the service worker can clean up any related data for the operation. It can also retrieve and store any successful responses (for example, using the {{domxref("Cache")}} API). To access the response data, the service worker uses the event's {{domxref("BackgroundFetchEvent/registration", "registration")}} property.

## Examples

### Cleaning up

This event handler might perform any cleanup of data associated with the aborted fetch.

```js
addEventListener("backgroundfetchabort", (event) => {
  // clean up any related data
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Background Fetch API](/en-US/docs/Web/API/Background_Fetch_API)
# ServiceWorkerGlobalScope: backgroundfetchclick event

{{APIRef("Background Fetch API")}}{{SeeCompatTable}}{{SecureContext_Header}}{{AvailableInWorkers("service")}}

The **`backgroundfetchclick`** event of the {{domxref("ServiceWorkerGlobalScope")}} interface is fired when the user clicks on the UI that the browser provides to show the user the progress of the [background fetch](/en-US/docs/Web/API/Background_Fetch_API) operation.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("backgroundfetchclick", (event) => { })

onbackgroundfetchclick = (event) => { }
```

## Event type

A {{domxref("BackgroundFetchEvent")}}.

{{InheritanceDiagram("BackgroundFetchEvent")}}

## Event properties

_Inherits properties from its parent, {{domxref("ExtendableEvent")}}._

- {{domxref("BackgroundFetchEvent.registration")}}
  - : Returns the {{domxref("BackgroundFetchRegistration")}} whose progress dialog the user clicked on.

## Description

When a [background fetch](/en-US/docs/Web/API/Background_Fetch_API) operation starts, the browser shows a UI element to the user to indicate the progress of the operation. If the user clicks this element, the browser starts the service worker, if necessary, and fires the `backgroundfetchclick` event in the service worker's global scope.

A common task for the handler in this situation is to open a window giving the user more details about the fetch operation.

## Examples

### Opening a window with more details

This event handler uses the global {{domxref("ServiceWorkerGlobalScope.clients", "clients")}} property to open a window giving the user more details about the fetch. It opens a different window depending on whether the fetch has completed or not.

```js
addEventListener("backgroundfetchclick", (event) => {
  const registration = event.registration;

  if (registration.result === "success") {
    clients.openWindow("/play-movie");
  } else {
    clients.openWindow("/movie-download-progress");
  }
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Background Fetch API](/en-US/docs/Web/API/Background_Fetch_API)
# ServiceWorkerGlobalScope: backgroundfetchfail event

{{APIRef("Background Fetch API")}}{{SeeCompatTable}}{{SecureContext_Header}}{{AvailableInWorkers("service")}}

The **`backgroundfetchfail`** event of the {{domxref("ServiceWorkerGlobalScope")}} interface is fired when a [background fetch](/en-US/docs/Web/API/Background_Fetch_API) operation has failed: that is, when at least one network request in the fetch has failed to complete successfully.

This event is not cancelable and does not bubble.

## Syntax

Use the event name in methods like {{domxref("EventTarget.addEventListener", "addEventListener()")}}, or set an event handler property.

```js-nolint
addEventListener("backgroundfetchfail", (event) => { })

onbackgroundfetchfail = (event) => { }
```

## Event type

A {{domxref("BackgroundFetchUpdateUIEvent")}}.

{{InheritanceDiagram("BackgroundFetchUpdateUIEvent")}}

## Event properties

_Inherits properties from its parent, {{domxref("BackgroundFetchEvent")}}._

- {{domxref("BackgroundFetchUpdateUIEvent.updateUI()")}}
  - : Updates the UI of the element that the browser displays to show the progress of the fetch operation.

## Description

When a [background fetch](/en-US/docs/Web/API/Background_Fetch_API) operation fails (meaning that at least one of the individual network requests has not completed successfully), the browser starts the service worker, if necessary, and fires the `backgroundfetchfail` event in the service worker's global scope.

In the background fetch API, the browser shows a UI element to the user to indicate the progress of the operation. In the `backgroundfetchfail` handler, the service worker can update that UI to show that the operation has failed. To do this, the handler calls the event's {{domxref("BackgroundFetchUpdateUIEvent/updateUI", "updateUI()")}} method, passing in a new title and/or icons.

In the handler for this `backgroundfetchfail`, the service worker can also clean up any related data for the operation. It can also retrieve and store any successful responses (for example, using the {{domxref("Cache")}} API). To access the response data, the service worker uses the event's {{domxref("BackgroundFetchEvent/registration", "registration")}} property.

## Examples

### Updating UI

This event handler updates the UI to let the user know that the operation failed.

```js
addEventListener("backgroundfetchfail", (event) => {
  event.updateUI({ title: "Could not complete download" });
});
```

## Specifications

{{Specifications}}

## Browser compatibility

{{Compat}}

## See also

- [Background Fetch API](/en-US/docs/Web/API/Background_Fetch_API)
